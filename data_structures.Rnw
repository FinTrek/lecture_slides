% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}



% Title page setup
\title[\texttt{R} Data Objects]{\texttt{R} Data Objects}
\subtitle{FRE6871 \texttt{R} in Finance, Spring 2015}
\institute[NYU Polytechnic]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{\today}



%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Data Objects}


%%%%%%%%%%%%%%%
\subsection{Data Objects in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      All data objects in \texttt{R} are \emph{vectors}, or consist of \emph{vectors},
      \vskip1ex
      Single numbers and character strings are vectors of length \texttt{"1"},
      \vskip1ex
      \emph{Atomic} vectors are \emph{homogeneous} objects whose elements are all of the same \emph{mode} (type), 
      \vskip1ex
      \emph{Lists} and \emph{data frames} are \emph{recursive} (heterogeneous) objects, whose elements can be vectors of different \emph{mode},
      \vskip1ex
      The functions \texttt{is.atomic()} and \texttt{is.recursive()} return logical values depending on whether their arguments are \emph{atomic} or \emph{recursive},
      \vskip1ex
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{\texttt{R} Data Objects}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{\emph{Atomic}} & \text{\emph{Recursive}} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# single numbers are vectors of length 1
1
# character strings are vectors of length 1
"a"
# strings without quotes are variable names
a  # variable "a" doesn't exist
# list elements can have different mode
list(aa=c('a', 'b'), bb=1:5)
data.frame(aa=c('a', 'b'), bb=1:2)
is.atomic(data.frame(aa=c('a', 'b'), bb=1:2))
is.recursive(data.frame(aa=c('a', 'b'), bb=1:2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type, Mode, and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{type}, \emph{mode}, and \emph{class} are \texttt{character} strings representing various object properties,
      \vskip1ex
      The \emph{type} of an atomic object represents how it's stored in memory (\texttt{logical}, \texttt{character}, \texttt{integer}, \texttt{double}, etc.)
      \vskip1ex
      The \emph{mode} of an atomic object is the kind of data it represents (\texttt{logical}, \texttt{character}, \texttt{numeric}, etc.)
      \vskip1ex
      The \emph{mode} of an object often coincides with its \emph{type} (except for \texttt{integer} and \texttt{double} types),
      \vskip1ex
      Recursive objects (\texttt{lists}, \texttt{data frames}) have both \emph{type} and \emph{mode} equal to the recursive type (\texttt{list}),
      \vskip1ex
      The \emph{class} of an object is given by either an explicit \emph{class} attribute, or is derived from the object \emph{mode} and its \texttt{dim} attribute (implicit \emph{class}), 
      \vskip1ex
      The function \texttt{class()} returns the explicit or implicit \emph{class} of an object,
      \vskip1ex
      The object \emph{class} is used for method dispatching in the \texttt{S3} object-oriented programming system in \texttt{R},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- "hello"
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- runif(5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(1:10, 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(runif(10), 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- list(aa=c('a', 'b'), bb=1:5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- data.frame(aa=c('a', 'b'), bb=1:2)
c(typeof(my_var), mode(my_var), class(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Object Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} objects can have different attributes, such as: \texttt{names}, \texttt{dimnames}, \texttt{dimensions}, \emph{class}, etc., 
      \vskip1ex
      The attributes of an object is a named \texttt{list} of \texttt{symbol=value} pairs,
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
      \vskip1ex
      The attributes of an \texttt{R} object can be modified using the \texttt{"attributes() <-"} assignment,
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it,
      \vskip1ex
      A \texttt{vector} that is assigned an attribute other than \texttt{names} is not treated as a \texttt{vector},
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# a simple vector has no attributes
attributes(5:10)
my_var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
# named vector has "names" attribute
attributes(my_var)
my_var <- 1:10
is.vector(my_var)  # is the object a vector?
attributes(my_var) <- list(my_attr="foo")
my_var
is.vector(my_var)  # is the object a vector?
my_var <- 0
attributes(my_var) <- list(class="Date")
my_var  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Modifying \protect\emph{class} Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Objects without an explicit \emph{class} don't have a \emph{class} attribute, and the function \texttt{class()} returns the implicit \emph{class},
      \vskip1ex
      The \emph{class} of an object can be modified using the \texttt{"class() <-"} assignment,
      \vskip1ex
      An object can have a main \emph{class}, and also an inherited \emph{class} (the \emph{class} attribute can be a vector of strings),
      \vskip1ex
      The function \texttt{unclass()} removes the explicit class attribute from an object,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- matrix(runif(10), 2, 5)
class(my_var)  # has implicit class
# but no explicit "class" attribute
attributes(my_var)
c(typeof(my_var), mode(my_var), class(my_var))
# assign explicit "class" attribute
class(my_var) <- "my_class"
class(my_var)  # has explicit "class"
# has explicit "class" attribute
attributes(my_var)
is.matrix(my_var)  # is the object a matrix?
is.vector(my_var)  # is the object a vector?
attributes(unclass(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Implicit Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an object has no explicit \emph{class}, then its implicit \emph{class} is derived from its \emph{mode} and \texttt{dim} attribute (except for \texttt{integer} vectors which have the implicit class \texttt{"integer"} derived from their \emph{type}), 
      \vskip1ex
      If an \emph{atomic} object has a \texttt{dim} attribute, then its implicit \emph{class} is \texttt{matrix} or \texttt{array}, 
      \vskip1ex
      \texttt{Data frames} have no explicit \texttt{dim} attribute, but \texttt{dim()} returns a value, so they have an implicit \texttt{dim} attribute, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# integer implicit class derived from type
my_var <- vector(mode="integer", length=10)
c(typeof(my_var), mode(my_var), class(my_var))
# numeric implicit class derived from mode
my_var <- vector(mode="numeric", length=10)
c(typeof(my_var), mode(my_var), class(my_var))
# adding dim attribute changes implicit class to matrix
dim(my_var) <- c(5, 2)
c(typeof(my_var), mode(my_var), class(my_var))
# data frames have implicit dim attribute
my_var <- data.frame(aa=c('a', 'b'), bb=1:2)
c(typeof(my_var), mode(my_var), class(my_var))
attributes(my_var)
dim(my_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Object Coercion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Coercion} means changing the \emph{type}, \emph{mode}, or \emph{class} of an object, often without changing the underlying data,
      \vskip1ex
      Changing the \emph{mode} of an object can change its \emph{class} as well, but not always,
      \vskip1ex
      Objects can be explicitly coerced using the \texttt{"as.*"} coercion functions,
      \vskip1ex
      Most coercion functions strip the \emph{attributes} from the object,
      \vskip1ex
      Implicit coercion occurs when objects with different \texttt{modes} are combined into a vector, forcing the elements to have the same \emph{mode},
      \vskip1ex
      Implicit coercion can cause bugs that are difficult to trace,
      \vskip1ex
      The rule is that coercion is into larger types (\texttt{numeric} objects are coerced into \texttt{character} strings),
      \vskip1ex
      Coercion can introduce bad data, such as \texttt{NA} values,
    \column{0.5\textwidth}
      \vspace{-2em}
      <<>>=
my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))
mode(my_var) <- "character"  # coerce to "character"
my_var
c(typeof(my_var), mode(my_var), class(my_var))
# explicitly coerce to "character"
my_var <- as.character(1:5)
c(typeof(my_var), mode(my_var), class(my_var))
mat_rix <- matrix(1:10, 2, 5)  # create matrix
# explicitly coerce to "character"
mat_rix <- as.character(mat_rix)
c(typeof(mat_rix), mode(mat_rix), class(mat_rix))
# coercion converted matrix to vector
c(is.matrix(mat_rix), is.vector(mat_rix))
as.logical(0:3)  # explicit coercion to "logical"
as.numeric(c(FALSE, TRUE, TRUE, TRUE))
c(1:3, 'a')  # implicit coercion to "character"
# explicit coercion to "numeric"
as.numeric(c(1:3, 'a'))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Atomic Data Objects}


%%%%%%%%%%%%%%%
\subsection{Basic \texttt{R} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The quotation marks \texttt{""} (or \texttt{''}) around a character string tell \texttt{R} that it's a string, not a variable name,
      \vskip1ex
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"},
      \vskip1ex
      A character string is also a vector with a single element, with the first element of the vector containing the string of text,
      \vskip1ex
      The colon binary operator \texttt{':'} produces a vector,
      \vskip1ex
      The function \texttt{c()} combines objects into a vector,
      \vskip1ex
      The \texttt{"[1]"} symbol means the return value is a vector,
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
"Hello World!"  # type some text
# hello is a variable name, because it's not in quotes
hello  # R interprets "hello" as a variable name
is.vector(1)  # single number is a vector
is.vector("a")  # string is a vector
4:8  # create a vector
# create vector using c() combine function
c(1, 2, 3, 4, 5)
# create vector using c() combine function
c('a', 'b', 'c')
# create vector using c() combine function
c(1, 'b', 'c')
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one),
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string,
      \vskip1ex
      Special characters in strings:\\
      \texttt{"\textbackslash{}t"} for TAB,\\
      \texttt{"\textbackslash{}n"} for new-line,\\
      "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{cat()} concatenates strings and echos them to console, without returning any values,
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
str_var <- "Some string"
str_var
str_var[1]
str_var[2]

length(str_var)  # length of vector
nchar(str_var)  # length of string

# concatenate and echo to console
cat("Hello", "World!")
cat("Enter\ttab")
cat("Enter\nnewline")
cat("Enter\\backslash")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, coerces them to characters if needed, and returns the string,
      \vskip1ex
      If a vector or list is passed to \texttt{paste()}, together with a \texttt{collapse} string, then \texttt{paste()} concatenates the elements into a string, separated by the \texttt{collapse} string,
      \vskip1ex
      The function \texttt{strsplit()} splits the elements of a character vector,
      \vskip1ex
      Splitting on the \texttt{"."} character requires surrounding it with brackets: \texttt{"[.]"}, or using argument \texttt{fixed=TRUE},
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string,
      \vskip1ex
      The recycling rule extends the length to match the longest object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str_var1 <- "Hello"  # define a character string
str_var2 <- "World!"  # define a character string
paste(str_var1, str_var2, sep=' ')  # concatenate and return value
cat(str_var1, str_var2)  # concatenate and echo to console
paste('a', 1:4, sep='-')  # convert, recycle and concatenate
paste(c("a1", "a2", "a3"), collapse="+")  # collapse vector to string
paste(list("a1", "a2", "a3"), collapse="+")
paste("Today is", Sys.time())  # coerce and concatenate strings
paste("Today is", format(Sys.time(), "%B-%d-%Y"))
strsplit("Hello World", split='r')  # split string
strsplit("Hello.World", split='[.]')  # split string
strsplit("Hello.World", split='.', fixed=TRUE)  # split string
substring("Hello World", 3, 6)  # extract characters from 3 to 6
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has Regex functions for pattern matching and replacement, 
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string,
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string,
      \vskip1ex
      The function \texttt{glob2rx()} converts globbing wildcard patterns into regular expressions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
gsub("is", "XX", "is this gratis?")  # replace "is" with "XX"

grep("b+", c("abc", "xyz", "cba d", "bbb"))  # get indexes

grep("b+", c("abc", "xyz", "cba d", "bbb"), value=TRUE)  # get values

glob2rx("abc.*")  # convert globs into regex
glob2rx("*.doc")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"},
      \vskip1ex
      The function \texttt{c()} combines values into a vector,
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise,
      \vskip1ex
      The object \texttt{letters} is a constant and a vector,
     \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
is.vector(1)  # single number is a vector
is.vector("a")  # string is a vector
vec_tor <- c(8, 6, 5, 7)  # create vector
vec_tor
vec_tor[2]  # extract second element
# extract all elements, except the second element
vec_tor[-2]
# create boolean vector
c(FALSE, TRUE, TRUE)
# extract second and third elements
vec_tor[c(FALSE, TRUE, TRUE)]
letters[5:10]  # vector of letters
c('a', letters[5:10])  # combine two vectors of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Creating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The colon operator (\texttt{":"}) provides a simple way of creating a numeric vector,
      \vskip1ex
      The function \texttt{vector()} returns a vector of the specified \emph{mode},
      \vskip1ex
      The functions \texttt{seq()}, \texttt{seq\_len()}, and \texttt{seq\_along()} return a sequence (vector) of numbers,
      \vskip1ex
      The function \texttt{rep()} replicates an object multiple times,
      \vskip1ex
      The functions \texttt{numeric()} and \texttt{character()} return empty (zero length) vectors of the specified \emph{type} (not to be confused with a \texttt{NULL} object),
      \vskip1ex
      Zero length vectors are not \texttt{NULL} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
0:10  # vector of integers from 0 to 10
vector()  # create empty vector
vector(mode="numeric", length=10)  # numeric vector of zeros
seq(10)  # sequence from 1 to 10
seq(along=(-5:5))  # instead of 1:length(obj)
seq_along(c("a", "b", "c"))  # instead of 1:length(obj)
seq(from=0, to=1, len=11)  # decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # decimals from 0 to 1.0
seq(-2,2, len=11)  # 10 numbers from -2 to 2
rep(100, times=5)  # replicate a number
character(5)  # create empty character vector
numeric(5)  # create empty numeric vector
numeric(0)  # create zero length vector
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Arithmetic and Logical Operations on \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vectors can be multiplied and squared element by element, as if they were single elements,
      \vskip1ex
      When vectors are manipulated as if they were single elements, then \texttt{R} automatically performs a loop over the vector elements, and applies the operation element-wise,
      \vskip1ex
      This is a very powerful feature of \texttt{R} called \emph{vectorized arithmetic},
      \vskip1ex
      \emph{Vectorized arithmetic} avoids writing loops and simplifies notation,
      \vskip1ex
      Vectors can be combined together and appended,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
2*4:8  # multiply a vector
2*(4:8)  # multiply a vector
4:8/2  # divide a vector
(0:10)/10  # divide vector - decimals from 0 to 1.0
vec_tor <- c(8, 6, 5, 7)  # create vector
vec_tor
# boolean vector TRUE if element is equal to second one
vec_tor == vec_tor[2]
# boolean vector TRUE for elements greater than six
vec_tor > 6
2*vec_tor  # multiply all elements by 2
vec_tor^2  # square all elements
c(11, 5:10)  # combine two vectors
c(vec_tor, 2.0)  # append number to vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Naming and Manipulating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vector elements can be assigned \texttt{names} using a list of symbol-value pairs,
      \vskip1ex
      The function \texttt{names()} returns the \texttt{names} attribute of an object,
      \vskip1ex
      The \texttt{names} attribute of a vector can be modified by assigning to the \texttt{names()} function ("\texttt{names() <-}" assignment),
      \vskip1ex
      The function \texttt{unname()} removes the \texttt{names} attribute,
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
vec_tor <- # create named vector
  c(pi_const=pi, euler=exp(1), gamma=-digamma(1))
vec_tor
names(vec_tor)  # get names of elements
vec_tor["euler"]  # get element named "euler"
names(vec_tor) <- c("pie","eulery","gammy")  # rename elements
vec_tor
unname(vec_tor)  # remove names attribute
letters[5:10]  # vector of letters
c('a', letters[5:10])  # combine two vectors of letters
# create named vector
structure(sample(1:5), names=paste0("el", 1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vector elements can be \emph{subset} (indexed, dereferenced) using the \texttt{"[]"} operator,
      \vskip1ex
      Vectors can be \emph{subset} using vectors of:
      \begin{itemize}
        \item positive integers,
        \item negative integers,
        \item characters (names),
        \item boolean vectors,
      \end{itemize}
      \vskip1ex
      Negative integers remove the vector elements,
      \vskip1ex
      Subsetting with \texttt{zero} returns a zero-length vector,
      \vskip1ex
      A named vector can be \emph{subset} using element names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
vec_tor  # named vector
# extract second element
vec_tor[2]
# extract all elements, except the second element
vec_tor[-2]
# extract zero elements - returns zero-length vector
vec_tor[0]
# extract second and third elements
vec_tor[c(FALSE, TRUE, TRUE)]
# extract elements using their names
vec_tor["eulery"]
# extract elements using their names
vec_tor[c("pie", "gammy")]
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Filtering \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Filtering} means extracting elements from a vector that satisfy a logical condition,
      \vskip1ex
      When logical comparison operators are applied to vectors, they produce boolean vectors,
      \vskip1ex
      Boolean vectors can then be applied to subset the original vectors, to extract their elements,
      \vskip1ex
      The function \texttt{which()} returns the indices of elements that satisfy a logical condition,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
vec_tor <- runif(5)
vec_tor
vec_tor > 0.5  # boolean vector
# boolean vector of elements equal to the second one
vec_tor == vec_tor[2]
# extract all elements equal to the second one
vec_tor[vec_tor == vec_tor[2]]
vec_tor < 1  # boolean vector of elements less than one
# extract all elements greater than one
vec_tor[vec_tor > 1]
vec_tor[vec_tor > 0.5]  # filter elements > 0.5
which(vec_tor > 0.5)  # index of elements > 0.5
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Factors are similar to vectors, but their elements can only take values from a set of \emph{levels},
      \vskip1ex
      Factors are designed for categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a vector into a factor,
      \vskip1ex
      Factors have two attributes: \emph{class} (equal to \texttt{"factor"}) and \texttt{levels} (the allowed values),
      \vskip1ex
      Although factors aren't vectors, the data underlying a factor is an integer vector, called an \emph{encoding vector},
      \vskip1ex
      The function \texttt{as.numeric()} extracts the encoding vector (indices) of a factor,
      \vskip1ex
      The function \texttt{as.vector()} coerces a factor to a character vector,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# create factor vector
fac_tor <- factor(c('b', 'c', 'd', 'a', 'c', 'b'))
fac_tor
fac_tor[3]
attributes(fac_tor)  # get factor attributes
levels(fac_tor)  # get allowed values
as.numeric(fac_tor)  # get encoding vector
is.vector(fac_tor)
as.factor(1:5)  # coerce vector to factor
# coerce factor to character vector
as.vector(as.factor(1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Tables of Categorical Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{table()} calculates the frequency distribution of categorical data,
      \vskip1ex
      A contingency table is a matrix that contains the frequency distribution of variables (factors) contained in a set of data, 
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
fac_tor
levels(fac_tor)  # get allowed values
unique(fac_tor)  # get unique elements
# get contingency (frequency) table
table(fac_tor)
# get contingency table using sapply
sapply(levels(fac_tor), 
       function(le_vel) {
         sum(fac_tor==le_vel)
       })  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Classifying Continuous Numeric Data Into Categories}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Numeric data that represents a \emph{magnitude}, \emph{intensity}, or \emph{score} can be classified into categorical data, given a vector of \emph{breakpoints},
      \vskip1ex
      The \emph{breakpoints} create intervals that correspond to different \emph{categories},
      \vskip1ex
      The \emph{categories} combine elements that have a similar numeric \emph{magnitude},
      \vskip1ex
      \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"},
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()},
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"},
      \vskip1ex
      If all the elements of \texttt{"vec"} are greater than the element of \texttt{"x"}, then \texttt{findInterval()} returns \texttt{zero},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=TRUE>>=
library(microbenchmark)
str(findInterval)
# get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# no exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7), 
             all.inside=TRUE)
# make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7), 
             rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Classifying Numeric Data Into Categories Example}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Temperature can be categorized into "cold", "warm", "hot", etc.
      \vskip1ex
      A named numeric vector of \emph{breakpoints} can be used to convert a temperature into one of the \emph{categories},
      \vskip1ex
      \emph{Breakpoints} correspond to \emph{categories} of the data,
      \vskip1ex
      The first \emph{breakpoint} should correspond to the lowest \emph{category}, and should have a value less than any of the data,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# named numeric vector of breakpoints
brea_ks <- c("freezing"=0, "very_cold"=30, 
             "cold"=50, "pleasant"=60, 
             "warm"=80, "hot"=90)
brea_ks
tempe_ratures <- runif(10, min=10, max=100)
feels_like <- names(
  brea_ks[findInterval(x=tempe_ratures, 
                       vec=brea_ks)])
names(tempe_ratures) <- feels_like
tempe_ratures
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Converting Numeric Data Into Factors Using \texttt{cut()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{cut()} converts a numeric vector into a vector of factors, representing the intervals to which the numeric values belong, 
      \vskip1ex
      \texttt{cut()} divides the range of values into intervals, based on a vector of breaks, 
      \vskip1ex
      \texttt{cut()} then assigns factors to the numeric values, representing the intervals to which the numeric values belong, 
      \vskip1ex
      The argument \texttt{"breaks"} is a numeric vector of break points that divide the range of values into intervals, 
      \vskip1ex
      The argument \texttt{"labels"} is a vector of labels for the intervals, 
      \vskip1ex
      The argument \texttt{"right"} is a boolean indicating if the intervals should be closed on the right (and open on the left), or vice versa, 
      \vskip1ex
      \texttt{cut()} can produce the same classification as \texttt{findInterval()}, but \texttt{findInterval()} is faster than \texttt{cut()}, because it's a compiled function, 
      \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=FALSE>>=
library(microbenchmark)
foo <- sample(0:6) + 0.1
foo
cut(x=foo, breaks=c(2, 4, 6, 8))
rbind(foo, cut(x=foo, breaks=c(2, 4, 6, 8)))
# cut() replicates findInterval()
cut(x=1:8, breaks=c(3, 5, 7), labels=1:2, 
    right=FALSE)
findInterval(x=1:8, vec=c(3, 5, 7))
# findInterval() is a compiled function, so it's faster than cut()
vec_tor <- rnorm(1000)
summary(microbenchmark(
  find_interval=
    findInterval(x=vec_tor, vec=c(3, 5, 7)), 
  cuut=
    cut(x=vec_tor, breaks=c(3, 5, 7)), 
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{matrix()} creates a matrix from a vector, and the matrix dimensions,
      \vskip1ex
      By default \texttt{matrix()} creates matrices column-wise, unless the argument \texttt{byrow=TRUE} is used,
      \vskip1ex
      The elements of matrices can be subset (dereferenced) using the \texttt{"[]"} operator,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
mat_rix <- matrix(5:10, nrow=2, ncol=3)  # create a matrix
mat_rix  # by default matrices are constructed column-wise
# create a matrix row-wise
matrix(5:10, nrow=2, byrow=TRUE)
mat_rix[2, 3]  # extract third element from second row
mat_rix[2, ]  # extract second row
mat_rix[, 3]  # extract third column
mat_rix[, c(1,3)]  # extract first and third column
mat_rix[, -2]  # remove second column
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Arrays are vectors with a dimension attribute,
      \vskip1ex
      Matrices are two-dimensional arrays,
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
      \vskip1ex
      The \texttt{dimnames} attribute is a list, with vector elements containing row and column names,
      \vskip1ex
      A named matrix can be subset using row and column names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
attributes(mat_rix)  # get matrix attributes
dim(mat_rix)  # get dimension attribute
class(mat_rix)  # get class attribute
rownames(mat_rix) <- c("row1", "row2")  # rownames attribute
colnames(mat_rix) <- c("col1", "col2", "col3")  # colnames attribute
mat_rix
mat_rix["row2", "col3"]  # third element from second row
names(mat_rix)  # get the names attribute
dimnames(mat_rix)  # get dimnames attribute
attributes(mat_rix)  # get matrix attributes
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Subsetting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Matrices can be subset in a similar way as Vectors, either by indices (integers), by characters (names), or boolean vectors,
      \vskip1ex
      Subsetting a matrix to a single row or column produces a vector, unless the parameter \texttt{"drop=FALSE"} is used,
      \vskip1ex
      Subsetting with the parameter \texttt{"drop=FALSE"} prevents the implicit coercion and preserves the matrix \emph{class},
      \vskip1ex
      This is an example of implicit coercion in \texttt{R}, which can cause difficult to trace bugs,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
mat_rix  # matrix with column names
mat_rix[1, ]  # subset rows by index
mat_rix[, "col1"]  # subset columns by name
mat_rix[, c(TRUE, FALSE, TRUE)]  # subset columns boolean vector
mat_rix[1, ]  # subsetting can produce a vector!
class(mat_rix); class(mat_rix[1, ])
is.matrix(mat_rix[1, ]); is.vector(mat_rix[1, ])
mat_rix[1, , drop=FALSE]  # drop=FALSE preserves matrix
class(mat_rix[1, , drop=FALSE])
is.matrix(mat_rix[1, , drop=FALSE]); is.vector(mat_rix[1, , drop=FALSE])
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Recursive Data Objects}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Lists are a type of vector that contain elements of different \emph{types},
      \vskip1ex
      Lists are recursive object types, meaning each list element can contain other vectors or lists,
      \vskip1ex
      The function \texttt{list()} creates a list from a list of vectors,
      \vskip1ex
      \texttt{list()} creates a named list from a list of symbol-value pairs,
      \vskip1ex
      The function \texttt{is.list()} returns \texttt{TRUE} if its argument is a list, and \texttt{FALSE} otherwise,
      \vskip1ex
      The function \texttt{unlist()} flattens a list into a vector that contains the atomic elements of the list (which typically causes coercion),
    \column{0.6\textwidth}
      \vspace{-2em}
      <<>>=
# create a list with two elements
list_var <- list(c('a', 'b'), 1:4)
list_var
c(typeof(list_var), mode(list_var), class(list_var))
# lists are also vectors
c(is.vector(list_var), is.list(list_var))
length(list_var)
# create named list
list_var <- list(first=c('a', 'b'), second=1:4)
list_var
names(list_var)
unlist(list_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Lists can be subset (indexed) using:
      \begin{itemize}
        \item the \texttt{"["} operator (returns sublist),
        \item the \texttt{"[["} operator (returns an element),
        \item the \texttt{"\$"} operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
list_var[2]  # extract second element as sublist
list_var[[2]]  # extract second element
list_var[[2]][3]  # extract third element of second element
list_var[[c(2, 3)]]  # third element of second element
list_var$second  # extract second element
list_var$s  # extract second element - partial name matching
list_var$second[3]  # third element of second element
list_var <- list()  # empty list
list_var$a <- 1
list_var[2] <- 2
list_var
names(list_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Vectors Into \subsecname \hskip0.5em Using \texttt{as.list()}}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{as.list()} coerces vectors and other objects into lists,
      \vskip1ex
      \texttt{as.list()} returns a list with the same elements as the vector,
      \vskip1ex
      \texttt{list()} called on a vector returns a single element equal to the vector,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
as.list(c(1,2,3))
list(c(1,2,3))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames are \texttt{2-D} objects (like matrices), but their columns can be of different \emph{types},
      \vskip1ex
      Data frames can be thought of as lists of vectors of the same length,
      \vskip1ex
      The function \texttt{data.frame()} creates a \texttt{data frame} from vectors assigned to column names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0)
                    )  # end data.frame
data_frame
dim(data_frame)  # get dimension attribute
colnames(data_frame)  # get the colnames attribute
rownames(data_frame)  # get the rownames attribute
class(data_frame)  # get object class
typeof(data_frame)  # data frames are lists
is.data.frame(data_frame)

class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
      \vskip1ex
      Depending on how a data frame is subset, the result can be either a data frame or a vector,
      \vskip1ex
      Extracting a single column from a data frame produces a vector,
      \vskip1ex
      The data frame class attribute can be preserved by using the parameter \texttt{"drop=FALSE"},
      \vskip1ex
      Extracting a single row from a data frame produces a data frame,
      \vskip1ex
      The function \texttt{unlist()} applied to a single row extracted from a data frame coerces it to a vector, 
    \column{0.6\textwidth}
      \vspace{-2em}
      <<>>=
data_frame[, 3]  # extract third column
data_frame[[3]]  # extract third column
data_frame[[3]][2]  # second element from third column
data_frame$price[2]  # second element from 'price' column
is.data.frame(data_frame[[3]]); is.vector(data_frame[[3]])
data_frame[, 3, drop=FALSE]  # extract third column
data_frame[2, ]  # extract second row
data_frame[2, ][3]  # third element from second column
data_frame[2, 3]  # third element from second column
unlist(data_frame[2, ])  # coerce to vector
is.data.frame(data_frame[2, ]); is.vector(data_frame[2, ])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em and Factors}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      By default \texttt{data.frame()} coerces \texttt{character} vectors to \texttt{factors}, unless the \texttt{stringsAsFactors=FALSE} option is passed into \texttt{data.frame()},
      \vskip1ex
      The function \texttt{options()} sets global \emph{options}, that determine how \texttt{R} computes and displays its results,
      \vskip1ex
      If the global \texttt{option} \texttt{stringsAsFactors=FALSE} is set, then \texttt{character} vectors will not be coerced to \texttt{factors} in all subsequent \texttt{data frame} operations,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0),
                      row.names=c('flower1', 'flower2', 'flower3'),
                      stringsAsFactors=FALSE
                    )  # end data.frame
data_frame
class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
# set option to not coerce character vectors to factors
options(stringsAsFactors=FALSE)
options("stringsAsFactors")
default.stringsAsFactors()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{str()} displays the structure of an \texttt{R} object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an \texttt{R} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str(data_frame)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{sort()} returns a sorted vector,
      \vskip1ex
      The function \texttt{order()} returns a permutation index,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:7))>>=
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
# create a data frame
data_frame <- data.frame(type, color, price)
# assign rownames
rownames(data_frame) <- c('flower1', 'flower2', 'flower3')
sort_data <- sample(1:6)  # permute data
sort_data
sort(sort_data)  # sorted data
order(sort_data)  # permution index
sort_data[order(sort_data)]  # permution index
order(data_frame$price)  # permute on price
data_frame[order(data_frame$price), ]  # sort on price
data_frame[order(data_frame$color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing \subsecname \hskip0.5em Into Matrices Using \texttt{as.matrix()}}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{as.matrix()} coerces vectors and data frames into matrices,
      \vskip1ex
      Coercing a data frame into a matrix causes coercion of \texttt{numeric} values into \texttt{character},
      \vskip1ex
      \texttt{as.matrix()} coerces vectors into single column matrices, as opposed to \texttt{matrix()}, which produces a matrix,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
as.matrix(data_frame)
vec_tor <- sample(9)
matrix(vec_tor, ncol=3)
as.matrix(vec_tor, ncol=3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Matrices Into \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The generic function \texttt{as.data.frame()} coerces matrices and other objects into data frames,
      \vskip1ex
      The method \texttt{as.data.frame.matrix()} coerces only matrices into data frames,
      \vskip1ex
      \texttt{as.data.frame.matrix()} is about \texttt{50\%} faster than \texttt{as.data.frame()}, because it skips extra \texttt{R} code in \texttt{as.data.frame()} needed for argument validation, error checking, and method dispatch,
      \vskip1ex
      As a general rule, calling generic functions is slower than directly calling individual methods, because generic functions must execute extra \texttt{R} code for method dispatch,
      \vskip1ex
      The function \texttt{data.frame()} can also be used to coerce matrices into data frames, but is much slower than even \texttt{as.data.frame()},
      \vskip1ex
      \texttt{as.data.frame()} is about three times faster than \texttt{data.frame()}, because it doesn't require extra \texttt{R} code in \texttt{data.frame()} needed for handling different types of vectors, and for method dispatch,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
library(microbenchmark)
# call method instead of generic function
as.data.frame.matrix(mat_rix)
# a few methods for generic function as.data.frame()
sample(methods(as.data.frame), size=4)
# function method is faster than generic function
summary(microbenchmark(
  as_data_frame_matrix=
    as.data.frame.matrix(mat_rix),
  as_data_frame=as.data.frame(mat_rix),
  data_frame=data.frame(mat_rix), 
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Matrices Into Lists}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be coerced into lists in at least two different ways, 
      \vskip1ex
      Matrices can be first coerced into a data frame, and then into a list using function \texttt{as.list()}, 
      \vskip1ex
      Matrices can be directly coerced into a list using function \texttt{lapply()}, 
      \vskip1ex
      Using \texttt{lapply()} is the faster of the two methods, because \texttt{lapply()} is a \emph{compiled} function, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=TRUE>>=
library(microbenchmark)
# lapply is faster than coercion function
summary(microbenchmark(
  as_list=
    as.list(as.data.frame.matrix(mat_rix)),
  l_apply=
    lapply(seq_along(mat_rix[1, ]), 
           function(in_dex) mat_rix[, in_dex]),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{iris} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{iris} data frame is included in the \texttt{datasets} base package,
      \vskip1ex
      \texttt{iris} contains sepal and petal dimensions of 50 flowers from 3 species of iris,
      \vskip1ex
      The function \texttt{unique()} extracts unique elements of an object,
      \vskip1ex
      \texttt{sapply()} applies a function to a list or a vector of objects and returns a vector,
      \vskip1ex
      \texttt{sapply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# ?iris  # get information on iris
dim(iris)
head(iris, 2)
colnames(iris)
unique(iris$Species)  # list of unique elements of iris
class(unique(iris$Species))
# find which columns of iris are numeric
sapply(iris, is.numeric)
# calculate means of iris columns
sapply(iris, mean)  # returns NA for Species
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{mtcars} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{mtcars} data frame is included in the \texttt{datasets} base package, and contains design and performance data for 32 automobiles,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# ?mtcars  # mtcars data from 1974 Motor Trend magazine
# mpg   Miles/(US) gallon
# qsec   1/4 mile time
# hp	 Gross horsepower
# wt	 Weight (lb/1000)
# cyl   Number of cylinders
dim(mtcars)
head(mtcars, 2)
colnames(mtcars)
head(rownames(mtcars), 3)
unique(mtcars$cyl)  # extract list of car cylinders
sapply(mtcars, mean)  # calculate means of mtcars columns
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{Cars93} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{Cars93} data frame is included in the \texttt{MASS} package, and contains design and performance data for 93 automobiles,
      \vskip1ex
      The function \texttt{hist()} calculates and plots a histogram,
      \vskip1ex
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      \texttt{"FD"} stands for the Freedman-Diaconis rule for calculating histogram breaks,
        <<Cars93_hist,fig.show='hide'>>=
library(MASS)
# ?Cars93  # get information on Cars93
dim(Cars93)
head(colnames(Cars93))
# head(Cars93, 2)
unique(Cars93$Type)  # extract list of car types
# sapply(Cars93, mean)  # calculate means of Cars93 columns
# plot histogram of Highway MPG using the Freedman-Diaconis rule
hist(Cars93$MPG.highway, col="lightblue1", 
     main="Distance per Gallon 1993", xlab="Highway MPG", breaks="FD")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/Cars93_hist-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Management and Analysis}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      When a function produces \texttt{NA} or \texttt{NaN} values, then it also produces a \emph{warning} condition, but not an \emph{error},
      \vskip1ex
      \texttt{NA} or \texttt{NaN} values are not \emph{errors},
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for \texttt{NA} and \texttt{NaN} values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove \texttt{NAs} from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, NaN, 0/0, 1/0))  # test for NA
is.nan(c(NA, NaN, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
da_ta <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
da_ta
mean(da_ta)  # returns NA, when NAs are input
mean(da_ta, na.rm=TRUE)  # remove NAs from input data
da_ta[!is.na(da_ta)]  # delete the NA values
sum(!is.na(da_ta))  # count non-NA values
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
# display rows containing NAs
head(airquality[!complete.cases(airquality), ])
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from library \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
# remove rows containing NAs
good_air <- airquality[complete.cases(airquality), ]
dim(good_air)
head(good_air)  # NAs removed
library(zoo)  # load package zoo
good_air <- na.locf(airquality)  # replace NAs
dim(good_air)
head(good_air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{NULL} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{NULL} is a reserved word that represents a value that doesn't exist,
      \vskip1ex
      \texttt{NULL} is a legitimate value, not bad data,
      \vskip1ex
      The function \texttt{is.null()} tests for \texttt{NULL} values,
      \vskip1ex
      \texttt{NULL} is often returned by functions whose value is undefined,
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration,
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# NULL values have no mode or type
c(mode(NULL), mode(NA))
c(typeof(NULL), typeof(NA))
c(length(NULL), length(NA))
# check for NULL values
is.null(NULL)
# NULL values are ignored when combined into a vector
c(1, 2, NULL, 4, 5)  
# vectors can be initialized to NULL
da_ta <- NULL
for (in_dex in 1:5)
  da_ta <- c(da_ta, in_dex)
da_ta
# NA value isn't ignored
da_ta <- NA
for (in_dex in 1:5)
  da_ta <- c(da_ta, in_dex)
da_ta
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
