% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}



% Title page setup
\title[\texttt{R} Data Structures]{\texttt{R} Data Structures}
\subtitle{FRE6871 R in Finance, Fall 2014}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@nyu.edu}
\date{\today}



%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Data Structures}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Homogeneous data structures contain objects of the same class,
      \vskip1ex
      Heterogeneous structures can contain objects of different classes,
    \column{0.5\textwidth}
%      \vspace{-1em}
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{\texttt{R} Data Structures}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{Homogeneous} & \text{Heterogeneous} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Homogeneous Data Structures}


%%%%%%%%%%%%%%%
\subsection{Basic \texttt{R} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Let's start by typing some \emph{text},
      \vskip1ex
      The quotation marks \texttt{""} (or \texttt{''}) around the characters tell \texttt{R} that it's a string, not a variable name,
      \vskip1ex
      The '\texttt{[1]}' symbol means the return value is a vector,
      \vskip1ex
      The first element of the vector contains the string of text,
      \vskip1ex
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      There are no scalars in \texttt{R}, so a single value is stored as a vector of length \texttt{1},
      \vskip1ex
      The colon binary operator \texttt{':'} produces a vector,
      \vskip1ex
      The function \texttt{c()} combines objects into a vector,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
"Hello World!"  # type some text

4:8  # create a vector
2*4:8  # create a vector
2*(4:8)  # create a vector
4:8/2  # create a vector
round(4:8/2)  # create a vector
trunc(4:8/2)  # create a vector
c(1, 2, 3, 4, 5)  # create vector using c() combine function
c('a', 'b', 'c')  # create vector using c() combine function
c(1, 'b', 'c')  # create vector using c() combine function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one),
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string,
      \vskip1ex
      Special Characters in Strings:\\
      "\texttt{\textbackslash{}t}" for TAB,\\
      "\texttt{\textbackslash{}n}" for new-line,\\
      "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{cat()} concatenates strings and writes to output, without returning any values,
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str_var <- "Some string"
str_var
str_var[1]
str_var[2]

length(str_var)  # length of vector
nchar(str_var)  # length of string

cat("Enter\ttab")
cat("Enter\nnewline")
cat("Enter\\backslash")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, and coerces them to characters if needed,
      \vskip1ex
      The function \texttt{strsplit()} splits the elements of a character vector,
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string,
      \vskip1ex
      The recycling rule extends the length to match the longest object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str_var1 <- "Hello"  # define a character string
str_var2 <- "World!"  # define a character string

paste(str_var1, str_var2, sep=' ')  # concatenate

paste('a', 1:4, sep='-')  # convert, recycle and concatenate

cat(str_var1, str_var2)  # concatenate and write to output

strsplit("Hello World", split='r')  # split string

substring("Hello World", 3, 6)  # extract characters from 3 to 6

paste("Today is", Sys.time())  # coerce and concatenate strings

paste("Today is", format(Sys.time(), "%B-%d-%Y"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has Regex functions for pattern matching and replacement, 
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string,
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string,
      \vskip1ex
      The function \texttt{glob2rx()} converts globbing wildcard patterns into regular expressions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
gsub("is", "XX", "is this gratis?")  # replace "is" with "XX"

grep("b+", c("abc", "xyz", "cba d", "bbb"))  # get indexes

grep("b+", c("abc", "xyz", "cba d", "bbb"), value=TRUE)  # get values

glob2rx("abc.*")  # convert globs into regex
glob2rx("*.doc")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{c()} combines values into a vector or a list,
      \vskip1ex
      Vectors can be indexed (subset) using vectors of:
      \begin{itemize}
        \item positive integers,
        \item negative integers,
        \item characters,
        \item logical vectors,
      \end{itemize}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var <- c(pi, exp(1), -digamma(1))  # define a vector
vec_var
vec_var[2]  # get second element
vec_var[-2]  # get all elements, except the second element
vec_var[c(F, T, T)]  # get second and third elements
vec_var == vec_var[2]  # logical vector of elements equal to the second one
vec_var < 1  # logical vector of elements less than one
vec_var[vec_var > 1]  # get all elements greater than one
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be multiplied and squared element by element,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
vec_var <- c(pi, exp(1), -digamma(1))
vec_var
2*vec_var  # multiply all elements by 2
vec_var^2  # square all elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Creating\hskip0.5em\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The colon operator ("\texttt{:}") provides a simple way of creating a numeric vector,
      \vskip1ex
      The function \texttt{vector()} returns a vector of the specified \texttt{mode},
      \vskip1ex
      The function \texttt{seq()} returns a vector of numbers,
      \vskip1ex
      The function \texttt{rep()} replicates an object multiple times,
      \vskip1ex
      The functions \texttt{numeric()} and \texttt{character()} return empty vectors of the specified \texttt{type},
      \vskip1ex
      Zero length vectors are not \texttt{NULL},
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
0:10  # vector of integers from 0 to 10
(0:10)/10  # vector of decimals from 0 to 1.0
vector()  # create empty vector
vector(mode="numeric", length=10)  # create numeric vector of zeros
seq(10)  # sequence from 1 to 10
seq(along=(-5:5))  # instead of 1:length(obj)
seq(from=0, to=1, len=11)  # vector of decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # vector of decimals from 0 to 1.0
seq(-2,2, len=10)  # 10 evenly distributed numbers from -2 to 2
rep(100, times=5)  # replicate a number
character(5)  # create empty character vector
numeric(5)  # create empty numeric vector
numeric(0)  # create zero length vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Manipulating\hskip0.5em\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vector elements can be assigned \texttt{names},
      \vskip1ex
      Vectors can be combined together and appended,
      \vskip1ex
      The object \texttt{letters} is a constant and a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
vec_var
names(vec_var)  # get names of elements
vec_var['euler']  # get element named 'euler'
names(vec_var) <- c("pie","eulery","gammy")  # rename elements
vec_var

c(11, 5:10)  # combine two vectors
c(vec_var, 2.0)  # append number to vector

letters[5:10]  # vector of letters
c('a', letters[5:10])  # combine two vectors of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Filtering\hskip0.5em\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Filtering} means extracting elements from a vector that satisfy a logical condition,
      \vskip1ex
      When logical comparison operators are applied to vectors, they produce logical vectors,
      \vskip1ex
      Logical vectors can then be applied to subset the original vectors, to extract their elements,
      \vskip1ex
      The function \texttt{which()} returns the indices of elements that satisfy a logical condition,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var <- runif(5)
vec_var

vec_var> 0.5  # logical vector

vec_var[vec_var>0.5]  # filter elements > 0.5

which(vec_var>0.5)  # index of elements > 0.5
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Factors are similar to vectors, but their elements can only take values from a set of \emph{levels},
      \vskip1ex
      Factors are designed for categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a vector into a factor,
      \vskip1ex
      Factors have two attributes: \texttt{class} (equal to "\texttt{factor}") and \texttt{levels} (the allowed values),
      \vskip1ex
      The function \texttt{as.vector()} coerces a factor to a character vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
# create factor vector
fact_var <- factor(c('b', 'c', 'd', 'a', 'c', 'b'))
fact_var
fact_var[3]

attributes(fact_var)  # get factor attributes
levels(fact_var)  # get allowed values

table(fact_var)  # get contingency (frequency) table

is.vector(fact_var)
as.vector(fact_var)  # coerce factor to character vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{matrix()} creates a matrix from a vector, and the matrix dimensions,
      \vskip1ex
      The elements of matrices can be subset (dereferenced) using the \texttt{[]} operator,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
mat_var <- matrix(5:10, nrow=2, ncol=3)  # create a matrix
mat_var  # by default matrices are constructed column-wise

mat_var[2, 3]  # get third element from second row
mat_var[2, ]  # get second row
mat_var[ ,3]  # get third column
mat_var[, c(1,3)]  # get first and third column
mat_var[ ,-2]  # remove second column
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Arrays are vectors with a dimension attribute,
      \vskip1ex
      Matrices are two-dimensional arrays,
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
      \vskip1ex
      The \texttt{dimnames} attribute is a list, with vector elements containing row and column names,
      \vskip1ex
      A named matrix can be subset using row and column names,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
attributes(mat_var)  # get matrix attributes
dim(mat_var)  # get dimension attribute
class(mat_var)  # get class attribute

rownames(mat_var) <- c("row1", "row2")  # set the rownames attribute
colnames(mat_var) <- c("col1", "col2", "col3")  # set the colnames attribute
mat_var
mat_var["row2", "col3"]  # get third element from second row
names(mat_var)  # get the names attribute
dimnames(mat_var)  # get dimnames attribute
attributes(mat_var)  # get matrix attributes
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Subsetting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Subsetting a matrix to a single row or column produces a vector,
      \vskip1ex
      This is an example of implicit coercion in \texttt{R}, which can cause difficult to trace bugs,
      \vskip1ex
      Subsetting with the parameter \texttt{"drop=FALSE"} prevents the implicit coercion and preserves the matrix \texttt{class},
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
mat_var[1, ]  # subsetting produces a vector!
class(mat_var)
class(mat_var[1, ])
is.matrix(mat_var[1, ])
is.vector(mat_var[1, ])

mat_var[1, , drop=FALSE]  # drop=FALSE preserves matrix
class(mat_var[1, , drop=FALSE])
is.matrix(mat_var[1, , drop=FALSE])
is.vector(mat_var[1, , drop=FALSE])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Vectors Into Matrices}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be coerced into matrices by adding a dimension attribute,
      \vskip1ex
      The \texttt{dimnames} attribute can be assigned a named list to convert it into a named matrix,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
mat_var <- 1:6  # create a vector
class(mat_var)  # get its class

dim(mat_var) <- c(2, 3)  # add dimension attribute to coerce into matrix
class(mat_var)  # get its class
is.matrix(mat_var)  # is the object a matrix?

dimnames(mat_var) <- list('rows'=c('row1', 'row2'),  # set dimnames attribute
                        'columns'=c('col1', 'col2', 'col3'))

mat_var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()},
      \vskip1ex
      The \alert{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var1 <- c(1, 2, 3)
vec_var2 <- c(4, 5, 6)
cbind(vec_var1, vec_var2)  # bind into columns
rbind(vec_var1, vec_var2)  # bind into rows
vec_var2 <- c(4, 5, 6, 7)  # extend second vector to four elements
cbind(vec_var1, vec_var2)  # recycling rule applied
1:6 + c(10, 20)  # another example of recycling rule
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Heterogeneous Data Structures}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Lists are a type of vector that contain elements of different classes,
      \vskip1ex
      Lists are recursive object types,
      \vskip1ex
      Lists can be indexed (subset) using:
      \begin{itemize}
        \item the '\texttt{[[}' operator,
        \item the '\texttt{\$}' operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
list_var <- list(c('a', 'b'), 1:4)  # create a list
list_var
typeof(list_var)
list_var[[2]]  # get second element
list_var[[2]][3]  # get third element of second element
list_var[[c(2, 3)]]  # get third element of second element
list_var <- list(first=c('a', 'b'),  # create named list
              second=1:4)
names(list_var)
list_var$second  # get second element
list_var$s  # get second element - partial name matching
list_var$second[3]  # get third element of second element
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames are \texttt{2-D} objects (like matrices), but their columns can be of different classes,
      \vskip1ex
      Data frames can be thought of as lists of vectors of the same length,
      \vskip1ex
      The function \texttt{data.frame()} creates a \texttt{data frame} from vectors assigned to column names,
      \vskip1ex
      Data frames can be subset in a similar way to lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0)
                    )  # end data.frame
data_frame
dim(data_frame)  # get dimension attribute
colnames(data_frame)  # get the colnames attribute
rownames(data_frame)  # get the rownames attribute
class(data_frame)  # get object class
class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
data_frame[2, 3]  # get second row and third column
data_frame[[3]]  # get third column
data_frame$color[3]  # get third row from column 'color'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname\hskip0.5emand Factors}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      By default \texttt{data.frame()} coerces \texttt{character} vectors to \texttt{factors}, unless the \texttt{stringsAsFactors=FALSE} option is passed into \texttt{data.frame()},
      \vskip1ex
      The function \texttt{options()} sets global \texttt{options}, that determine how \texttt{R} computes and displays its results,
      \vskip1ex
      If the global \texttt{option} \texttt{stringsAsFactors=FALSE} is set, then \texttt{character} vectors will not be coerced to \texttt{factors} in all subsequent \texttt{data frame} operations,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
# don't coerce character vectors to factors
options(stringsAsFactors=FALSE)
options("stringsAsFactors")
default.stringsAsFactors()

data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0),
                      row.names=c('flower1', 'flower2', 'flower3'),
                      stringsAsFactors=FALSE
                    )  # end data.frame
data_frame
class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{str()} compactly displays the structure of an \texttt{R} object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an \texttt{R} object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
str(data_frame)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{order()} returns a permutation vector,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30>>=
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
data_frame <- data.frame(type,  # create a data frame
                         color, price)
rownames(data_frame) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
data_frame
order(data_frame$price)  # permute on price
data_frame[order(data_frame$price), ]  # sort on price
data_frame[order(data_frame$color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Types and Classes}


%%%%%%%%%%%%%%%
\subsection{Type, Mode, and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{type} of an atomic object represents how it's stored in memory (\texttt{logical}, \texttt{integer}, \texttt{double}, \texttt{character}, etc.)
      \vskip1ex
      The \texttt{mode} of an atomic object is the kind of data it represents (\texttt{logical}, \texttt{numeric}, \texttt{character}, etc.)
      \vskip1ex
      The \texttt{mode} of an object often coincides with its \texttt{type} (except for \texttt{integer} and \texttt{double} types),
      \vskip1ex
      Recursive objects (such as \texttt{lists}) have both \texttt{type} and \texttt{mode} equal to the recursive type (\texttt{list}, etc.),
      \vskip1ex
      The \texttt{class} of an object is an attribute used for function dispatching in the \texttt{S3 OO} system (\texttt{classes} are \texttt{numeric}, \texttt{matrix}, \texttt{character}, \texttt{factor}, \texttt{list}, etc.)
      \vskip1ex
      Objects are assigned an implicit \texttt{class} when they are created, derived from either their \texttt{type}, \texttt{mode}, or their data structure (\texttt{matrix}, \texttt{data.frame}, etc.)
      \vskip1ex
      The function \texttt{class()} returns the explicit or implicit \texttt{class} of an object,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- "hello"
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- runif(5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(1:10, 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(runif(10), 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- list(aa=c('a', 'b'), bb=1:5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- data.frame(aa=c('a', 'b'), bb=1:2)
c(typeof(my_var), mode(my_var), class(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Object Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} objects can have different attributes, such as: \texttt{names}, \texttt{dimnames}, \texttt{dimensions}, \texttt{class}, etc., 
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
      \vskip1ex
      Objects without an explicit \texttt{class} don't have a \texttt{class} attribute, and the function \texttt{class()} returns the implicit \texttt{class},
      \vskip1ex
      The \texttt{class} of an object can be assigned explicitly using the \texttt{"class() <-"} assignment,
      \vskip1ex
      An object can have a main \texttt{class}, and also an inherited \texttt{class} (the \texttt{class} attribute can be a vector of strings),
      \vskip1ex
      The function unclass() removes the explicit class attribute from an object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
attributes(5:10)  # a simple vector has no attributes
my_var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
attributes(my_var)  # a named vector has 'names' attribute
my_var <- matrix(runif(10), 2, 5)
attributes(my_var)  # no explicit 'class' attribute
c(typeof(my_var), mode(my_var), class(my_var))
class(my_var) <- "my_class"
attributes(my_var)  # has explicit 'class' attribute
c(typeof(my_var), mode(my_var), class(my_var))
is.matrix(my_var)  # is the object a matrix?
is.vector(my_var)  # is the object a vector?
attributes(unclass(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Object Coercion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Coercion} means changing the \texttt{type}, \texttt{mode}, or \texttt{class} of an object,
      \vskip1ex
      Changing the \texttt{mode} of an object can change its \texttt{class} as well, but not always,
      \vskip1ex
      Objects can be explicitly coerced using the \texttt{as.*} coercion functions,
      \vskip1ex
      Most coercion functions strip the attributes from the object,
      \vskip1ex
      Implicit coercion occurs when objects with different \texttt{modes} are combined into a vector, forcing the elements to have the same \texttt{mode},
      \vskip1ex
      The rule is that coercion is into larger types (\texttt{numeric} objects are coerced into \texttt{character} strings),
      \vskip1ex
      Coercion can introduce bad data, such as \texttt{NA} values,
      \vskip1ex
      Implicit coercion can cause bugs that are difficult to trace,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))

mode(my_var) <- "character"  # coerce to "character"
my_var
c(typeof(my_var), mode(my_var), class(my_var))
my_var <- as.character(1:5)  # explicitly coerce to "character"
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(1:10, 2, 5)
my_var <- as.character(my_var)  # explicitly coerce to "character"
c(typeof(my_var), mode(my_var), class(my_var))
is.matrix(my_var)  # is the object a matrix?

as.logical(0:3)  # explicit coercion to "logical"

c(1:3, 'a')  # implicit coercion to "character"
as.numeric(c(1:3, 'a'))  # explicit coercion to "numeric"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Management and Analysis}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for NA and NaN values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove NAs from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, 0/0, 1/0))  # test for NA
is.nan(c(NA, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
v.na <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
mean(v.na)  # returns NA, when NAs are input
mean(v.na, na.rm=TRUE)  # remove NAs from input data
v.na[!is.na(v.na)]  # delete the NA values
sum(!is.na(v.na))  # count non-NA values
      @
  \end{columns}
\end{block}

\begin{block}{}
  \texttt{NULL} isn't bad data, but is a reserved word and represents a null object,\\
  \texttt{NULL} is returned by functions whose value is undefined,\\
  Very often variables are initialized to \texttt{NULL} before iteration,\\
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
head(airquality[!complete.cases(airquality), ])  # display some NAs
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from library \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
good.air <- airquality[complete.cases(airquality), ]  # remove NAs
dim(good.air)
head(good.air)  # NAs removed
library(zoo)  # load package zoo
good.air <- na.locf(airquality)  # replace NAs
dim(good.air)
head(good.air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
