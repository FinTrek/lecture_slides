% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6811_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}



% Title page setup
\title[$R$ Data Structures]{$R$ Data Structures}
\subtitle{FRE6871 R in Finance, Fall 2014}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@nyu.edu}
\date{\today}



%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Data Structures}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em in $R$}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Homogeneous data structures contain objects of the same class,
      \vskip1ex
      Heterogeneous structures can contain objects of different classes,
    \column{0.5\textwidth}
%      \vspace{-1em}
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{$R$ Data Structures}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{Homogeneous} & \text{Heterogeneous} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Homogeneous Data Structures}


%%%%%%%%%%%%%%%
\subsection{Basic $R$ Objects}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Let's start by typing some \emph{text},\\
      \vskip1ex
      The quotation marks \texttt{""} (or \texttt{''}) around the characters tell $R$ that it's a string, not a variable name,\\
      \vskip1ex
      The '\texttt{[1]}' symbol means the return value is a vector,\\
      \vskip1ex
      The first element of the vector contains the string of text,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
"Hello World!"  # type some text
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The colon operator \texttt{':'} returns a vector of length \texttt{1}, with the first element containing a string with the name of the current working directory (cwd),
      \vskip1ex
      The function \texttt{c()} returns a vector of length \texttt{1}, with the first element containing a string with the name of the current working directory (cwd),
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
4:8  # create a vector
2*4:8  # create a vector
2*(4:8)  # create a vector
4:8/2  # create a vector
round(4:8/2)  # create a vector
trunc(4:8/2)  # create a vector
c(1, 2, 3, 4, 5)  # create vector using c() combine function

c('a', 'b', 'c')  # create vector using c() combine function

c(1, 'b', 'c')  # create vector using c() combine function

paste('a', 'b', 'c')  # create vector using c() combine function

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one),
      \vskip1ex
      Special Characters in Strings,
      "\texttt{\textbackslash{}t}" for TAB, "\texttt{\textbackslash{}n}" for new-line, and "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
blah <- "blah"
blah
blah[1]
blah[2]
"Enter\ttab"
"Enter\nline"
nchar(blah)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, and coerces them to characters if needed,
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string,
      \vskip1ex
      The function \texttt{cat()} concatenates strings and writes to output, without returning any values,
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions,
      \vskip1ex
      The recycling rule extends the length to match the longest object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
s.var1 <- "Hello"  # define a character string
s.var2 <- "World!"  # define a character string
paste(s.var1, s.var2, sep=' ')  # concatenate
paste('a', 1:4, sep='-')  # convert, recycle and concatenate
cat(s.var1, s.var2)  # concatenate and write to output
strsplit("Hello World", split='r')  # split string
substring("Hello World", 3, 6)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in $R$}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Manipulating string are character objects of length one,\\
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string,\\
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string,\\
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
s.var1 <- "Hello"  # define a character string
s.var2 <- "World!"  # define a character string
strsplit("Hello World", split='r')  # split string
grep("a+", c("abc", "def", "cba a", "aa"), value=TRUE)
gsub("is", "XX", "is this gratis?")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{c()} combines values into a vector or a list,
      \vskip1ex
      Vectors can be indexed (subset) using vectors of:
      \begin{itemize}[]
        \item positive integers,
        \item negative integers,
        \item characters,
        \item logical vectors,
      \end{itemize}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
v.var <- c(pi, exp(1), -digamma(1))  # define a vector
v.var
v.var[2]  # get second element
v.var[-2]  # get all elements, except the second element
v.var[c(F, T, T)]  # get second and third elements
v.var == v.var[2]  # logical vector of elements equal to the second one
v.var < 1  # logical vector of elements less than one
v.var[v.var > 1]  # get all elements greater than one
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be multiplied and squared element by element,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
v.var <- c(pi, exp(1), -digamma(1))
v.var
2*v.var  # multiply all elements by 2
v.var^2  # square all elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vector elements can be assigned $names$,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
v.var
names(v.var)  # get names of elements
v.var['euler']  # get element named 'euler'
names(v.var) <- c("pie","eulery","gammy")  # rename elements
v.var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em of Numbers}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{seq()} returns a vector of numbers,
      \vskip1ex
      Another way of producing a vector of numbers is by using the "\texttt{:}" operator,
      \vskip1ex
      \texttt{letters} is a constant and a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
seq(from=0, to=1, len=11)  # vector of decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # vector of decimals from 0 to 1.0
0:10  # vector of integers from 0 to 10
(0:10)/10  # vector of decimals from 0 to 1.0
letters[5:10]  # vector of letters
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Appending vectors,
      \vskip1ex
      The function \texttt{vector()} returns an empty vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
c(11, 5:10)  # append to vector
c(20:25, 5:10)  # append to vector
v.var <- vector()  # create empty vector
v.var <- vector("numeric",  # create numeric vector of zeros
                length=10)
c(v.var, 2.0)  # append to vector
c('a', letters[5:10])  # vector of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em of Characters}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{seq()} returns a vector of numbers,
      \vskip1ex
      Another way of producing a vector of numbers is by using the "\texttt{:}" operator,
      \vskip1ex
      \texttt{letters} is a constant and a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
str <- c('a', 'b', 'c')
str[2:3]
str[c(1,3)]
str[2] <- 'hello'
str

str <- letters[1:5]

seq(from=0, to=1, len=11)  # vector of decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # vector of decimals from 0 to 1.0
0:10  # vector of integers from 0 to 10
(0:10)/10  # vector of decimals from 0 to 1.0
letters[5:10]  # vector of letters
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Appending vectors,
      \vskip1ex
      The function \texttt{vector()} returns an empty vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
c(11, 5:10)  # append to vector
c(20:25, 5:10)  # append to vector
v.var <- vector()  # create empty vector
v.var <- vector("numeric",  # create numeric vector of zeros
                length=10)
c(v.var, 2.0)  # append to vector
c('a', letters[5:10])  # vector of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Factors are vectors whose elements can have only certain values,
      \vskip1ex
      Factors are designed to describe categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a character vector into a factor,
      \vskip1ex
      Factors have two attributes: \texttt{class} ("\texttt{factor}") and \texttt{levels} (the allowed values),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
f.var <- factor(c('b', 'c',  # create factor vector
                        'd', 'a', 'c', 'b'))
class(f.var)  # get object class
levels(f.var)  # get allowed values
table(f.var)  # get contingency (frequency) table
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Arrays and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Arrays are vectors with a dimension attribute,\\
      \vskip1ex
      Matrices are two-dimensional arrays,\\
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3)  # create a matrix
m.var  # by default matrices are constructed column-wise
class(m.var)  # matrix class
dim(m.var)  # get dimension attribute
rownames(m.var) <- c("row1", "row2")  # set the rownames attribute
colnames(m.var) <- c("col1", "col2", "col3")  # set the colnames attribute
m.var
names(m.var)  # get the names attribute
dimnames(m.var)  # get dimnames attribute
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be converted into matrices by adding a dimension attribute,
      \vskip1ex
      The attribute \texttt{dimnames} can be assigned a named list to convert into a named matrix,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
m.var <- 1:6  # create a vector
dim(m.var) <- c(2, 3)  # convert into matrix by adding dimension attribute
dimnames(m.var) <- list('rows'=c('row1', 'row2'),  # set dimnames attribute
                        'columns'=c('col1', 'col2', 'col3'))
m.var
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Indexing (subsetting) matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:20,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3)  # create a matrix
m.var
m.var[2, ]  # get second row
m.var[c(1,2), ]  # get first and second rows
m.var[ ,3]  # get third column
m.var[ ,-2]  # remove second column
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()},
      \vskip1ex
      The \alert{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
v.var1 <- c(1, 2, 3)
v.var2 <- c(4, 5, 6)
cbind(v.var1, v.var2)  # bind into columns
rbind(v.var1, v.var2)  # bind into rows
v.var2 <- c(4, 5, 6, 7)  # extend second vector to four elements
cbind(v.var1, v.var2)  # recycling rule applied
1:6 + c(10, 20)  # another example of recycling rule
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Heterogeneous Data Structures}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Lists are a type of vector that contain elements of different classes,
      \vskip1ex
      Lists are recursive object types,
      \vskip1ex
      Lists can be indexed (subset) using:
      \begin{itemize}[]
        \item the '\texttt{[[}' operator,
        \item the '\texttt{\$}' operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
l.var <- list(c('a', 'b'), 1:4)  # create a list
l.var
typeof(l.var)
l.var[[2]]  # get second element
l.var[[2]][3]  # get third element of second element
l.var[[c(2, 3)]]  # get third element of second element
l.var <- list(first=c('a', 'b'),  # create named list
              second=1:4)
names(l.var)
l.var$second  # get second element
l.var$s  # get second element - partial name matching
l.var$second[3]  # get third element of second element
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames are 2-D objects (like matrices), but the columns can be of different classes,
      \vskip1ex
      Data frames can also be thought of as lists in which all the elements are vectors of the same length,\\
      Each list element is a column of elements of the same class,
      \vskip1ex
      Data frames share properties of both lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
dim(df.florist)  # get dimension attribute
colnames(df.florist)  # get the colnames attribute
rownames(df.florist)  # get the rownames attribute
class(df.florist)  # get object class
class(df.florist$v.type)  # get column class
class(df.florist$v.price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
df.florist[2, ]  # get second row
df.florist[2, 3]  # get second row and third column
df.florist[[3]]  # get third column
df.florist$v.color[3]  # get third row from column 'v.color'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{str()} compactly displays the structure of an $R$ object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an $R$ object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
str(df.florist)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{order()} returns a permutation vector,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
order(df.florist$v.price)  # permute on price
df.florist[order(df.florist$v.price), ]  # sort on price
df.florist[order(df.florist$v.color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Reading and Writing \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from files,
      \vskip1ex
      The functions \texttt{read.csv()} and \texttt{write.csv()} are wrappers for \texttt{read.table()} and \texttt{write.table()}, and read and write data frames from CSV format files,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
write.csv(df.florist, file='florist.csv')  # write to file
df.bad <- read.csv(file='badflorist.csv')  # read from file
df.bad  # v.price has bad data point
class(df.bad$v.price)  # numeric coerced to factor by bad data
df.bad$v.price <- as.numeric(  # explicitly coerce to numeric
                            as.character(df.bad$v.price))
df.bad$v.price[2] <- 0.5  # fix value
mean(df.bad$v.price)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Types and Classes}


%%%%%%%%%%%%%%%
\subsection{$R$ Object Attributes}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      $R$ objects can have the following attributes:
      \begin{itemize}[]
        \item length,
        \item names,
        \item dimnames,
        \item dimensions,
        \item class,
        \item Other user-defined attributes/metadata,
      \end{itemize}
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
attributes(5:10)  # a simple vector has no attributes
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
attributes(v.var)  # a named vector has 'names' attribute
class(attributes(v.var))  # the attribute is a list object 
length(v.var)
is.vector(v.var)  # is the object a vector?
is.vector(names(v.var))  # names are character vectors
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{type} of an  $R$ object represents how it's stored in memory,\\
      Examples of $R$ \texttt{types} are \texttt{double}, \texttt{character}, \texttt{list}, etc.
      \vskip1ex
      The \texttt{class} of an  $R$ object is an attribute used for function dispatching in S3 classes,\\
      Examples of $R$ \texttt{classes} are \texttt{character}, \texttt{numeric}, \texttt{matrix}, \texttt{factor}, \texttt{data.frame}, etc.
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
typeof(v.var)  # get object type
class(v.var)  # get object class
typeof(names(v.var))
class(names(v.var))
v.var <- c(1:5, 'a')  # append to vector
v.var  # type coercion
class(v.var)  # get object class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type Coercion}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      When different objects are mixed in a vector, implicit coercion occurs so that every element in the vector is of the same class,
      \vskip1ex
      The rule is that coercion is into larger types (numeric values are coerced into character strings),
      \vskip1ex
      Objects can be explicitly coerced from one class to another using the \texttt{as.*} functions,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, prompt=TRUE>>=
c(1:3, 'a')  # implicit coercion
as.numeric(c(1:3, 'a'))  # explicit coercion
as.logical(0:3)
as.character(0:3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Management and Analysis}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}[]
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for NA and NaN values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove NAs from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, 0/0, 1/0))  # test for NA
is.nan(c(NA, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
v.na <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
mean(v.na)  # returns NA, when NAs are input
mean(v.na, na.rm=TRUE)  # remove NAs from input data
v.na[!is.na(v.na)]  # delete the NA values
sum(!is.na(v.na))  # count non-NA values
      @
  \end{columns}
\end{block}

\begin{block}{}
  \texttt{NULL} isn't bad data, but is a reserved word and represents a null object,\\
  \texttt{NULL} is returned by functions whose value is undefined,\\
  Very often variables are initialized to \texttt{NULL} before iteration,\\
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
head(airquality[!complete.cases(airquality), ])  # display some NAs
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from library \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
good.air <- airquality[complete.cases(airquality), ]  # remove NAs
dim(good.air)
head(good.air)  # NAs removed
library(zoo)  # load package zoo
good.air <- na.locf(airquality)  # replace NAs
dim(good.air)
head(good.air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Extra Stuff}


%%%%%%%%%%%%%%%
\subsection{Calling Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{save()} combine values into a vector or a list,\\
      Reading the help file,\\
      default argument values,\\
      elipsis argument,\\
    \column{0.6\textwidth}
      \vspace{-1em}
      <<tidy=FALSE, eval=FALSE, prompt=TRUE>>=
save(n.var1, n.var2,  # save selected objects
     file="C:/jerzy/temp/my_data.RData")

save(..., list=character(),
     file=stop("'file' must be specified"),
     ascii=FALSE, version=NULL, envir=parent.frame(),
     compress=!ascii, compression_level,
     eval.promises=TRUE, precheck=TRUE)
      @
  \end{columns}
\end{block}
\pause

\begin{block}{\color{red}{Rule of Thumb}}
Use "\texttt{<-}" in $R$ scripts,\\
Use "\texttt{=}" in function calls.\\
\end{block}

\end{frame}


\end{document}
