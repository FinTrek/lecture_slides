% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}



% Title page setup
\title[\texttt{R} Data Objects]{\texttt{R} Data Objects}
\subtitle{FRE6871 \texttt{R} in Finance, Spring 2015}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{\today}



%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Data Objects}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      All data objects in \texttt{R} are \emph{vectors}, or consist of \emph{vectors},
      \vskip1ex
      Single numbers and character strings are vectors of length \texttt{"1"},
      \vskip1ex
      \emph{Atomic} vectors are \emph{homogeneous} objects whose elements are all of the same \emph{mode} (type), 
      \vskip1ex
      \emph{Lists} and \emph{data frames} are \emph{recursive} (heterogeneous) objects, whose elements can be vectors of different \emph{mode},
      \vskip1ex
      The functions \texttt{is.atomic()} and \texttt{is.recursive()} return logical values depending on whether their arguments are \emph{atomic} or \emph{recursive},
      \vskip1ex
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{\texttt{R} Data Objects}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{\emph{Atomic}} & \text{\emph{Recursive}} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# single numbers are vectors of length 1
1
# character strings are vectors of length 1
"a"
# strings without quotes are variable names
a  # variable "a" doesn't exist
# list elements can have different mode
list(aa=c('a', 'b'), bb=1:5)
data.frame(aa=c('a', 'b'), bb=1:2)
is.atomic(data.frame(aa=c('a', 'b'), bb=1:2))
is.recursive(data.frame(aa=c('a', 'b'), bb=1:2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type, Mode, and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{type}, \emph{mode}, and \emph{class} are \texttt{character} strings representing various object properties,
      \vskip1ex
      The \emph{type} of an atomic object represents how it's stored in memory (\texttt{logical}, \texttt{character}, \texttt{integer}, \texttt{double}, etc.)
      \vskip1ex
      The \emph{mode} of an atomic object is the kind of data it represents (\texttt{logical}, \texttt{character}, \texttt{numeric}, etc.)
      \vskip1ex
      The \emph{mode} of an object often coincides with its \emph{type} (except for \texttt{integer} and \texttt{double} types),
      \vskip1ex
      Recursive objects (such as \texttt{lists}) have both \emph{type} and \emph{mode} equal to the recursive type (\texttt{list}, etc.),
      \vskip1ex
      The \emph{class} of an object is either an explicit \emph{class} attribute, or is derived from the object \texttt{dim} attribute, or its \emph{mode} (implicit \emph{class}), 
      \vskip1ex
      The function \texttt{class()} returns the explicit or implicit \emph{class} of an object,
      \vskip1ex
      The \emph{class} attribute is used for function dispatching in the \texttt{S3} object-oriented programming system in \texttt{R},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- "hello"
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- runif(5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(1:10, 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(runif(10), 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- list(aa=c('a', 'b'), bb=1:5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- data.frame(aa=c('a', 'b'), bb=1:2)
c(typeof(my_var), mode(my_var), class(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Implicit Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an object has a \texttt{dim} attribute, then its implicit \emph{class} is \texttt{matrix} or \texttt{array}, 
      \vskip1ex
      If an object has no explicit \emph{class} nor \texttt{dim} attributes, then its implicit \emph{class} is derived from its \emph{mode} (except for \texttt{integer} vectors have implicit class \texttt{"integer"}), 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- matrix(1:10, 2)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- vector(mode="numeric", length=10)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- vector(mode="integer", length=10)
c(typeof(my_var), mode(my_var), class(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Object Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} objects can have different attributes, such as: \texttt{names}, \texttt{dimnames}, \texttt{dimensions}, \emph{class}, etc., 
      \vskip1ex
      The attributes of an object is a named \texttt{list} of \texttt{symbol=value} pairs,
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
      \vskip1ex
      The attributes of an \texttt{R} object can be modified using the \texttt{"attributes() <-"} assignment,
      \vskip1ex
      The function \texttt{structure()} adds attributes to an object (specified as \texttt{symbol=value} pairs), and returns it,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
attributes(5:10)  # a simple vector has no attributes
my_var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
attributes(my_var)  # named vector has "names" attribute
my_var <- 1:10
is.vector(my_var)  # is the object a vector?
attributes(my_var) <- list(dim=c(2, 5))
is.matrix(my_var)  # is the object a matrix?
my_var  # matrix object
structure(1:10, dim=c(2, 5))  # matrix object

my_var <- 0
attributes(my_var) <- list(class="Date")
my_var  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Modifying \protect\emph{class} Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Objects without an explicit \emph{class} don't have a \emph{class} attribute, and the function \texttt{class()} returns the implicit \emph{class},
      \vskip1ex
      The \emph{class} of an object can be modified using the \texttt{"class() <-"} assignment,
      \vskip1ex
      An object can have a main \emph{class}, and also an inherited \emph{class} (the \emph{class} attribute can be a vector of strings),
      \vskip1ex
      The function \texttt{unclass()} removes the explicit class attribute from an object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- matrix(runif(10), 2, 5)
class(my_var)  # has implicit class
attributes(my_var)  # but no explicit "class" attribute
c(typeof(my_var), mode(my_var), class(my_var))
class(my_var) <- "my_class"  # assign explicit "class" attribute
class(my_var)  # has explicit "class"
attributes(my_var)  # has explicit "class" attribute
is.matrix(my_var)  # is the object a matrix?
is.vector(my_var)  # is the object a vector?
attributes(unclass(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Object Coercion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Coercion} means changing the \emph{type}, \emph{mode}, or \emph{class} of an object, often without changing the underlying data,
      \vskip1ex
      Changing the \emph{mode} of an object can change its \emph{class} as well, but not always,
      \vskip1ex
      Objects can be explicitly coerced using the "\texttt{as.*}" coercion functions,
      \vskip1ex
      Most coercion functions strip the attributes from the object,
      \vskip1ex
      Implicit coercion occurs when objects with different \texttt{modes} are combined into a vector, forcing the elements to have the same \emph{mode},
      \vskip1ex
      Implicit coercion can cause bugs that are difficult to trace,
      \vskip1ex
      The rule is that coercion is into larger types (\texttt{numeric} objects are coerced into \texttt{character} strings),
      \vskip1ex
      Coercion can introduce bad data, such as \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))

mode(my_var) <- "character"  # coerce to "character"
my_var
c(typeof(my_var), mode(my_var), class(my_var))
my_var <- as.character(1:5)  # explicitly coerce to "character"
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(1:10, 2, 5)
my_var <- as.character(my_var)  # explicitly coerce to "character"
c(typeof(my_var), mode(my_var), class(my_var))
is.matrix(my_var)  # is the object a matrix?

as.logical(0:3)  # explicit coercion to "logical"

c(1:3, 'a')  # implicit coercion to "character"
as.numeric(c(1:3, 'a'))  # explicit coercion to "numeric"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Atomic Data Objects}


%%%%%%%%%%%%%%%
\subsection{Basic \texttt{R} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Let's start by typing some \emph{text},
      \vskip1ex
      The quotation marks \texttt{""} (or \texttt{''}) around the characters tell \texttt{R} that it's a string, not a variable name,
      \vskip1ex
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      There are no scalars in \texttt{R}, so a single value is stored as a vector of length \texttt{1},
      \vskip1ex
      A character string is also a vector with a single element, with the first element of the vector containing the string of text,
      \vskip1ex
      The colon binary operator \texttt{':'} produces a vector,
      \vskip1ex
      The function \texttt{c()} combines objects into a vector,
      \vskip1ex
      The '\texttt{[1]}' symbol means the return value is a vector,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
"Hello World!"  # type some text
# R thinks 'hello' is a variable name, because it's not in quotes
hello
4:8  # create a vector
2*4:8  # create a vector
2*(4:8)  # create a vector
4:8/2  # create a vector
round(4:8/2)  # create a vector
trunc(4:8/2)  # create a vector
c(1, 2, 3, 4, 5)  # create vector using c() combine function
c('a', 'b', 'c')  # create vector using c() combine function
c(1, 'b', 'c')  # create vector using c() combine function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one),
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string,
      \vskip1ex
      Special characters in strings:\\
      "\texttt{\textbackslash{}t}" for TAB,\\
      "\texttt{\textbackslash{}n}" for new-line,\\
      "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{cat()} concatenates strings and echos them to console, without returning any values,
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str_var <- "Some string"
str_var
str_var[1]
str_var[2]

length(str_var)  # length of vector
nchar(str_var)  # length of string

cat("Enter\ttab")
cat("Enter\nnewline")
cat("Enter\\backslash")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, coerces them to characters if needed, and returns the string,
      \vskip1ex
      If a vector or list is passed to \texttt{paste()}, together with a \texttt{collapse} string, then \texttt{paste()} concatenates the elements into a string, separated by the \texttt{collapse} string,
      \vskip1ex
      The function \texttt{strsplit()} splits the elements of a character vector,
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string,
      \vskip1ex
      The recycling rule extends the length to match the longest object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str_var1 <- "Hello"  # define a character string
str_var2 <- "World!"  # define a character string

paste(str_var1, str_var2, sep=' ')  # concatenate and return value
cat(str_var1, str_var2)  # concatenate and echo to console
paste('a', 1:4, sep='-')  # convert, recycle and concatenate

paste(c("a1", "a2", "a3"), collapse="+")  # collapse vector to string
paste(list("a1", "a2", "a3"), collapse="+")

paste("Today is", Sys.time())  # coerce and concatenate strings
paste("Today is", format(Sys.time(), "%B-%d-%Y"))

strsplit("Hello World", split='r')  # split string
substring("Hello World", 3, 6)  # extract characters from 3 to 6
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has Regex functions for pattern matching and replacement, 
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string,
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string,
      \vskip1ex
      The function \texttt{glob2rx()} converts globbing wildcard patterns into regular expressions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
gsub("is", "XX", "is this gratis?")  # replace "is" with "XX"

grep("b+", c("abc", "xyz", "cba d", "bbb"))  # get indexes

grep("b+", c("abc", "xyz", "cba d", "bbb"), value=TRUE)  # get values

glob2rx("abc.*")  # convert globs into regex
glob2rx("*.doc")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      The function \texttt{c()} combines values into a vector,
      \vskip1ex
      Vectors can be multiplied and squared element by element, as if they were single elements,
      \vskip1ex
      Vectors can be manipulated as if they were single elements, and \texttt{R} automatically performs a loop over the vector elements, and applies the operation element-wise,
      \vskip1ex
      This is a very powerful feature of \texttt{R} called \emph{vectorized arithmetic},
      \vskip1ex
      \emph{Vectorized arithmetic} avoids writing loops and simplifies notation,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var <- c(pi, exp(1), -digamma(1))  # define a vector
vec_var

vec_var[2]  # extract second element
vec_var[-2]  # extract all elements, except the second element

vec_var[c(FALSE, TRUE, TRUE)]  # extract second and third elements
vec_var == vec_var[2]  # logical vector of elements equal to the second one
vec_var[vec_var == vec_var[2]]  # extract all elements equal to the second one

vec_var < 1  # logical vector of elements less than one
vec_var[vec_var > 1]  # extract all elements greater than one

2*vec_var  # multiply all elements by 2
vec_var^2  # square all elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Creating\hskip0.5em\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The colon operator ("\texttt{:}") provides a simple way of creating a numeric vector,
      \vskip1ex
      The function \texttt{vector()} returns a vector of the specified \emph{mode},
      \vskip1ex
      The function \texttt{seq()} returns a vector of numbers,
      \vskip1ex
      The function \texttt{rep()} replicates an object multiple times,
      \vskip1ex
      The functions \texttt{numeric()} and \texttt{character()} return empty (zero length) vectors of the specified \emph{type} (not to be confused with a \texttt{NULL} object),
      \vskip1ex
      Zero length vectors are not \texttt{NULL},
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
0:10  # vector of integers from 0 to 10
(0:10)/10  # vector of decimals from 0 to 1.0
vector()  # create empty vector
vector(mode="numeric", length=10)  # create numeric vector of zeros
seq(10)  # sequence from 1 to 10
seq(along=(-5:5))  # instead of 1:length(obj)
seq(from=0, to=1, len=11)  # vector of decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # vector of decimals from 0 to 1.0
seq(-2,2, len=11)  # 10 evenly distributed numbers from -2 to 2
rep(100, times=5)  # replicate a number
character(5)  # create empty character vector
numeric(5)  # create empty numeric vector
numeric(0)  # create zero length vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Naming and Manipulating\hskip0.5em\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vector elements can be assigned \texttt{names} using a list of symbol-value pairs,
      \vskip1ex
      The function \texttt{names()} returns the \texttt{names} attribute of an object,
      \vskip1ex
      The \texttt{names} attribute of a vector can be modified by assigning to the \texttt{names()} function ("\texttt{names() <-}" assignment),
      \vskip1ex
      The function \texttt{unname()} removes the \texttt{names} attribute,
      \vskip1ex
      Vectors can be combined together and appended,
      \vskip1ex
      The object \texttt{letters} is a constant and a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
vec_var
names(vec_var)  # get names of elements
vec_var['euler']  # get element named 'euler'
names(vec_var) <- c("pie","eulery","gammy")  # rename elements
vec_var
unname(vec_var)  # remove names attribute
c(11, 5:10)  # combine two vectors
c(vec_var, 2.0)  # append number to vector

letters[5:10]  # vector of letters
c('a', letters[5:10])  # combine two vectors of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting\hskip0.5em\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vector elements can be \emph{subset} (indexed, dereferenced) using the \texttt{"[]"} operator,
      \vskip1ex
      Vectors can be \emph{subset} using vectors of:
      \begin{itemize}
        \item positive integers,
        \item negative integers,
        \item characters (names),
        \item logical vectors,
      \end{itemize}
      \vskip1ex
      A named vector can be \emph{subset} using element names,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var  # named vector
vec_var[2]  # extract second element
vec_var[-2]  # extract all elements, except the second element
vec_var[c(FALSE, TRUE, TRUE)]  # extract second and third elements
vec_var["eulery"]  # extract elements using their names
vec_var[c("pie", "gammy")]  # extract elements using their names
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Filtering\hskip0.5em\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Filtering} means extracting elements from a vector that satisfy a logical condition,
      \vskip1ex
      When logical comparison operators are applied to vectors, they produce logical vectors,
      \vskip1ex
      Logical vectors can then be applied to subset the original vectors, to extract their elements,
      \vskip1ex
      The function \texttt{which()} returns the indices of elements that satisfy a logical condition,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var <- runif(5)
vec_var
vec_var > 0.5  # logical vector
# logical vector of elements equal to the second one
vec_var == vec_var[2]
# extract all elements equal to the second one
vec_var[vec_var == vec_var[2]]
vec_var < 1  # logical vector of elements less than one
vec_var[vec_var > 1]  # extract all elements greater than one
vec_var[vec_var > 0.5]  # filter elements > 0.5
which(vec_var > 0.5)  # index of elements > 0.5
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Factors are similar to vectors, but their elements can only take values from a set of \emph{levels},
      \vskip1ex
      Factors are designed for categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a vector into a factor,
      \vskip1ex
      Factors have two attributes: \emph{class} (equal to \texttt{"factor"}) and \texttt{levels} (the allowed values),
      \vskip1ex
      The function \texttt{as.vector()} coerces a factor to a character vector,
      \vskip1ex
      The function \texttt{as.numeric()} extracts the encoding vector (indices) of a factor,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
# create factor vector
fact_var <- factor(c('b', 'c', 'd', 'a', 'c', 'b'))
fact_var
fact_var[3]
attributes(fact_var)  # get factor attributes
levels(fact_var)  # get allowed values
as.numeric(fact_var)  # get encoding vector
table(fact_var)  # get contingency (frequency) table
is.vector(fact_var)
as.vector(fact_var)  # coerce factor to character vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{matrix()} creates a matrix from a vector, and the matrix dimensions,
      \vskip1ex
      The elements of matrices can be subset (dereferenced) using the \texttt{"[]"} operator,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
mat_var <- matrix(5:10, nrow=2, ncol=3)  # create a matrix
mat_var  # by default matrices are constructed column-wise

mat_var[2, 3]  # extract third element from second row
mat_var[2, ]  # extract second row
mat_var[, 3]  # extract third column
mat_var[, c(1,3)]  # extract first and third column
mat_var[, -2]  # remove second column
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Arrays are vectors with a dimension attribute,
      \vskip1ex
      Matrices are two-dimensional arrays,
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
      \vskip1ex
      The \texttt{dimnames} attribute is a list, with vector elements containing row and column names,
      \vskip1ex
      A named matrix can be subset using row and column names,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
attributes(mat_var)  # get matrix attributes
dim(mat_var)  # get dimension attribute
class(mat_var)  # get class attribute
rownames(mat_var) <- c("row1", "row2")  # set the rownames attribute
colnames(mat_var) <- c("col1", "col2", "col3")  # set the colnames attribute
mat_var
mat_var["row2", "col3"]  # get third element from second row
names(mat_var)  # get the names attribute
dimnames(mat_var)  # get dimnames attribute
attributes(mat_var)  # get matrix attributes
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Subsetting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Matrices can be subset in a similar way as Vectors, either by indices (integers), by characters (names), or logical vectors,
      \vskip1ex
      Subsetting a matrix to a single row or column produces a vector, unless the parameter \texttt{"drop=FALSE"} is used,
      \vskip1ex
      Subsetting with the parameter \texttt{"drop=FALSE"} prevents the implicit coercion and preserves the matrix \emph{class},
      \vskip1ex
      This is an example of implicit coercion in \texttt{R}, which can cause difficult to trace bugs,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
mat_var  # matrix with column names
mat_var[1, ]  # subset rows by index
mat_var[, "col1"]  # subset columns by name
mat_var[, c(TRUE, FALSE, TRUE)]  # subset columns by logical vector
mat_var[1, ]  # subsetting can produce a vector!
class(mat_var); class(mat_var[1, ])
is.matrix(mat_var[1, ]); is.vector(mat_var[1, ])
mat_var[1, , drop=FALSE]  # drop=FALSE preserves matrix
class(mat_var[1, , drop=FALSE])
is.matrix(mat_var[1, , drop=FALSE]); is.vector(mat_var[1, , drop=FALSE])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Vectors Into Matrices}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be coerced into matrices by adding a dimension attribute,
      \vskip1ex
      The \texttt{dimnames} attribute can be assigned a named list to convert it into a named matrix,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
mat_var <- 1:6  # create a vector
class(mat_var)  # get its class

dim(mat_var) <- c(2, 3)  # add dimension attribute to coerce into matrix
class(mat_var)  # get its class
is.matrix(mat_var)  # is the object a matrix?

dimnames(mat_var) <- list('rows'=c('row1', 'row2'),  # set dimnames attribute
                        'columns'=c('col1', 'col2', 'col3'))

mat_var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()},
      \vskip1ex
      The \emph{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var1 <- 1:3  # define vector
vec_var2 <- 6:4  # define vector
cbind(vec_var1, vec_var2)  # bind into columns
rbind(vec_var1, vec_var2)  # bind into rows
vec_var2 <- c(vec_var2, 7)  # extend second vector to four elements
cbind(vec_var1, vec_var2)  # recycling rule applied
1:6 + c(10, 20)  # another example of recycling rule
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \emph{operator} \texttt{*} performs \emph{element-by-element} multiplication on vectors and matrices,
      \vskip1ex
      The \emph{operator} \texttt{\%*\%} performs \emph{vector} multiplication on vectors and matrices,
      \vskip1ex
      In \emph{vector} multiplication the dimensions of the objects must be \emph{conformable}, otherwise the \emph{recycling rule} is applied or an error is produced,
      \vskip1ex
      The function \texttt{drop()} removes any dimensions of length \emph{one},
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
vec_var1
vec_var2 <- 6:4  # define vector
# multiply two vectors element-by-element
vec_var1 * vec_var2
# calculate scalar ("inner") product
vec_var1 %*% vec_var2
# calculate inner product and drop dimensions
drop(vec_var1 %*% vec_var2)
mat_var
# multiply vector by matrix
mat_var %*% vec_var1  # single column matrix
drop(mat_var %*% vec_var1)  # vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Transpose}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{t()} returns the transpose of a matrix,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
# multiply matrix by vector
# fails because dimensions of objects aren't conformable
vec_var1 %*% mat_var
# works after transpose
drop(vec_var1 %*% t(mat_var))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Recursive Data Objects}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Lists are a type of vector that contain elements of different \emph{types},
      \vskip1ex
      Lists are recursive object types,
      \vskip1ex
      The function \texttt{list()} creates a list from a list of vectors,
      \vskip1ex
      \texttt{list()} creates a named list from a list of symbol-value pairs,
      \vskip1ex
      The function \texttt{unlist()} flattens a list into a vector that contains the atomic elements of the list (which typically causes coercion),
    \column{0.7\textwidth}
      \vspace{-2em}
      <<>>=
# create a list with two elements
list_var <- list(c('a', 'b'), 1:4)
list_var
c(class(list_var), typeof(list_var))
c(is.vector(list_var), is.list(list_var))
length(list_var)
# create named list
list_var <- list(first=c('a', 'b'), second=1:4)
list_var
names(list_var)
unlist(list_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Lists can be subset (indexed) using:
      \begin{itemize}
        \item the '\texttt{[}' operator (returns sublist),
        \item the '\texttt{[[}' operator (returns an element),
        \item the '\texttt{\$}' operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
list_var[2]  # extract second element as sublist
list_var[[2]]  # extract second element
list_var[[2]][3]  # extract third element of second element
list_var[[c(2, 3)]]  # extract third element of second element
list_var$second  # extract second element
list_var$s  # extract second element - partial name matching
list_var$second[3]  # extract third element of second element
list_var <- list()  # empty list
list_var$a <- 1
list_var[2] <- 2
list_var
names(list_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames are \texttt{2-D} objects (like matrices), but their columns can be of different \emph{types},
      \vskip1ex
      Data frames can be thought of as lists of vectors of the same length,
      \vskip1ex
      The function \texttt{data.frame()} creates a \texttt{data frame} from vectors assigned to column names,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0)
                    )  # end data.frame
data_frame
dim(data_frame)  # get dimension attribute
colnames(data_frame)  # get the colnames attribute
rownames(data_frame)  # get the rownames attribute
class(data_frame)  # get object class
typeof(data_frame)  # data frames are lists
is.data.frame(data_frame)

class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
data_frame[2, 3]  # extract second row and third column
data_frame[[3]]  # extract third column
data_frame$color[3]  # extract third row from column 'color'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname\hskip0.5emand Factors}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      By default \texttt{data.frame()} coerces \texttt{character} vectors to \texttt{factors}, unless the \texttt{stringsAsFactors=FALSE} option is passed into \texttt{data.frame()},
      \vskip1ex
      The function \texttt{options()} sets global \texttt{options}, that determine how \texttt{R} computes and displays its results,
      \vskip1ex
      If the global \texttt{option} \texttt{stringsAsFactors=FALSE} is set, then \texttt{character} vectors will not be coerced to \texttt{factors} in all subsequent \texttt{data frame} operations,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0),
                      row.names=c('flower1', 'flower2', 'flower3'),
                      stringsAsFactors=FALSE
                    )  # end data.frame
data_frame
class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
# set option to not coerce character vectors to factors
options(stringsAsFactors=FALSE)
options("stringsAsFactors")
default.stringsAsFactors()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{str()} displays the structure of an \texttt{R} object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an \texttt{R} object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
str(data_frame)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{sort()} returns a sorted vector,
      \vskip1ex
      The function \texttt{order()} returns a permutation index,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=(-(1:7))>>=
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
# create a data frame
data_frame <- data.frame(type, color, price)
# assign rownames
rownames(data_frame) <- c('flower1', 'flower2', 'flower3')
sort_data <- sample(1:6)  # permute data
sort_data
sort(sort_data)  # sorted data
order(sort_data)  # permution index
sort_data[order(sort_data)]  # permution index
order(data_frame$price)  # permute on price
data_frame[order(data_frame$price), ]  # sort on price
data_frame[order(data_frame$color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{iris} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{iris} data frame is included in the \texttt{datasets} base package,
      \vskip1ex
      \texttt{iris} contains sepal and petal dimensions of 50 flowers from 3 species of iris,
      \vskip1ex
      The function \texttt{unique()} extracts unique elements of an object,
      \vskip1ex
      \texttt{sapply()} applies a function to a list or a vector of objects and returns a vector,
      \vskip1ex
      \texttt{sapply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
# ?iris  # get information on iris
dim(iris)
head(iris, 2)
colnames(iris)
unique(iris$Species)  # extract list of unique elements of iris
class(unique(iris$Species))
# find which columns of iris are numeric
sapply(iris, is.numeric)
# calculate means of iris columns
sapply(iris, mean)  # returns NA for Species
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{mtcars} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{mtcars} data frame is included in the \texttt{datasets} base package, and contains design and performance data for 32 automobiles,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
# ?mtcars  # get information on mtcars - data from 1974 Motor Trend magazine
# mpg   Miles/(US) gallon
# qsec   1/4 mile time
# hp	 Gross horsepower
# wt	 Weight (lb/1000)
# cyl   Number of cylinders
dim(mtcars)
head(mtcars, 2)
colnames(mtcars)
head(rownames(mtcars), 3)
unique(mtcars$cyl)  # extract list of car cylinders
sapply(mtcars, mean)  # calculate means of mtcars columns
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{Cars93} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{Cars93} data frame is included in the \texttt{MASS} package, and contains design and performance data for 93 automobiles,
      \vskip1ex
      The function \texttt{hist()} calculates and plots a histogram,
      \vskip1ex
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      \texttt{"FD"} stands for the Freedman-Diaconis rule for calculating histogram breaks,
        <<Cars93_hist,fig.show='hide'>>=
library(MASS)
# ?Cars93  # get information on Cars93
dim(Cars93)
head(colnames(Cars93))
# head(Cars93, 2)
unique(Cars93$Type)  # extract list of car types
# sapply(Cars93, mean)  # calculate means of Cars93 columns
# plot histogram of Highway MPG using the Freedman-Diaconis rule
hist(Cars93$MPG.highway, col="lightblue1", 
     main="Distance per Gallon 1993", xlab="Highway MPG", breaks="FD")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/Cars93_hist-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Management and Analysis}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for NA and NaN values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove \texttt{NAs} from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, NaN, 0/0, 1/0))  # test for NA
is.nan(c(NA, NaN, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
bad_data <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
mean(bad_data)  # returns NA, when NAs are input
mean(bad_data, na.rm=TRUE)  # remove NAs from input data
bad_data[!is.na(bad_data)]  # delete the NA values
sum(!is.na(bad_data))  # count non-NA values
      @
  \end{columns}
\end{block}

\begin{block}{}
  \texttt{NULL} isn't bad data, but is a reserved word and represents a null object,\\
  \texttt{NULL} is returned by functions whose value is undefined,\\
  Very often variables are initialized to \texttt{NULL} before iteration,\\
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
head(airquality[!complete.cases(airquality), ])  # display some NAs
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from library \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
good_air <- airquality[complete.cases(airquality), ]  # remove NAs
dim(good_air)
head(good_air)  # NAs removed
library(zoo)  # load package zoo
good_air <- na.locf(airquality)  # replace NAs
dim(good_air)
head(good_air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
