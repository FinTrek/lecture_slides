% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}



% Title page setup
\title[Date and Time Series Objects]{Date and Time Series Objects}
\subtitle{FRE6871 \texttt{R} in Finance, Spring 2015}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{\today}



%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Date and Time Objects}


%%%%%%%%%%%%%%%
\subsection{Date Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has a \texttt{Date} class for date objects (but without time),
      \vskip1ex
      The function \texttt{as.Date()} parses a \texttt{character} string into a date object,
      \vskip1ex
      \texttt{R} stores \texttt{Date} objects as the number of days since the \texttt{epoch} (January 1, 1970),
      \vskip1ex
      \texttt{numeric} \emph{year-fraction} dates can be coerced to \texttt{Date} objects using the functions \texttt{attributes()} and \texttt{structure()},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
Sys.Date()  # get today's date
date_time <- as.Date("2012-07-14")  # "%Y-%m-%d" or "%Y/%m/%d"
date_time
class(date_time)  # Date object
as.Date("07-14-2014", "%m-%d-%Y")  # specify format
date_time + 20  # add 20 days
as.numeric(date_time)  # get internal integer representation
date_old <- as.Date("07/14/2013", "%m/%d/%Y")
date_old
# difference between dates
difftime(date_time, date_old, units="weeks")
weekdays(date_time)  # get day of the week
# coerce numeric into date-times
date_time <- 0
attributes(date_time) <- list(class="Date")
date_time  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{POSIXct} Date-time Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} has a class \texttt{POSIXct} for Date-time (date-time) objects,
      \vskip1ex
      The function \texttt{as.POSIXct()} parses a \texttt{character} string into a \texttt{POSIXct} object,
      \vskip1ex
      \texttt{format()} converts \emph{date-time} objects to \texttt{character} strings, given a time zone,
      \vskip1ex
      \texttt{format.POSIXct()} parses \texttt{POSIXct} objects to \texttt{character} strings,
      \vskip1ex
      \texttt{R} stores \texttt{POSIXct} objects as the number of seconds since the \texttt{epoch} (January 1, 1970 UTC),
      \vskip1ex
      \texttt{POSIX} is an acronym for "Portable Operating System Interface",
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
date_time <- Sys.time()  # get today's date and time
date_time
class(date_time)  # POSIXct object
as.numeric(date_time)  # get internal integer representation
# parse character string "%Y-%m-%d %H:%M:%S" to POSIXct object
as.POSIXct("2012-07-14 13:30:10")
format(date_time)  # convert POSIXct to character string
class(format(date_time))  # character string
date_time + 20  # add 20 seconds
as.POSIXct(as.Date(date_time)+1)  # add a day
trunc(date_time, units="hours")  # truncate to closest hour
as.POSIXct(as.character(as.Date(date_time)))  # truncate to closest day
methods(trunc)  # trunc methods
trunc.POSIXt
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{POSIXlt} Date-time Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} has a class \texttt{POSIXlt} for \emph{date-time} objects,
      \vskip1ex
      \texttt{R} stores \texttt{POSIXlt} objects as a list,
      \vskip1ex
      The function \texttt{as.POSIXlt()} parses a \texttt{character} string into a \texttt{POSIXlt} object,
      \vskip1ex
      \texttt{format.POSIXlt()} converts \texttt{POSIXlt} objects to \texttt{character} strings,
      \vskip1ex
      Adding a number to \texttt{POSIXlt} causes implicit coercion to \texttt{POSIXct},
      \vskip1ex
      \texttt{POSIXct} and \texttt{POSIXlt} are two derived classes of the more general \texttt{POSIXt} class,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
# parse character string "%Y-%m-%d %H:%M:%S" to POSIXlt object
date_time <- as.POSIXlt("2012-07-14 18:30:10")
date_time
class(date_time)  # POSIXlt object
aperm(as.matrix(unclass(date_time)))  # get internal representation

date_time + 20  # add 20 seconds
class(date_time + 20)  # implicit coercion to POSIXct
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Zones and Date-time Conversion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{date-time} objects require a time zone to be uniquely specified,
      \vskip1ex
      \texttt{UTC} stands for "Universal Time Coordinated", and is synonymous with \texttt{GMT}, but doesn't change with Daylight Saving Time,
      \vskip1ex
      \texttt{EST} stands for "Eastern Standard Time", \texttt{UTC} - 5 hours,
      \vskip1ex
      \texttt{EDT} stands for "Eastern Daylight Time", \texttt{UTC} - 4 hours,
      \vskip1ex
      The function \texttt{Sys.setenv()} can be used to set the default time zone,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
Sys.timezone()  # get time-zone
Sys.setenv(tz="UTC")  # set time-zone to UTC
Sys.timezone()  # get time-zone
# Standard Time in effect
as.POSIXct("2013-03-09 11:00:00", tz="America/New_York")
# Daylight Savings Time in effect
as.POSIXct("2013-03-10 11:00:00", tz="America/New_York")
date_time <- Sys.time()  # today's date and time
# convert to character in different TZ
format(date_time, tz="America/New_York")
format(date_time, tz="UTC")
# parse back to POSIXct
as.POSIXct(format(date_time, tz="America/New_York"))
# difference between local time and UTC
as.POSIXct(format(Sys.time(), tz="UTC")) - 
  as.POSIXct(format(Sys.time(), tz="America/New_York"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Date-time Objects Using \texttt{lubridate}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The package \texttt{lubridate} contains functions for converting and manipulating date-time objects,
      \vskip1ex
      The \texttt{ymd(), dmy()}, etc. functions parse \texttt{character} and \texttt{numeric} \emph{year-fraction} dates into \texttt{POSIXct} objects,
      \vskip1ex
      The \texttt{mday(), month(), year()}, etc. accessor functions extract date-time components,
      \vskip1ex
      The function \texttt{decimal\_date()} converts \texttt{POSIXct} objects into \texttt{numeric} \emph{year-fraction} dates,
      \vskip1ex
      The function \texttt{date\_decimal()} converts \texttt{numeric} \emph{year-fraction} dates into \texttt{POSIXct} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
library(lubridate)  # load lubridate
# parse strings into date-times
as.POSIXct("07-14-2014", format="%m-%d-%Y", tz="America/New_York")
date_time <- mdy("07-14-2014", tz="America/New_York")
date_time
class(date_time)  # POSIXct object
dmy("14.07.2014", tz="America/New_York")

# parse numeric into date-times
as.POSIXct(as.character(14072014), format="%d%m%Y", 
                        tz="America/New_York")
dmy(14072014, tz="America/New_York")

# parse decimal to date-times
decimal_date(date_time)
date_decimal(2014.25, tz="America/New_York")
date_decimal(decimal_date(date_time), tz="America/New_York")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Zones Using \texttt{lubridate}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{lubridate} simplifies time zone calculations,
      \vskip1ex
      The \emph{moment of time} is the time in the \texttt{UTC} time zone,
      \vskip1ex
      The \emph{clock time} is the time (number of hours, minutes and seconds) in the local time zone,
      \vskip1ex
      The same \emph{moment of time} corresponds to different \emph{clock times} in different time zones,
      \vskip1ex
      The same \emph{clock times} in different time zones correspond to different \emph{moments of time},
      \vskip1ex
      The function \texttt{with\_tz()} creates a date-time object with the same moment of time in a different time zone,
      \vskip1ex
      The function \texttt{force\_tz()} creates a date-time object with the same clock time in a different time zone,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(lubridate)  # load lubridate
date_time <- ymd_hms(20140714142010, 
                     tz="America/New_York")
date_time

# get same moment of time in "UTC" time zone
with_tz(date_time, "UTC")
as.POSIXct(format(date_time, tz="UTC"), tz="UTC")

# get same clock time in "UTC" time zone
force_tz(date_time, "UTC")
as.POSIXct(format(date_time), tz="UTC")

# same moment of time
date_time - with_tz(date_time, "UTC")

# different moments of time
date_time - force_tz(date_time, "UTC")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{lubridate} Time Span Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{lubridate} has two time span classes: \texttt{durations} and \texttt{periods},
      \vskip1ex
      \texttt{durations} specify exact time spans, such as numbers of seconds, hours, days, etc.
      \vskip1ex
      The functions \texttt{ddays(), dyears()}, etc. return \texttt{duration} objects,
      \vskip1ex
      \texttt{periods} specify relative time spans that don't have a fixed length, such as months, years, etc.
      \vskip1ex
      \texttt{periods} account for variable days in the months, for Daylight Savings Time, and for leap years,
      \vskip1ex
      The functions \texttt{days(), months(), years()}, etc. return \texttt{period} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(lubridate)  # load lubridate
# Daylight Savings Time handling periods vs durations
date_time <- as.POSIXct("2013-03-09 11:00:00", 
                        tz="America/New_York")
date_time
date_time + ddays(1)  # add duration
date_time + days(1)  # add period

leap_year(2012)  # leap year
date_time <- dmy(01012012, tz="America/New_York")
date_time
date_time + dyears(1)  # add duration
date_time + years(1)  # add period
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Adding Time Spans to Date-time Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{periods} allow calculating future dates with the same day of the month, or month of the year,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(lubridate)  # load lubridate
date_time <- ymd_hms(20140714142010, tz="America/New_York")
date_time
# add periods to a date-time
c(date_time + seconds(1), date_time + minutes(1), 
date_time + days(1), date_time + months(1))

# create vectors of dates
date_time <- ymd(20140714, tz="America/New_York")
date_time + 0:2 * months(1)  # monthly dates
date_time + months(0:2)
date_time + 0:2 * months(2)  # bi-monthly dates
date_time + seq(0, 5, by=2) * months(1)
seq(date_time, length=3, by="2 months")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{End-of-month Dates}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Adding monthly \texttt{periods} can create invalid dates,
      \vskip1ex
      The operators \texttt{\%m+\%} and \texttt{\%m-\%} add or subtract monthly \texttt{periods} to account for the varible number of days per month,
      \vskip1ex
      This allows creating vectors of end-of-month dates,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(lubridate)  # load lubridate
# adding monthly periods can create invalid dates
date_time <- ymd(20120131, tz="America/New_York")
date_time + 0:2 * months(1)
date_time + months(1)
date_time + months(2)

# create vector of end-of-month dates
date_time %m-% months(13:1)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{RQuantLib} Calendar Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The package \texttt{RQuantLib} contains a large library of functions for pricing fixed-income instruments and options, and for risk management calculations,
      \vskip1ex
      The package \texttt{RQuantLib} contains calendar functions for determining holidays and business days in many different jurisdictions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # load zoo
library(RQuantLib)  # load RQuantLib

# create daily date series of class 'Date'
in_dex <- Sys.Date() + -5:2
in_dex

# create logical vector of business days
bus.days <- isBusinessDay(  # RQuantLib calendar
  calendar="UnitedStates/GovernmentBond", in_dex)

# create daily series of business days
bus_index <- in_dex[bus.days]
bus_index
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Review of Date-time Classes in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{Date} class from the \texttt{base} package is suitable for \emph{daily} time series,
      \vskip1ex
      The \texttt{POSIXct} class from the \texttt{base} package is suitable for \emph{intra-day} time series,
      \vskip1ex
      The \texttt{yearmon} and  \texttt{yearqtr} classes from the \texttt{zoo} package are suitable for \emph{quarterly} and \emph{monthly} time series,
    \column{0.7\textwidth}
      \vspace{-2em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
date_time <- Sys.Date()  # create date series of class 'Date'
in_dex <- date_time + 0:365  # daily series over one year
head(in_dex, 4)  # print first few dates
format(head(in_dex, 4), "%m/%d/%Y")  # print first few dates
# create daily date-time series of class 'POSIXct'
in_dex <- seq(Sys.time(), by="days", length.out=365)
head(in_dex, 4)  # print first few dates
format(head(in_dex, 4), "%m/%d/%Y %H:%M:%S")  # print first few dates
# create series of monthly dates of class 'zoo'
monthly_index <- yearmon(2010+0:36/12)
head(monthly_index, 4)  # print first few dates
# create series of quarterly dates of class 'zoo'
qrtly_index <- yearqtr(2010+0:16/4)
head(qrtly_index, 4)  # print first few dates
# parse quarterly 'zoo' dates to POSIXct
Sys.setenv(tz="UTC")
as.POSIXct(head(qrtly_index, 4))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Time Series Objects}


%%%%%%%%%%%%%%%
\subsection{Time Series Objects of Class \texttt{ts}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Time series} are data objects that contain a \emph{date-time} index and data associated with it,
      \vskip1ex
      The native time series class in \texttt{R} is \texttt{"ts"},
      \vskip1ex
      \texttt{ts} time series are \emph{regular}, i.e. they can only have an equally spaced \emph{date-time} index,
      \vskip1ex
      \texttt{ts} time series have a \texttt{numeric} \emph{date-time} index, usually encoded as a \emph{year-fraction}, or some other unit, like number of months, etc.,
      \vskip1ex
      For example the date \texttt{"2015-03-31"} can be encoded as a \emph{year-fraction} equal to \texttt{2015.244},
      \vskip1ex
      The \texttt{stats} base package contains functions for manipulating time series objects of class \texttt{ts},
      \vskip1ex
      The function \texttt{ts()} creates a \texttt{ts} time series from a \texttt{numeric} vector or matrix, and from the associated \emph{date-time} information (the number of data per time unit: year, month, etc.),
      \vskip1ex
      The \texttt{frequency} argument is the number of observations per unit of time,
      \vskip1ex
      For example, if the \emph{date-time} index is encoded as a \emph{year-fraction}, then \texttt{frequency=12} means \texttt{12} monthly data points per year,
    \column{0.5\textwidth}
        \vspace{-1em}
        <<echo=(-(1:2))>>=
library(lubridate)  # load lubridate
set.seed(1121)  # for reproducibility
# create daily time series ending today
start_date <- decimal_date(Sys.Date()-6)
end_date <- decimal_date(Sys.Date())
da_ta <- cumsum(rnorm(6))
fre_quency <- length(da_ta)/(end_date-start_date)
ts_series <- ts(data=da_ta,
                start=start_date, 
                frequency=fre_quency)
ts_series  # display time series
# display index dates
as.Date(date_decimal(coredata(time(ts_series))))
# create bi-monthly series starting mid-1990
ts_series <- ts(data=cumsum(rnorm(96)), 
             frequency=6, start=1990.5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating \texttt{ts} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{ts} time series don't store their \emph{date-time} indices, and instead store only a \texttt{"tsp"} attribute that specifies the index \texttt{start} and \texttt{end} dates and its \texttt{frequency},
      \vskip1ex
      The \emph{date-time} index is calculated as needed from the \texttt{"tsp"} attribute,
      \vskip1ex
      The function \texttt{time()} extracts the \emph{date-time} index of a \texttt{ts} time series object, 
      \vskip1ex
      The function \texttt{window()} subsets the a \texttt{ts} time series object, 
    \column{0.6\textwidth}
        \vspace{-1em}
        <<>>=
# show some methods for class "ts"
matrix(methods(class="ts")[3:8], ncol=2)
# "tsp" attribute specifies the date-time index
attributes(ts_series)
# extract the index
tail(time(ts_series), 11)
# the index is equally spaced
diff(tail(time(ts_series), 11))
# subset the time series
window(ts_series, start=1992, end=1992.25)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting \texttt{ts} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The method \texttt{plot.ts()} plots \texttt{ts} time series objects, 
        <<ts_obj,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
plot(ts_series, type="l",  # create plot
     col="red", lty="solid", xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ts_obj-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{EuStockMarkets}
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Data}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} includes a number of \texttt{base} packages that are already installed and loaded,
      \vskip1ex
      \texttt{datasets} is a \texttt{base} package containing various datasets, for example: \texttt{EuStockMarkets},
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices,
        <<eustx_ts,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
class(EuStockMarkets)  # multiple ts object
dim(EuStockMarkets)
head(EuStockMarkets, 3)  # get first three rows
# EuStockMarkets index is equally spaced
diff(tail(time(EuStockMarkets), 4))
# plot all the columns
plot(EuStockMarkets, main="", xlab="")
# add title
title(main="EuStockMarkets", line=-2)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_ts-1}
      \vspace{-2em}
      \texttt{EuStockMarkets} is a \texttt{mts()} time series object,
      \vskip1ex
      The \texttt{EuStockMarkets} \emph{date-time} index is equally spaced (\emph{regular}), so the \emph{year-fraction} dates don't correspond to actual trading days,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{EuStockMarkets}
\begin{frame}[fragile,t]{Plotting \subsecname \hskip0.5em Data}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The four \texttt{EuStockMarkets} time series can be plotted in a single panel (pane),
      \vskip1ex
        <<eustx_plot,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# plot in single panel
plot(EuStockMarkets, main="EuStockMarkets", 
     xlab="", ylab="", plot.type="single", 
     col=c("black", "red", "blue", "green"))
# add legend
legend(x=1992, y=8000, 
       legend=colnames(EuStockMarkets), 
       col=c("black", "red", "blue", "green"), 
       lty=1)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_plot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Distribution of \subsecname \hskip0.5em Returns}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{hist()} calculates and plots a histogram,
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      The function \texttt{density()} calculates a kernel estimate of the probability density,
      \vskip1ex
      The function \texttt{lines()} draws a line through specified points,
        \vspace{-1em}
        <<eustx_rets,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate DAX percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# mean and standard deviation of returns
c(mean(dax_rets), sd(dax_rets))
# plot histogram
hist(dax_rets, breaks=30, main="", 
     xlim=c(-0.04, 0.04), ylim=c(0, 60), 
     xlab="", ylab="", freq = FALSE)
# draw kernel density of histogram
lines(density(dax_rets), col='red', lwd=2)
# add density of normal distribution
curve(expr=dnorm(x, mean=mean(dax_rets), sd=sd(dax_rets)), 
      add=TRUE, type="l", lwd=2, col="blue")
title(main="Return distributions", line=0)  # add title
# add legend
legend("topright", inset=0.05, cex=0.8, title=NULL, 
       leg=c(colnames(EuStockMarkets)[1], "Normal"), 
       lwd=2, bg="white", col=c("red", "blue"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_rets-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Quantile-Quantile Plot}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \texttt{Q-Q} plot is a plot of points from two probability distributions with the same quantiles,
      \vskip1ex
      The function \texttt{qqnorm()} produces a normal Q-Q plot,
      \vskip1ex
      The function \texttt{qqline()} fits a line to the normal quantiles,
      \vskip1ex
      The \texttt{DAX} Q-Q plot shows that the \texttt{DAX} return distribution has fat tails,
        <<eustx_qq,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# create normal Q-Q plot
qqnorm(dax_rets, ylim=c(-0.04, 0.04), 
       xlab='Normal Quantiles', main='')
# fit a line to the normal quantiles
qqline(dax_rets, col='red', lwd=2)
plot_title <- paste(colnames(EuStockMarkets)[1], 
                  'Q-Q Plot')
title(main=plot_title, line=-1)  # add title
shapiro.test(dax_rets)  # Shapiro-Wilk test
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_qq-1}
      \vskip2ex
      The \emph{p}-value of the \emph{Shapiro-Wilk} test is very small, which shows that the \texttt{DAX} returns are not normal,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Boxplots}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{Box Plot} (box-and-whisker plot) is a graphical display of a distribution of values,
      \vskip1ex
      The \emph{box} represents the upper and lower quartiles, \\
      the vertical lines (whiskers) represent values beyond the quartiles, \\
      and open circles represent values beyond the nominal range (outliers),
      \vskip1ex
      The function \texttt{boxplot()} plots a box-and-whisker plot for a distribution of values,
      \vskip1ex
      \texttt{boxplot()} has two \texttt{methods}: one for \texttt{formula} objects (involving categorical variables), and another for \texttt{data frames},
      <<box_plots,echo=(-(1:2)),fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(1.5, 0.5, 0), mar=c(2.5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# boxplot method for formula
boxplot(formula=mpg ~ cyl, data=mtcars, 
        main="Mileage by number of cylinders", 
        xlab="Cylinders", ylab="Miles per gallon")

# calculate EuStockMarkets percentage returns
eu_rets <- diff(log(EuStockMarkets))
# boxplot method for data frame
boxplot(x=eu_rets)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/box_plots-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} is designed for managing \emph{irregular} time series and ordered objects of class \texttt{"zoo"},
      \vskip1ex
      The function \texttt{zoo()} creates a \texttt{zoo} object from a \texttt{numeric} vector or matrix, and an associated \emph{date-time} index,
      \vskip1ex
      The \texttt{zoo} index is a vector of \emph{date-time} objects, and can be from any \emph{date-time} class,
      \vskip1ex
      The \texttt{zoo} class can manage \emph{irregular} time series whose \emph{date-time} index isn't equally spaced,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2))>>=
set.seed(1121)  # initialize the random number generator
library(zoo)  # load package zoo
# create zoo time series
in_dex <- Sys.Date() + 0:3
zoo_series <- zoo(rnorm(length(in_dex)), 
               order.by=in_dex)
zoo_series
attributes(zoo_series)
class(zoo_series)  # class 'zoo'
tail(zoo_series, 3)  # get last few elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operations on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{coredata()} extracts the data contained in \texttt{zoo} object, and returns a vector or matrix,
      \vskip1ex
      The function \texttt{index()} extracts the time index of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{start()} and \texttt{end()} return the time index values of the first and last elements of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{cumsum()}, \texttt{cummax()}, and \texttt{cummin()} return cumulative sums, minima and maxima of a \texttt{zoo} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
coredata(zoo_series)  # extract coredata
index(zoo_series)  # extract time index
zoo_series[start(zoo_series)]  # first element
zoo_series[end(zoo_series)]  # last element
coredata(zoo_series) <- rep(1, 4)  # replace coredata
cumsum(zoo_series)  # cumulative sum
cummax(cumsum(zoo_series))
cummin(cumsum(zoo_series))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lag()} and \texttt{diff()} Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lag()} returns a lagged version of a time series, shifting the time index back by a given number of observations,
      \vskip1ex
      The function \texttt{diff()} returns the difference between a time series and its lagged version, 
      \vskip1ex
      For \texttt{zoo} objects, both these functions omit any \texttt{NA} values they may have produced,
    \column{0.6\textwidth}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
coredata(zoo_series) <- 1:4  # replace coredata
zoo_series
diff(zoo_series)  # diff with one day lag
lag(zoo_series, 2)  # two day lag
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting \texttt{zoo} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be plotted using the generic function \texttt{plot()}, which dispatches the \texttt{plot.zoo()} method,
      <<zoo_ts,echo=(-(1:2)),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # initialize the random number generator
library(zoo)  # load package zoo
# create index of daily dates
in_dex <- seq(from=as.Date("2012-07-14"), 
                  by="day", length.out=1000)
# create vector of data
zoo_data <- cumsum(rnorm(length(in_dex)))
# create zoo time series
zoo_series <- zoo(x=zoo_data, 
                  order.by=in_dex)
# plot using plot.zoo method
plot(zoo_series, xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Subsetting \texttt{zoo} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{zoo} time series can be subset in similar ways to \texttt{matrices} and \texttt{ts} time series, 
      \vskip1ex
      The function \texttt{window()} can also subset \texttt{zoo} time series objects, 
      \vskip1ex
      In addition, \texttt{zoo} time series can be subset using \texttt{Date} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(zoo)  # load package zoo
# subset zoo as matrix
zoo_series[459:463, 1]
# subset zoo using window()
window(zoo_series, 
       start=as.Date("2013-10-15"), 
       end=as.Date("2013-10-19"))
# subset zoo using Date object
zoo_series[as.Date("2013-10-15")]
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Sequential Joining \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be joined sequentially using \texttt{rbind},
      <<zoo_join_seq,echo=(-(1:2)),fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily date series of class 'Date'
in_dex1 <- seq(Sys.Date(), by="days", 
                   length.out=365)
# create zoo time series
zoo_series1 <- zoo(rnorm(length(in_dex1)), 
                 order.by=in_dex1)
# create another zoo time series
in_dex2 <- seq(Sys.Date()+350, by="days", 
                   length.out=365)
zoo_series2 <- zoo(rnorm(length(in_dex2)), 
                 order.by=in_dex2)
# rbind the two time series - ts1 supersedes ts2
zoo_series3 <- rbind(zoo_series1,
                 zoo_series2[index(zoo_series2) > end(zoo_series1)])
plot(cumsum(zoo_series3), xlab="", ylab="")
# add vertical lines at stitch point
abline(v=end(zoo_series1), col="blue", lty="dashed")
abline(v=start(zoo_series2), col="red", lty="dashed")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_join_seq-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Merging \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{zoo} time series can be combined concurrently by joining their columns using \texttt{merge()},
      \vskip1ex
      \texttt{merge()} is similar to \texttt{cbind()},
      \vskip1ex
      If the \texttt{all=TRUE} option is set, then \texttt{merge()} returns the union of their dates, otherwise it returns their intersection,
      \vskip1ex
      The \texttt{merge()} operation can produce \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
# create daily date series of class 'Date'
in_dex1 <- Sys.Date() + -3:1
# create zoo time series
zoo_series1 <- zoo(rnorm(length(in_dex1)), 
               order.by=in_dex1)
# create another zoo time series
in_dex2 <- Sys.Date() + -1:3
zoo_series2 <- zoo(rnorm(length(in_dex2)), 
               order.by=in_dex2)
merge(zoo_series1, zoo_series2)  # union of dates
# intersection of dates
merge(zoo_series1, zoo_series2, all=FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Managing \texttt{NA} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Operations on time series can produce \texttt{NA} values,
      \vskip1ex
      There are two dedicated functions for managing \texttt{NA} values in time series: 
      \begin{itemize}
        \item \texttt{na.omit()} removes observations containing \texttt{NA} values,
        \item \texttt{na.locf()} carries the last non-\texttt{NA} observation forward,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
# create zoo time series
zoo_series <- zoo(sample(4), 
                  order.by=(Sys.Date() + 0:3))
# add NA
zoo_series[3] <- NA
zoo_series

na.locf(zoo_series)  # replace NA's using locf

na.omit(zoo_series)  # remove NA's using omit
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Aggregating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{aggregate()} performs temporal aggregations of \texttt{zoo} objects,
      <<zoo_agg,echo=(-(1:6)),fig.show='hide'>>=
set.seed(1121)  # for reproducibility
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create zoo time series
in_dex <- Sys.Date() + 0:365
zoo_series <- zoo(rnorm(length(in_dex)), order.by=in_dex)
# create monthly dates
dates_agg <- as.Date(as.yearmon(index(zoo_series)))
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using locf
zoo_agg <- na.locf(zoo_agg)
# extract aggregated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and aggregated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Aggregated Prices", 
       leg=c("orig prices", "agg prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_agg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpolating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has two functions for replacing \texttt{NA} values using interpolation:
      \begin{itemize}
        \item \texttt{na.approx()} performs linear interpolation,
        \item \texttt{na.spline()} performs spline interpolation,
      \end{itemize}
      \vspace{-1em}
      <<zoo_interpol,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using linear interpolation
zoo_agg <- na.approx(zoo_agg)
# extract interpolated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Interpolated Prices", 
       leg=c("orig prices", "interpol prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_interpol-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Rolling Functions on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has several functions for rolling calculations:
      \begin{itemize}
        \item \texttt{rollapply()} applying function over a rolling (sliding) window,
        \item \texttt{rollmean()} calculate rolling means,
        \item \texttt{rollmedian()} calculate rolling median,
        \item \texttt{rollmax()} calculate rolling max,
      \end{itemize}
      \vspace{-1em}
      <<zoo_roll,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_mean <- rollapply(zoo_series, width=11, FUN=mean)
# merge with original zoo - union of dates
zoo_mean <- merge(zoo_series, zoo_mean)
# replace NA's using na.locf
zoo_mean <- na.locf(zoo_mean, fromLast=TRUE)
# extract mean zoo
zoo_mean <- zoo_mean[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_mean), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Mean Prices", 
       leg=c("orig prices", "mean prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_roll-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Time Series Objects Into \texttt{zoo}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The generic function \texttt{as.zoo()} coerces objects into \texttt{zoo} time series,
      \vskip1ex
      \texttt{as.zoo()} creates a \texttt{zoo} object with a \texttt{numeric} \emph{date-time} index, with \emph{date-time} encoded as a \emph{year-fraction},
      \vskip1ex
      The \emph{year-fraction} can be \emph{approximately} converted to a \texttt{Date} object by first calculating the number of days since the \texttt{epoch} (\texttt{1970}), and then coercing the \texttt{numeric} days using \texttt{as.Date()},
      \vskip1ex
      The function \texttt{date\_decimal()} from package \texttt{lubridate} converts \texttt{numeric} \emph{year-fraction} dates into \texttt{POSIXct} objects,
      \vskip1ex
      \texttt{date\_decimal()} provides a more accurate way of converting a \emph{year-fraction} index to \texttt{POSIXct},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:3))>>=
library(lubridate)  # load lubridate
library(zoo)  # load package zoo
# methods(as.zoo)  # many methods of coercing into zoo
class(EuStockMarkets)  # multiple ts object
# coerce mts object into zoo
zoo_series <- as.zoo(EuStockMarkets)
class(index(zoo_series))  # index is numeric
head(zoo_series, 3)
# approximately convert index into class 'Date'
index(zoo_series) <- 
  as.Date(365*(index(zoo_series)-1970))
head(zoo_series, 3)
# convert index into class 'POSIXct'
zoo_series <- as.zoo(EuStockMarkets)
index(zoo_series) <- date_decimal(index(zoo_series))
head(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing \texttt{zoo} Objects Into Class \texttt{ts}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The generic function \texttt{as.ts()} from package \texttt{stats} coerces time series objects (including \texttt{zoo}) into \texttt{ts} time series,
      \vskip1ex
      \texttt{as.ts()} creates a \texttt{ts} object with a \texttt{frequency=1}, implying a \emph{"day"} time unit, instead of a \emph{"year"} time unit suitable for \emph{year-fraction} dates,
      \vskip1ex
      A \texttt{ts} time series can be created from a \texttt{zoo} using the function \texttt{ts()}, after extracting the data and date attributes from \texttt{zoo},
      \vskip1ex
      The function \texttt{decimal\_date()} from package \texttt{lubridate} converts \texttt{POSIXct} objects into \texttt{numeric} \emph{year-fraction} dates,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:9))>>=
library(lubridate)  # load lubridate
library(zoo)  # load package zoo
set.seed(1121)  # initialize the random number generator
# create index of daily dates
in_dex <- seq(from=as.Date("2012-07-14"), 
                  by="day", length.out=1000)
# create vector of data
zoo_data <- cumsum(rnorm(length(in_dex)))
# create zoo time series
zoo_series <- zoo(x=zoo_data, 
                  order.by=in_dex)
head(zoo_series, 3)  # zoo object
# as.ts() creates ts object with frequency=1
ts_series <- as.ts(zoo_series)
tsp(ts_series)  # frequency=1
# get start and end dates of zoo_series
start_date <- decimal_date(start(zoo_series))
end_date <- decimal_date(end(zoo_series))
# calculate frequency of zoo_series
fre_quency <- length(zoo_series)/(end_date-start_date)
da_ta <- coredata(zoo_series)  # extract data from zoo_series
# create ts object using ts()
ts_series <- ts(data=da_ta, start=start_date, 
                frequency=fre_quency)
# display start of time series
window(ts_series, start=start(ts_series), 
       end=start(ts_series)+4/365)
head(time(ts_series))  # display index dates
head(as.Date(date_decimal(coredata(time(ts_series)))))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Irregular Time Series Into Class \texttt{ts}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Irregular time series cannot be properly coerced into \texttt{ts} time series without modifying their index,
      \vskip1ex
      The function \texttt{as.ts()} creates \texttt{NA} values when it coerces irregular time series into a \texttt{ts} time series,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2))>>=
library(lubridate)  # load lubridate
library(zoo)  # load package zoo
# create weekday logical vector
week_days <- weekdays(index(zoo_series))
is_weekday <- !((week_days == "Saturday") | 
  (week_days == "Sunday"))
# remove weekends from zoo time series
zoo_series <- zoo_series[is_weekday, ]
head(zoo_series, 7)  # zoo object
# as.ts() creates NA values
ts_series <- as.ts(zoo_series)
head(ts_series, 7)
# create vector of regular dates, including weekends
in_dex <- seq(from=start(zoo_series), 
                  by="day", 
                  length.out=length(zoo_series))
index(zoo_series) <- in_dex
ts_series <- as.ts(zoo_series)
head(ts_series, 7)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{xts} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{xts} defines time series objects of class \texttt{"xts"},
      \begin{itemize}
        \item Class \texttt{"xts"} is an extension of the \texttt{zoo} class (derived from \texttt{zoo}),
        \item \texttt{"xts"} is the most widely accepted time series class,
        \item \texttt{"xts"} is designed for high-frequency and \emph{OHLC} data,
        \item \texttt{"xts"} contains many convenient functions for plotting, calculating rolling max, min, etc.
      \end{itemize}
      The function \texttt{xts()} creates a \texttt{xts} object from a \texttt{numeric} vector or matrix, and an associated \emph{date-time} index,
      \vskip1ex
      The \texttt{xts} index is a vector of \emph{date-time} objects, and can be from any \emph{date-time} class,
      \vskip1ex
      The \texttt{xts} class can manage \emph{irregular} time series whose \emph{date-time} index isn't equally spaced,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
set.seed(1121)  # initialize the random number generator
library(xts)  # load package xts
# create xts time series
in_dex <- Sys.Date() + 0:3
xts_series <- xts(rnorm(length(in_dex)), 
               order.by=in_dex)
names(xts_series) <- "random"
xts_series
tail(xts_series, 3)  # get last few elements
first(xts_series)  # get first element
last(xts_series)  # get last element
class(xts_series)  # class 'xts'
attributes(xts_series)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing \texttt{zoo} Objects Into Class \texttt{xts}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{as.xts()} coerces time series (including \texttt{zoo}) into \texttt{xts} time series,
      \vskip1ex
      \texttt{as.xts()} preserves the \emph{index} attributes of the original time series,
      \vskip1ex
      \texttt{xts} can be plotted using the generic function \texttt{plot()}, which dispatches the \texttt{plot.xts()} method,
      <<xts_plot,echo=(-(1:2)),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
load(file="C:/Develop/data/zoo_data.RData")
library(xts)  # load package xts
# as.xts() creates xts from zoo
xts_stx <- as.xts(zoo_stx_adj)
dim(xts_stx)
head(xts_stx[, 1:4], 4)
# plot using plot.xts method
plot(xts_stx[, "AdjClose"], xlab="", ylab="", main="")
title(main="MSFT Prices")  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/xts_plot-2}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Subsetting \texttt{xts} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{xts} time series can be subset in similar ways to \texttt{zoo}, 
      \vskip1ex
      In addition, \texttt{xts} time series can be subset using date strings, or date range strings, for example: \texttt{["2013-10-15/2014-01-10"]}, 
      \vskip1ex
      \texttt{xts} time series can be subset by year, week, days, or even seconds,
      \vskip1ex
      If only the date is subset, then a comma \texttt{","} after the date range isn't necessary,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# subset xts using a date range string
xts_sub <- xts_stx["2013-10-15/2014-01-10", 1:4]
first(xts_sub)
last(xts_sub)
# subset Nov 2014 using a date string
xts_sub <- xts_stx["2014-11", 1:4]
first(xts_sub)
last(xts_sub)
# subset all data after Nov 2014
xts_sub <- xts_stx["2014-11/", 1:4]
first(xts_sub)
last(xts_sub)
# comma after date range not necessary
identical(xts_stx["2014-11", ], xts_stx["2014-11"])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Subsetting Recurring \texttt{xts} Time Intervals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{recurring time interval} is the same time interval every day,
      \vskip1ex
      \texttt{xts} can be subset on recurring time intervals using the \texttt{"T"} notation,
      \vskip1ex
      For example, to subset the time interval from 9:30AM to 4:00PM every day: \texttt{["T09:30:00/T16:00:00"]}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# vector of 1-minute times (ticks)
min_ticks <- seq.POSIXt(
  from=as.POSIXct("2015-04-14", tz="America/New_York"), 
  to=as.POSIXct("2015-04-16"), 
  by="min")
# xts of 1-minute times (ticks)
xts_series <- xts(rnorm(length(min_ticks)), 
                     order.by=min_ticks)
# subset recurring time interval using "T notation",
xts_series <- xts_series["T09:30:00/T16:00:00"]
first(xts_series["2015-04-15"])  # first element of day
last(xts_series["2015-04-15"])  # last element of day
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Properties of \texttt{xts} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{xts} series always have a \texttt{dim} attribute, unlike \texttt{zoo},
      \vskip1ex
      \texttt{zoo} series with multiple columns have a \texttt{dim} attribute, and are therefore matrices,
      \vskip1ex
      But \texttt{zoo} with a single column don't, and are therefore vectors not matrices,
      \vskip1ex
      When a \texttt{zoo} is subset to a single column, the \texttt{dim} attribute is dropped, which can create errors,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
str(xts_stx)  # display structure of xts
# subsetting zoo to single column drops dim attribute
dim(zoo_stx_adj)
dim(zoo_stx_adj[, 1])
# zoo with single column are vectors not matrices
c(is.matrix(zoo_stx_adj), is.matrix(zoo_stx_adj[, 1]))
# xts always have a dim attribute
rbind(base=dim(xts_stx), subs=dim(xts_stx[, 1]))
c(is.matrix(xts_stx), is.matrix(xts_stx[, 1]))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{lag} and \texttt{diff} Operations on \texttt{xts} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{lag} and \texttt{diff} operations on \texttt{xts} series differ from those on \texttt{zoo},
      \vskip1ex
      \texttt{lag} and \texttt{diff} operations on \texttt{zoo} shorten the series by one row, 
      \vskip1ex
      \texttt{lag} and \texttt{diff} operations on \texttt{xts} by default retain the same number of rows, but substitute \texttt{NAs} for missing data, 
      \vskip1ex
      By default, the \texttt{lag} operation on \texttt{xts} replaces the values at time \emph{"t"} with the values at time \emph{"t-1"} (negative lags replace values in the opposite direction), 
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# lag of zoo shortens it by one row
rbind(base=dim(zoo_stx_adj), lag=dim(lag(zoo_stx_adj)))
# lag of xts doesn't shorten it
rbind(base=dim(xts_stx), lag=dim(lag(xts_stx)))
# lag of zoo is in opposite direction from xts
head(lag(zoo_stx_adj), 4)
head(lag(xts_stx), 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Extracting \protect\emph{Endpoints} of \texttt{xts} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{endpoints()} extracts the indices of the last observations in each period of time of an \texttt{xts} series,
      \vskip1ex
      For example:\\ \-\ \texttt{endpoints(x, on="months")}\\
      extracts the indices of the last observations in each month,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# extract indices of the last observations in each month
end_points <- endpoints(xts_stx, on='months')
head(end_points)
# extract the last observations in each month
head(xts_stx[end_points, ])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Applying Functions Over \protect\emph{Endpoints} of \texttt{xts}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \emph{endpoints} of an \texttt{xts} form a vector of non-overlapping date-time intervals,
      \vskip1ex
      The function \texttt{period.apply()} performs an \emph{aggregation} by applying a function over a vector of \emph{endpoints},
      \vskip1ex
      The package \texttt{xts} also has several specialized and optimized (fast) functions for aggregating data over \emph{endpoints}:
      \begin{itemize}
        \item \texttt{period.sum()} calculate the sum for each period,
        \item \texttt{period.max()} calculate the maximum for each period,
        \item \texttt{period.min()} calculate the minimum for each period,
        \item \texttt{period.prod()} calculate the product for each period,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# apply "mean" over end_points
period_mean <- period.apply(xts_stx[, "AdjClose"], 
                     INDEX=end_points, 
                     FUN=mean)
head(period_mean)
period_sum <- period.sum(xts_stx[, "AdjClose"], 
                     INDEX=end_points)
head(period_sum)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Applying Functions to \texttt{xts} Over Calendar Periods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The package \texttt{xts} has convenience wrapper functions for \texttt{period.apply()}, that apply functions over calendar periods:
      \begin{itemize}
        \item \texttt{apply.daily()} applies functions over daily periods,
        \item \texttt{apply.weekly()} applies functions over weekly periods,
        \item \texttt{apply.monthly()} applies functions over monthly periods,
        \item \texttt{apply.quarterly()} applies functions over quarterly periods,
        \item \texttt{apply.yearly()} applies functions over yearly periods,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# apply "mean" over monthly periods
period_mean <- apply.monthly(xts_stx[, "AdjClose"], 
                     FUN=mean)
head(period_mean)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Converting \texttt{xts} to Lower Periodicity}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{to.period()} converts a time series to a lower periodicity (for example from hourly to daily periodicity),
      \vskip1ex
      \texttt{to.period()} returns a time series of open, high, low, and close values (\emph{OHLC}) for the lower period,
      \vskip1ex
      \texttt{to.period()} converts both univariate and \emph{OHLC} time series to a lower periodicity,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
library(xts)  # load package xts
# lower the periodicity to months
xts_monthly <- to.period(x=xts_stx[, "AdjClose"], 
                         period="months", name="MSFT")
# convert colnames to standard OHLC format
colnames(xts_monthly)
colnames(xts_monthly) <- sapply(
  strsplit(colnames(xts_monthly), split=".", fixed=TRUE), 
  function(na_me) na_me[-1]
  )  # end sapply
head(xts_monthly, 3)
# lower the periodicity to years
xts_yearly <- to.period(x=xts_monthly, 
                         period="years", name="MSFT")
colnames(xts_yearly) <- sapply(
  strsplit(colnames(xts_yearly), split=".", fixed=TRUE), 
  function(na_me) na_me[-1]
  )  # end sapply
head(xts_yearly)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting \protect\emph{OHLC} Time Series Using \texttt{xts}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The method (function) \texttt{plot.xts()} can plot \emph{OHLC} time series of class \texttt{xts},
      <<xts_plot_OHLC,echo=(-(1:3)),eval=FALSE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
load(file="C:/Develop/data/zoo_data.RData")
library(xts)  # load package xts
# as.xts() creates xts from zoo
xts_stx <- as.xts(zoo_stx_adj)
# subset xts using a date
xts_sub <- xts_stx["2014-11", 1:4]

# plot OHLC using plot.xts method
plot(xts_sub, type="candles", main="")
title(main="MSFT Prices")  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/xts_plot_OHLC-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Series Classes in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} and other packages contain a number of different time series classes:
      \begin{itemize}
        \item Class \texttt{"ts"} from base package \texttt{stats}:\\
        native time series class in \texttt{R}, but allows only \emph{regular} (equally spaced) date-time index,\\
        not suitable for sophisticated financial applications,
        \item Class \texttt{"zoo"}: allows \emph{irregular} date-time index,\\
        the \texttt{zoo} index can be from any \emph{date-time} class,
        \item Class \texttt{"xts"} extension of \texttt{zoo} class: most widely accepted time series class,\\
        designed for high-frequency and \emph{OHLC} data,\\
        contains convenient functions for plotting, calculating rolling max, min, etc.
        \item Class \texttt{"timeSeries"} from the \emph{Rmetrics} suite,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
load(file="C:/Develop/data/zoo_data.RData")
ts_stx <- as.ts(zoo_stx)
class(ts_stx)
tail(ts_stx[, 1:4])
library(xts)
xts_stx <- as.xts(zoo_stx)
class(xts_stx)
tail(xts_stx[, 1:4])
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Package \texttt{tseries} for Time Series Analysis}


%%%%%%%%%%%%%%%
\subsection{Package \texttt{tseries} for Time Series Analysis}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{tseries} contains functions for time series analysis and computational finance, such as:
      \begin{itemize}
        \item downloading historical data,
        \item plotting time series,
        \item calculating risk and performance measures,
        \item statistical \emph{hypothesis testing},
        \item fitting models to time series,
        \item portfolio optimization, 
      \end{itemize}
      Package \texttt{tseries} accepts time series objects of class \texttt{"ts"} and \texttt{"zoo"}, and also has its own class \texttt{"irts"} for irregular spaced time-series objects,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
# get documentation for package "tseries"
packageDescription("tseries")  # get short description

help(package="tseries")  # load help page

library(tseries)  # load package "tseries"

data(package="tseries")  # list all datasets in "tseries"

ls("package:tseries")  # list all objects in "tseries"

detach("package:tseries")  # remove tseries from search path
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading Data From \protect\emph{Yahoo} Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{get.hist.quote()} downloads historical data from online sources,
      \vskip1ex
      The \texttt{"provider"} argument determines the \emph{online source}, and its default value is \texttt{c("yahoo", "oanda")},
      \vskip1ex
      The \texttt{"retclass"} argument determines the \emph{return class}, and its default value is \texttt{c("zoo", "its", "ts")},
      \vskip1ex
      The \texttt{"quote"} argument determines the data fields, and its default value is \texttt{c("Open", "High", "Low", "Close")},
      \vskip1ex
      The \texttt{"AdjClose"} data field is for the \emph{close} price adjusted for stock splits and dividends, 
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE>>=
library(tseries)  # load package tseries
# download MSFT data
zoo_stx <- suppressWarnings(
  get.hist.quote(
    instrument="MSFT", 
    start=Sys.Date()-3*365, 
    end=Sys.Date(), 
    quote=c("Open","High","Low","Close",
            "AdjClose","Volume"),
    origin="1970-01-01")
)  # end suppressWarnings
      @
      \vspace{-2em}
      <<echo=(-1),eval=TRUE>>=
load(file="C:/Develop/data/zoo_data.RData")
class(zoo_stx)
dim(zoo_stx)
head(zoo_stx, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Adjusting \protect\emph{OHLC} Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Stock prices experience jumps due to stock splits and dividends,
      \vskip1ex
      \emph{Adjusted} stock prices are stock prices that have been adjusted so they don't have jumps,
      \vskip1ex
      \emph{OHLC} data can be adjusted for stock splits and dividends, 
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2)),eval=TRUE>>=
library(tseries)  # load package tseries
load(file="C:/Develop/data/zoo_data.RData")
# create price adjustment vector
adj_close <- zoo_stx[, "AdjClose"] - zoo_stx[, "Close"]
head(adj_close, 5)
tail(adj_close, 5)
# adjust OHLC prices
zoo_stx_adj <- zoo_stx
zoo_stx_adj[, c("Open","High","Low","Close")] <- 
  zoo_stx[, c("Open","High","Low","Close")] + adj_close
head(zoo_stx_adj)
tail(zoo_stx_adj)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading \texttt{ts} Data From \protect\emph{Yahoo} Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{get.hist.quote()} can download daily historical data in \texttt{ts} format using the argument \texttt{"retclass="ts"},
      \vskip1ex
      \texttt{get.hist.quote()} returns a \texttt{ts} object with a \texttt{frequency=1}, implying a \emph{"day"} time unit, instead of a \emph{"year"} time unit suitable for \emph{year-fraction} dates,
      \vskip1ex
      The \texttt{ts} contains \texttt{NA} values for weekends and holidays,
      <<echo=(-1),eval=FALSE>>=
library(tseries)  # load package tseries
# download MSFT data in ts format
ts_stx <- suppressWarnings(
  get.hist.quote(
    instrument="MSFT", 
    start=Sys.Date()-3*365, 
    end=Sys.Date(), 
    retclass="ts",
    quote=c("Open","High","Low","Close",
            "AdjClose","Volume"),
    origin="1970-01-01")
)  # end suppressWarnings
      @
    \column{0.6\textwidth}
      \vspace{-2em}
      <<echo=(-1),eval=TRUE>>=
load(file="C:/Develop/data/zoo_data.RData")
# create price adjustment vector
adj_close <- ts_stx[, "AdjClose"] - 
  ts_stx[, "Close"]
# adjust OHLC prices
ts_stx_adj <- ts_stx
ts_stx_adj[, c("Open","High","Low","Close")] <- 
  ts_stx[, c("Open","High","Low","Close")] + adj_close
# inspect the data
tsp(ts_stx_adj)  # frequency=1
head(time(ts_stx_adj))
head(ts_stx_adj)
tail(ts_stx_adj)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading Data From \protect\emph{Oanda} Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Oanda} is a foreign exchange broker that also provides free historical currency rates data,
      \vskip1ex
      The function \texttt{get.hist.quote()} downloads historical data from online sources,
      \vskip1ex
      The \texttt{"provider"} argument determines the \emph{online source}, and its default value is \texttt{c("yahoo", "oanda")},
      \vskip1ex
      The \texttt{"retclass"} argument determines the \emph{return class}, and its default value is \texttt{c("zoo", "its", "ts")},
      \vskip1ex
      The \texttt{"quote"} argument determines the data fields, and its default value is \texttt{c("Open", "High", "Low", "Close")},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE>>=
library(tseries)  # load package tseries
# download EUR/USD data
zoo_eurusd <- suppressWarnings(
  get.hist.quote(
    instrument="EUR/USD", 
    provider="oanda",
    start=Sys.Date()-3*365, 
    end=Sys.Date(), 
    origin="1970-01-01")
)  # end suppressWarnings
# bind and scrub data
zoo_stxeur <- merge(zoo_eurusd, 
                     zoo_stx[, "AdjClose"])
colnames(zoo_stxeur) <- c("EURUSD", "MSFT")
zoo_stxeur <- 
  zoo_stxeur[complete.cases(zoo_stxeur),]
save(zoo_stx, zoo_stx_adj, 
     ts_stx, ts_stx_adj, 
     zoo_eurusd, zoo_stxeur, 
     file="C:/Develop/data/zoo_data.RData")
      @
      \vspace{-2em}
      <<echo=(-1),eval=TRUE>>=
load(file="C:/Develop/data/zoo_data.RData")
# inspect the data
class(zoo_eurusd)
tail(zoo_eurusd, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting \protect\emph{OHLC} Time Series Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{plotOHLC()} from package \texttt{tseries} plots \emph{OHLC} time series, 
      <<tseries_OHLC,echo=(-(1:2)),eval=FALSE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
load(file="C:/Develop/data/zoo_data.RData")
# get start and end dates
in_dex <- time(ts_stx_adj)
e_nd <- in_dex[length(in_dex)]
st_art <- round((4*e_nd + in_dex[1])/5)
# plot using plotOHLC
plotOHLC(window(ts_stx_adj, 
                start=st_art, 
                end=e_nd)[, 1:4], 
         xlab="", ylab="")
title(main="MSFT OHLC Prices")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/tseries_OHLC-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Two Time Series Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{seqplot.ts()} from package \texttt{tseries} plots \emph{OHLC} time series, 
      The package \texttt{tseries} contains functions for plotting time series:
      \begin{itemize}
        \item \texttt{seqplot.ts()} for plotting two time series in same panel, 
        \item \texttt{plotOHLC()} for plotting \emph{OHLC} time series, 
      \end{itemize}
      \vspace{-1em}
      <<tseries_intro,echo=(-(1:2)),eval=FALSE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
load(file="C:/Develop/data/zoo_data.RData")
# plot using plot.zoo method
seqplot.ts(zoo_stx[, "AdjClose"], xlab="", ylab="")
title(main="MSFT AdjClose Prices", line=-1)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/tseries_intro-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Two Time Series With Two \texttt{"y"} axes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{par()} sets graphical parameters used for plotting, and invisibly returns existing parameters as a named list,
      \vskip1ex
      The function \texttt{axis()} plots an axis to the current plot,
      \vskip1ex
      The function \texttt{lines()} plots a line to the current plot,
      <<zoo_plot_2y,echo=(-(1:2)),eval=FALSE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
load(file="C:/Develop/data/zoo_data.RData")
### plot with two "y" axes
par(las=1)  # set text printing to "horizontal"
# plot first ts
plot(zoo_stxeur[, 1], xlab=NA, ylab=NA)
# set range of "y" coordinates for second axis
par(usr=c(par("usr")[1:2], range(zoo_stxeur[,2])))
lines(zoo_stxeur[, 2], col="red")  # second plot
axis(side=4, col="red")  # second "y" axis on right
# print axis labels
mtext(colnames(zoo_stxeur)[1], side=2, padj=-6, line=-4)
mtext(colnames(zoo_stxeur)[2], col="red", side=4, padj=-2, line=-3)
title(main="EUR and MSFT")  # add title
# add legend without box
legend("bottomright", legend=colnames(zoo_stxeur), bg="white", 
       lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")

##########

# slightly different method using par(new=TRUE)
# par(las=1)  # set text printing to "horizontal"
# plot(zoo_stxeur[, 1], xlab=NA, ylab=NA)
# par(new=TRUE)  # allow new plot on same chart
# plot(zoo_stxeur[, 2], xlab=NA, ylab=NA, yaxt="n", col="red")
# axis(side=4, col="red")  # second "y" axis on right
# mtext(colnames(zoo_stxeur)[1], side=2, padj=-6, line=-4)
# mtext(colnames(zoo_stxeur)[2], col="red", side=4, padj=-2, line=-3)
# title(main="EUR and MSFT", line=-1)  # add title
# legend("bottomright", legend=colnames(zoo_stxeur), 
#        lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")

##########

# "x" axis with monthly ticks - doesn't work
# plot first ts wthout "x" axis
# plot(zoo_stxeur[, 1], xaxt="n", xlab=NA, ylab=NA)
# # add "x" axis with monthly ticks
# month.ticks <- unique(as.yearmon(index(zoo_eurusd)))
# axis(side=1, at=month.ticks, labels=format(month.ticks, "%b-%y"), tcl=-0.7)

      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_plot_2y-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Risk and Performance Estimation Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{tseries} contains functions for calculating risk and performance:
      \begin{itemize}
        \item \texttt{maxdrawdown()} for calculating the maximum drawdown, 
        \item \texttt{sharpe()} for calculating the \emph{Sharpe} ratio (defined as the excess return divided by the standard deviation), 
        \item \texttt{sterling()} for calculating the \emph{Sterling} ratio (defined as the return divided by the maximum drawdown), 
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2)),eval=TRUE>>=
library(tseries)  # load package tseries
load(file="C:/Develop/data/zoo_data.RData")
# calculate maximum drawdown
maxdrawdown(na.remove(ts_stx[, "AdjClose"]))
# calculate Sharpe ratio
sharpe(na.remove(ts_stx[, "AdjClose"]))
# calculate Sterling ratio
sterling(na.remove(ts_stx[, "AdjClose"]))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Hypothesis Testing Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{tseries} contains functions for testing statistical hypothesis on time series:
      \begin{itemize}
        \item \texttt{jarque.bera.test()} \emph{Jarque-Bera} test for normality of distribution of returns,
        \item \texttt{adf.test()} \emph{Augmented Dickey-Fuller} test for existence of unit roots,
        \item \texttt{pp.test()} \emph{Phillips-Perron} test for existence of unit roots,
        \item \texttt{kpss.test()} \emph{KPSS} test for stationarity,
        \item \texttt{po.test()} \emph{Phillips-Ouliaris} test for cointegration,
        \item \texttt{bds.test()} \emph{BDS} test for randomness,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE,fig.show='hide'>>=
library(tseries)  # load package tseries
zoo_stx <- suppressWarnings(  # load MSFT data
  get.hist.quote(instrument="MSFT", 
                 start=Sys.Date()-365, 
                 end=Sys.Date(), 
                 origin="1970-01-01")
)  # end suppressWarnings
class(zoo_stx)
dim(zoo_stx)
tail(zoo_stx, 4)

# calculate Sharpe ratio
sharpe(zoo_stx[, "Close"], r=0.01)
# add title
plot(zoo_stx[, "Close"], xlab="", ylab="")
title(main="MSFT Close Prices", line=-1)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fitting Time Series Models Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{tseries} contains functions for fitting models to time series:
      \begin{itemize}
        \item \texttt{garch()} for fitting \texttt{GARCH} volatility models, 
        \item \texttt{arma()} for fitting \texttt{ARMA} models, 
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE,fig.show='hide'>>=
library(tseries)  # load package tseries
zoo_stx <- suppressWarnings(  # load MSFT data
  get.hist.quote(instrument="MSFT", 
                 start=Sys.Date()-365, 
                 end=Sys.Date(), 
                 origin="1970-01-01")
)  # end suppressWarnings
class(zoo_stx)
dim(zoo_stx)
tail(zoo_stx, 4)

# calculate Sharpe ratio
sharpe(zoo_stx[, "Close"], r=0.01)
# add title
plot(zoo_stx[, "Close"], xlab="", ylab="")
title(main="MSFT Close Prices", line=-1)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Portfolio Optimization Using \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{tseries} contains functions for miscellaneous functions:
      \vskip1ex
      \texttt{portfolio.optim()} for calculating mean-variance efficient portfolios, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1),eval=FALSE,fig.show='hide'>>=
library(tseries)  # load package tseries
zoo_stx <- suppressWarnings(  # load MSFT data
  get.hist.quote(instrument="MSFT", 
                 start=Sys.Date()-365, 
                 end=Sys.Date(), 
                 origin="1970-01-01")
)  # end suppressWarnings
class(zoo_stx)
dim(zoo_stx)
tail(zoo_stx, 4)

# calculate Sharpe ratio
sharpe(zoo_stx[, "Close"], r=0.01)
# add title
plot(zoo_stx[, "Close"], xlab="", ylab="")
title(main="MSFT Close Prices", line=-1)
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
