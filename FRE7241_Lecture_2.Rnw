% FRE7241_Lecture_2

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE7241 Lecture\#2]{FRE7241 Algorithmic Portfolio Management}
\subtitle{Lecture\#2, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@poly.edu}
\date{November 11, 2014}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Plotting With the \texttt{graphics} Package}


%%%%%%%%%%%%%%%
\subsection{Plotting in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plotting functions:
      \vskip1ex
      \texttt{x11()} opens a \texttt{Windows} graphics device,
      \vskip1ex
      \texttt{plot()} creates a generic plot,
      \vskip1ex
      \texttt{lines()} adds lines to a plot,
      \vskip1ex
      \texttt{title()} adds a title to a plot,
      \vskip1ex
      \texttt{legend()} adds a legend to a plot,
        <<sincosplot,fig.show='hide'>>=
x_var <- seq(-2*pi, 2*pi, len=100)  # x values

# open Windows graphics device
x11(width=11, height=7, title="simple plot")

# plot a sine function using basic line plot
plot(x=x_var, y=sin(x_var), xlab="x-val", 
     ylab="y-val", type='l', lwd=2, col="red")
# add a cosine function
lines(x=x_var, y=cos(x_var), lwd=2, col="blue")
# add title
title(main="sine and cosine functions", line=0.1)
# add legend
legend(x="topright", legend=c("sine", "cosine"),
       title="legend", inset=0.1, cex=1.0, bg="white",
       lwd=2, lty=c(1, 1), col=c("red", "blue"))
graphics.off()  # close all graphics devices
      @
    \column{0.5\textwidth}
    \vspace{-3em}
    \includegraphics[width=0.5\paperwidth,valign=t]{figure/sincosplot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Mathematical Functions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has dedicated functions for plotting mathematical functions,
      \vskip1ex
      The function \texttt{curve()} plots a function given by its name,
        <<funplot,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# plot a Normal probability distribution
curve(expr=dnorm, type="l", xlim=c(-3, 3), 
      xlab="", ylab="", lwd=2, col="blue")
# add shifted Normal probability distribution
curve(expr=dnorm(x, mean=1), add=TRUE, 
      type="l", lwd=2, col="red")

# add title
title(main="Normal probability distribution functions", 
      line=0.1)
# add legend
legend(x="topright", legend=c("Normal", "shifted"),
       title="legend", inset=0.05, cex=0.8, bg="white",
       lwd=2, lty=c(1, 1), col=c("blue", "red"))
      @
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth,valign=t]{figure/funplot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Barplots in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{rpois()} produces random numbers from the Poisson distribution,
      \vskip1ex
      The function \texttt{table()} calculates the frequency distribution of categorical data,
      \vskip1ex
      The function \texttt{truehist()} (from package \texttt{MASS}) plots histograms,
      \vspace{-1em}
        <<poisbarplot,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 4, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
pois_vector <- rpois(100, 4)  # Poisson numbers
# calculate contingency table
pois_table <- table(pois_vector)
pois_table <- pois_table/sum(pois_table)
pois_table

library(MASS)  # create histogram of Poisson variables
truehist(pois_vector, nbins="FD", col="blue", xlab="No. of events", 
         ylab="Frequency of events", main="Poisson histogram")
x_var <- 0:max(pois_vector)  # add Poisson density
lines(x=x_var, y=dpois(x_var, lambda=4), lwd=4, col="red")
# add legend
legend(x="topright", legend="Poisson density", title="", inset=0.05, 
       cex=0.8, bg="white", lwd=4, lty=1, col="red")
      @
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth,valign=t]{figure/poisbarplot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Graphical Parameters}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{par()} sets graphical parameters used for plotting, and invisibly returns existing parameters as a named list,
        <<par_ams,fig.show='hide'>>=
graph_params <- par()  # get existing parameters
par("mar")  # get plot margins
par(mar=c(2, 1, 2, 1))  # set plot margins
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 1, 0))  # set title and label margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(las=1)  # set axis labels to horizontal
par(ask=TRUE)  # pause, ask before plotting
par(mfrow=c(2, 2))  # plot on 2x2 grid by rows
for (i in 1:4) {  # plot 4 panels
  barplot(sample(1:6), main=paste("panel", i), 
          col=rainbow(6), border=NA, axes=FALSE)
  box()
}
par(ask=FALSE)  # restore automatic plotting
par(new=TRUE)  # allow new plot on same chart
par(graph_params)  # restore original parameters
      @
    \column{0.5\textwidth}
      \vspace{-3em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/par_ams-1}
      \vspace{-3em}
      Some graphical parameters:
      \begin{itemize}
        \item \texttt{cex} set graphic scales,
        \item \texttt{mar} \& \texttt{oma} set plot margins,
        \item \texttt{mgp} set title and label margins,
        \item \texttt{las} set orientation of axis labels,
        \item \texttt{mfcol} \& \texttt{mfrow} set number of plot panels,
      \end{itemize}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Basic Line Plot}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{graphics} package is one of the base packages in \texttt{R}, and offers a number of plotting capabilities,
      \vskip1ex
      The function \texttt{as.Date()} converts a character string into a date object,
      \vskip1ex
      \texttt{R} stores \texttt{Date} objects as the number of days since January 1, 1970,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
Sys.Date()  # get today's date
date_time <- as.Date("2013-06-15")  # "%Y-%m-%d" or "%Y/%m/%d"
date_time
class(date_time)
as.Date("06-15-2013", "%m-%d-%Y")  # specify format
date_time + 20  # add 20 days
unclass(date_time)  # get internal integer representation
some.date <- as.Date("11/22/2013", "%m/%d/%Y")
some.date
# difference between dates
difftime(some.date, date_time, units="weeks")
weekdays(date_time)  # get day of the week
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting a Scatterplot}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{graphics} package is one of the base packages in \texttt{R}, and offers a number of plotting capabilities,
      \vskip1ex
        <<scatter_plot,echo=2:30,fig.show='hide'>>=
par(mar=c(5, 3, 1, 1), oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
attach(mtcars)  # add mtcars to search path
# specify model of horsepower vs miles per gallon
reg_formula <- mpg ~ hp
# plot scatterplot horsepower vs miles per gallon
plot(reg_formula, 
     main="miles per gallon vs horsepower")
# add labels using wordcloud, to prevent label overlaps
library(wordcloud)
textplot(x=mpg, y=hp, words=rownames(mtcars))

# don't forget to detach!!!
detach(mtcars)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/scatter_plot-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Plotting Using Package \texttt{ggplot2}}


%%%%%%%%%%%%%%%
\subsection{\texttt{ggplot2} Package for Plotting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{ggplot2} is a very popular \texttt{R} package for advanced plotting,
      \vskip1ex
      In the \texttt{ggplot2} framework a plot object is created by combining the outputs of several plotting functions using the "\texttt{+}" operator,
      \vskip1ex
      The function \texttt{ggplot()} defines the plot data and creates a plot template,
      \vskip1ex
      The function \texttt{aes()} specifies the plot "\emph{aesthetics}", which are mappings between data elements (rows, columns) and plot elements (points, lines),
      \vskip1ex
      \texttt{geom\_point()} adds plot points,
      \vskip1ex
      \texttt{geom\_line()} adds plot lines,
      \vskip1ex
      The function \texttt{theme()} customizes plot objects,
      \vskip1ex
      Simply calling the plot object renders the plot,
      \vskip1ex
      \texttt{ggplot2} is designed for plotting data formatted as \texttt{data frames},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<ggplot_basic1,echo=4:30,fig.width=5,fig.height=4,fig.show='hide'>>=
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(scales)  # load scales
my_ggplot <- ggplot(  # specify data and aesthetics
  data=mtcars, mapping=aes(x=hp, y=mpg)) + 
  geom_point() +  # plot points
  ggtitle("basic scatterplot") +  # add title
  theme(  # customize plot object
        plot.title=element_text(vjust=-2.0), 
        plot.background=element_blank()
  )  # end theme
my_ggplot  # render the plot
      @
      \vspace{-2em}
      \hspace*{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ggplot_basic1-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting \texttt{zoo} Time Series Using \texttt{autoplot()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{autoplot()} is a convenience wrapper for \texttt{ggplot2} functions, designed to plot \texttt{zoo} time series,
      \vspace{-1em}
      <<ggplot_zoo1,echo=5:30,fig.width=5,fig.height=6,fig.show='hide'>>=
library(ggplot2)  # load ggplot2
library(scales)  # load scales
library(gridExtra)  # load gridExtra
# coerce mts object into zoo
zoo_series <- as.zoo(EuStockMarkets)
# create ggplot2 theme object
auto_theme <- theme(
  legend.position="none", 
  plot.title=element_text(vjust=-2.0), 
  plot.margin=unit(c(-0.0,0.0,-0.5,0.0),"cm"), 
#  axis.text.y=element_blank(),
  plot.background=element_blank()
  )  # end theme
# ggplot2 object for plotting in single panel
ggp_zoo_single <- autoplot(zoo_series, 
                  main="Eu Stox single panel", 
                  facets=NULL) + xlab("") +
                  auto_theme
# ggplot2 object for plotting in multiple panels
ggp_zoo_multiple <- autoplot(zoo_series, 
                  main="Eu Stox multiple panels", 
                  facets="Series ~ .") + xlab("") +
                  facet_grid("Series ~ .", 
                  scales="free_y") + auto_theme
# render plots in single column
grid.arrange(ggp_zoo_single + 
               theme(legend.position=c(0.1, 0.5)), 
             ggp_zoo_multiple, ncol=1)
      @
    \column{0.5\textwidth}
      \vspace{-0.0em}
      \hspace*{-1em}
      \includegraphics[width=0.475\paperwidth,valign=t]{figure/ggplot_zoo1-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Time Series Objects}


%%%%%%%%%%%%%%%
\subsection{\texttt{ts} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{stats} package contains functions for manipulating time series objects of class \texttt{ts},
        <<ts_obj,echo=3:30,fig.show='hide'>>=
set.seed(1121)  # for reproducibility
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# create monthly time series starting 1990
ts_series <- ts(data=cumsum(rnorm(96)), 
             frequency=12, start=c(1990, 1))
class(ts_series)  # class 'ts'
attributes(ts_series)
methods(class=class(ts_series))[3:8]
# window the time series
window(ts_series, start=1992, end=1992.5)

plot(ts_series, type="l",  # create plot
     col="red", lty="solid", xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ts_obj-1}
      \vspace{-5em}
      The function \texttt{ts()} creates a \texttt{ts} time series object from a \texttt{numeric} vector or matrix containing the values, and associated \texttt{date-time} information (the number of years),
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{EuStockMarkets}
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Data}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} includes a number of 'base' packages that are already installed and loaded,
      \vskip1ex
      \texttt{datasets} is a base package containing various datasets, for example \texttt{EuStockMarkets},
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices,
        <<eustx_ts,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
class(EuStockMarkets)  # multiple ts object
dim(EuStockMarkets)
head(EuStockMarkets)  # get first six rows
plot(EuStockMarkets, main="", xlab="")  # plot all the columns
title(main="EuStockMarkets", line=-1)  # add title
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Distribution of \subsecname \hskip0.5em Returns}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{hist()} calculates and plots a histogram,
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      The function \texttt{density()} calculates a kernel estimate of the probability density,
      \vskip1ex
      The function \texttt{lines()} draws a line through specified points,
        \vspace{-1em}
        <<eustx_rets,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate DAX percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# mean and standard deviation of returns
c(mean(dax_rets), sd(dax_rets))
# plot histogram
hist(dax_rets, breaks=30, main="", 
     xlim=c(-0.04, 0.04), ylim=c(0, 60), 
     xlab="", ylab="", freq = FALSE)
# draw kernel density of histogram
lines(density(dax_rets), col='red', lwd=2)
# add density of normal distribution
curve(expr=dnorm(x, mean=mean(dax_rets), sd=sd(dax_rets)), 
      add=TRUE, type="l", lwd=2, col="blue")
title(main="Return distributions", line=0)  # add title
# add legend
legend("topright", inset=0.05, cex=0.8, title=NULL, 
       leg=c(colnames(EuStockMarkets)[1], "Normal"), 
       lwd=2, bg="white", col=c("red", "blue"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_rets-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Quantile-Quantile Plot}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \texttt{Q-Q} plot is a plot of points from two probability distributions with the same quantiles,
      \vskip1ex
      The function \texttt{qqnorm()} produces a normal Q-Q plot,
      \vskip1ex
      The function \texttt{qqline()} fits a line to the normal quantiles,
      \vskip1ex
      The \texttt{DAX} Q-Q plot shows that the \texttt{DAX} return distribution has fat tails,
        <<eustx_qq,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# create normal Q-Q plot
qqnorm(dax_rets, ylim=c(-0.04, 0.04), 
       xlab='Normal Quantiles', main='')
# fit a line to the normal quantiles
qqline(dax_rets, col='red', lwd=2)
plot_title <- paste(colnames(EuStockMarkets)[1], 
                  'Q-Q Plot')
title(main=plot_title, line=-1)  # add title
shapiro.test(dax_rets)  # Shapiro-Wilk test
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_qq-1}
      \vskip2ex
      The \emph{p}-value of the \emph{Shapiro-Wilk} test is very small, which shows that the \texttt{DAX} returns are not normal,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} is designed for managing \emph{time series} and ordered objects,
      \vskip1ex
      The function \texttt{zoo()} creates a \texttt{zoo} object from a \texttt{numeric} vector or matrix, and an associated \texttt{date-time} index,
      \vskip1ex
      The \texttt{zoo()} index is a vector of \texttt{date-time} objects, and can be from any \texttt{date-time} class,
      <<zoo_ts,echo=3:30,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create index of daily dates
date_index <- seq(from=as.Date("2014-07-14"), 
                  by="day", length.out=1000)
# create zoo time series
zoo_series <- zoo(cumsum(rnorm(length(date_index))), 
                  order.by=date_index)

class(zoo_series)  # class 'zoo'
tail(zoo_series, 4)  # get last few elements

# call plot.zoo
plot(zoo_series, xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operations on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{coredata()} extracts the data contained in \texttt{zoo} object, and returns a vector or matrix,
      \vskip1ex
      The function \texttt{index()} extracts the time index of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{start()} and \texttt{end()} return the time index values of the first and last elements of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{cumsum()}, \texttt{cummax()}, and \texttt{cummin()} return cumulative sums, minima and maxima of a \texttt{zoo} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:3
zoo_series <- zoo(rnorm(length(date_index)), 
               order.by=date_index)
zoo_series
index(zoo_series)  # extract time index
coredata(zoo_series)  # extract coredata
zoo_series[start(zoo_series)]  # first element
zoo_series[end(zoo_series)]  # last element
coredata(zoo_series) <- rep(1, 4)  # replace coredata
cumsum(zoo_series)  # cumulative sum
cummax(cumsum(zoo_series))
cummin(cumsum(zoo_series))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lag()} and \texttt{diff()} Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lag()} returns a lagged version of a time series, shifting the time index back by a given number of observations,
      \vskip1ex
      The function \texttt{diff()} returns the difference between a time series and its lagged version, 
      \vskip1ex
      For \texttt{zoo} objects, both these functions omit any \texttt{NA} values they may have produced,
    \column{0.6\textwidth}
      <<echo=2:30>>=
library(zoo)  # load package zoo
coredata(zoo_series) <- 1:4  # replace coredata
zoo_series
diff(zoo_series)  # diff with one day lag
lag(zoo_series, 2)  # two day lag
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Sequential Joining \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be joined sequentially using \texttt{rbind},
      <<zoo_join_seq,echo=3:30,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily date series of class 'Date'
date_index1 <- seq(Sys.Date(), by="days", 
                   length.out=365)
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
                 order.by=date_index1)
# create another zoo time series
date_index2 <- seq(Sys.Date()+350, by="days", 
                   length.out=365)
zoo_series2 <- zoo(rnorm(length(date_index2)), 
                 order.by=date_index2)
# rbind the two time series - ts1 supersedes ts2
zoo_series3 <- rbind(zoo_series1,
                 zoo_series2[index(zoo_series2) > end(zoo_series1)])
plot(cumsum(zoo_series3), xlab="", ylab="")
# add vertical lines at stitch point
abline(v=end(zoo_series1), col="blue", lty="dashed")
abline(v=start(zoo_series2), col="red", lty="dashed")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_join_seq-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Merging \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{zoo} time series can be combined concurrently by joining their columns using \texttt{merge()},
      \vskip1ex
      \texttt{merge()} is similar to \texttt{cbind()},
      \vskip1ex
      If the \texttt{all=TRUE} option is set, then \texttt{merge()} returns the union of their dates, otherwise it returns their intersection,
      \vskip1ex
      The \texttt{merge()} operation can produce \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
# create daily date series of class 'Date'
date_index1 <- Sys.Date() + -3:1
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
               order.by=date_index1)
# create another zoo time series
date_index2 <- Sys.Date() + -1:3
zoo_series2 <- zoo(rnorm(length(date_index2)), 
               order.by=date_index2)
merge(zoo_series1, zoo_series2)  # union of dates
# intersection of dates
merge(zoo_series1, zoo_series2, all=FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Managing \texttt{NA} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Operations on time series can produce \texttt{NA} values,
      \vskip1ex
      There are two dedicated functions for managing \texttt{NA} values in time series: 
      \begin{itemize}
        \item \texttt{na.omit()} removes observations containing \texttt{NA} values,
        \item \texttt{na.locf()} carries the last non-\texttt{NA} observation forward,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
library(zoo)  # load package zoo
# create zoo time series
zoo_series <- zoo(rnorm(4), 
                  order.by=(Sys.Date() + 0:3))
# add NA
zoo_series[3] <- NA
zoo_series

na.locf(zoo_series)  # replace NA's using locf

na.omit(zoo_series)  # remove NA's using omit
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Aggregating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{aggregate()} performs temporal aggregations of \texttt{zoo} objects,
      <<zoo_agg,echo=7:30,fig.show='hide'>>=
set.seed(1121)  # for reproducibility
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:365
zoo_series <- zoo(rnorm(length(date_index)), order.by=date_index)
# create monthly dates
dates_agg <- as.Date(as.yearmon(index(zoo_series)))
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using locf
zoo_agg <- na.locf(zoo_agg)
# extract aggregated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and aggregated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Aggregated Prices", 
       leg=c("orig prices", "agg prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_agg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpolating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has two functions for replacing \texttt{NA} values using interpolation:
      \begin{itemize}
        \item \texttt{na.approx()} performs linear interpolation,
        \item \texttt{na.spline()} performs spline interpolation,
      \end{itemize}
      \vspace{-1em}
      <<zoo_interpol,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using linear interpolation
zoo_agg <- na.approx(zoo_agg)
# extract interpolated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Interpolated Prices", 
       leg=c("orig prices", "interpol prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_interpol-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Rolling Functions on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has several functions for rolling calculations:
      \begin{itemize}
        \item \texttt{rollapply()} applying function to rolling margins,
        \item \texttt{rollmean()} calculate rolling means,
        \item \texttt{rollmedian()} calculate rolling median,
        \item \texttt{rollmax()} calculate rolling max,
      \end{itemize}
      \vspace{-1em}
      <<zoo_roll,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_mean <- rollapply(zoo_series, width=11, FUN=mean)
# merge with original zoo - union of dates
zoo_mean <- merge(zoo_series, zoo_mean)
# replace NA's using na.locf
zoo_mean <- na.locf(zoo_mean, fromLast=TRUE)
# extract mean zoo
zoo_mean <- zoo_mean[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_mean), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Mean Prices", 
       leg=c("orig prices", "mean prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_roll-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Time Series Objects Into \texttt{zoo}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The generic function \texttt{as.zoo} converts objects into \texttt{zoo} time series,
      \vskip1ex
      Coercing a \texttt{ts} time series creates a \texttt{zoo} object with a \texttt{numeric} \texttt{date-time} index, with \texttt{date-time} encoded as a \texttt{year-fraction},
      \vskip1ex
      The \texttt{year-fraction} can be \emph{approximately} converted to a \texttt{Date} object by first calculating the number of days since the \texttt{epoch} (\texttt{1970}), and then coercing the \texttt{numeric} days using \texttt{as.Date()},
      \vskip1ex
      The function \texttt{date\_decimal()} from package \texttt{lubridate} converts \texttt{numeric} objects into \texttt{POSIXct} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=4:30>>=
library(lubridate)  # load lubridate
library(zoo)  # load package zoo
# methods(as.zoo)  # many methods of coercing into zoo
class(EuStockMarkets)  # multiple ts object
# convert mts object into zoo
zoo_series <- as.zoo(EuStockMarkets)
class(index(zoo_series))  # index is numeric
head(zoo_series, 3)
# approximately convert index into class 'Dates'
index(zoo_series) <- as.Date(365*(index(zoo_series)-1970))
head(zoo_series, 3)
# convert index into class 'Dates'
zoo_series <- as.zoo(EuStockMarkets)
index(zoo_series) <- date_decimal(index(zoo_series))
head(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package \texttt{tseries} for Time Series Analysis}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<tseries_intro,echo=2:30,eval=TRUE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(tseries)  # load package tseries
zoo_msft <- suppressWarnings(  # load MSFT data
  get.hist.quote(instrument="MSFT", 
                 start=Sys.Date()-365, 
                 end=Sys.Date(), 
                 origin="1970-01-01")
)  # end suppressWarnings
class(zoo_msft)
dim(zoo_msft)
tail(zoo_msft, 4)

sharpe(zoo_msft[, "Close"], r=0.01)  # calculate Sharpe ratio

plot(zoo_msft[, "Close"], xlab="", ylab="")
title(main="MSFT Close Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/tseries_intro-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading Time Series Data Using Package \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<zoo_plot_2y,echo=3:30,eval=TRUE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(tseries)  # load package tseries
zoo_eurusd <- suppressWarnings(  # load EUR/USD data
  get.hist.quote(
    instrument="EUR/USD", provider="oanda",
    start=Sys.Date()-365, 
    end=Sys.Date(), 
    origin="1970-01-01")
)  # end suppressWarnings
# bind and scrub data
zoo_msfteur <- merge(zoo_eurusd, 
                     zoo_msft[, "Close"])
colnames(zoo_msfteur) <- c("EURUSD", "MSFT")
zoo_msfteur <- 
  zoo_msfteur[complete.cases(zoo_msfteur),]
### plot with two "y" axes
par(las=1)  # set text printing to "horizontal"
# plot first ts
plot(zoo_msfteur[, 1], xlab=NA, ylab=NA)
# set range of "y" coordinates for second axis
par(usr=c(par("usr")[1:2], range(zoo_msfteur[,2])))
lines(zoo_msfteur[, 2], col="red")  # second plot
axis(side=4, col="red")  # second "y" axis on right
# print axis labels
mtext(colnames(zoo_msfteur)[1], side=2, padj=-6, line=-4)
mtext(colnames(zoo_msfteur)[2], col="red", side=4, padj=-2, line=-3)
title(main="EUR and MSFT")  # add title
# add legend without box
legend("bottomright", legend=colnames(zoo_msfteur), bg="white", 
       lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")


##########

# slightly different method using par(new=TRUE)
# par(las=1)  # set text printing to "horizontal"
# plot(zoo_msfteur[, 1], xlab=NA, ylab=NA)
# par(new=TRUE)  # allow new plot on same chart
# plot(zoo_msfteur[, 2], xlab=NA, ylab=NA, yaxt="n", col="red")
# axis(side=4, col="red")  # second "y" axis on right
# mtext(colnames(zoo_msfteur)[1], side=2, padj=-6, line=-4)
# mtext(colnames(zoo_msfteur)[2], col="red", side=4, padj=-2, line=-3)
# title(main="EUR and MSFT", line=-1)  # add title
# legend("bottomright", legend=colnames(zoo_msfteur), 
#        lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")

##########

# "x" axis with monthly ticks - doesn't work
# plot first ts wthout "x" axis
# plot(zoo_msfteur[, 1], xaxt="n", xlab=NA, ylab=NA)
# # add "x" axis with monthly ticks
# month.ticks <- unique(as.yearmon(index(zoo_eurusd)))
# axis(side=1, at=month.ticks, labels=format(month.ticks, "%b-%y"), tcl=-0.7)

      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_plot_2y-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Series Classes in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has a number of different time series classes:
      \begin{itemize}
        \item Class \texttt{ts} from base package \texttt{stats},
        \item Class \texttt{zoo} ordered observations,
        \item Class \texttt{xts} extension of \texttt{zoo} class,
        \item Class \texttt{timeSeries} from the \emph{Rmetrics} suite,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=1:30>>=
ts_msft <- as.ts(zoo_msft)
class(ts_msft)
# rename colnames
colnames(ts_msft) <- paste0("MSFT.", colnames(ts_msft))
tail(ts_msft, 4)

library(timeSeries)
tser_msft <- as.timeSeries(zoo_msft)
class(ts_msft)
tail(tser_msft, 4)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Univariate Statistical Analysis}



%%%%%%%%%%%%%%%
\subsection{Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Autocorrelation Function} is the correlation coefficient of a time series with its lagged values:
      \begin{displaymath}
        \rho_{k} = \frac{1}{(n-k)\sigma^2} {\sum_{i=k+1}^{n} (x_{i}-\bar{x})(x_{i-k}-\bar{x})}
      \end{displaymath}
      \vskip1ex
      The function \texttt{acf()} from the base package \texttt{stats} calculates and plots the autocorrelation function for a univariate time series,
      \vskip1ex
      \texttt{acf()} returns the \texttt{acf} data invisibly - the return value isn't automatically printed to the console,
      \vskip1ex
      The \texttt{acf()} return data can be assigned to a variable, and then printed,
        <<acf_func,echo=2:30,fig.width=4,fig.height=3.5,fig.show='hide'>>=
par(mar=c(5,0,1,2), oma=c(1,2,1,0), mgp=c(2,1,0), cex.lab=0.8, cex.axis=1.0, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# autocorrelation from "stats"
acf(coredata(dax_rets), lag=10, main="")
title(main="acf of DAX returns", line=-1)
      @
      The package \texttt{zoo} is designed for managing \emph{time series} and ordered objects,
      \vskip1ex
      \texttt{coredata} extracts the core underlying data from a complex object,
    \column{0.5\textwidth}
      \vspace{-1.0em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/acf_func-1}
      \vspace{-3.0em}
      The horizontal dashed lines are confidence intervals of the autocorrelation estimator (at 95\% significance level),
      \vskip1ex
      The DAX time series does not appear to have statistically significant autocorrelations,
      \vskip1ex
      The function \texttt{acf()} has the drawback that it plots the lag-zero autocorrelation (which is simply \texttt{1}),
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Improved Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Inspection of the data returned by \texttt{acf()} shows how to omit the lag-zero autocorrelation,
      <<echo=2:30>>=
library(zoo)  # load package zoo
dax_acf <- acf(coredata(dax_rets), plot=FALSE)
summary(dax_acf)  # get the structure of the "acf" object
# print(dax_acf)  # print acf data
dim(dax_acf$acf)
dim(dax_acf$lag)
head(dax_acf$acf)
      @
    \column{0.5\textwidth}
      The below wrapper function for \texttt{acf()} omits the lag-zero autocorrelation,
      <<>>=
acf_plus <- function (ts_data, plot=TRUE, 
                      xlab="Lag", ylab="", 
                      main="", ...) {
  acf_data <- acf(x=ts_data, plot=FALSE, ...)
# remove first element of acf data
  acf_data$acf <-  array(data=acf_data$acf[-1], 
          dim=c((dim(acf_data$acf)[1]-1), 1, 1))
  acf_data$lag <-  array(data=acf_data$lag[-1], 
          dim=c((dim(acf_data$lag)[1]-1), 1, 1))
  if(plot) {
    ci <- qnorm((1+0.95)/2)*sqrt(1/length(ts_data))
    ylim <- c(min(-ci, range(acf_data$acf[-1, , 1])),
              max(ci, range(acf_data$acf[-1, , 1])))
    plot(acf_data, xlab=xlab, ylab=ylab, 
         ylim=ylim, main=main, ci=0)
    abline(h=c(-ci, ci), col="blue", lty=2)
  }
  invisible(acf_data)  # return invisibly
}  # end acf_plus
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation of DAX Returns}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The DAX time series does not appear to have statistically significant autocorrelations,
      \vskip1ex
      But the \texttt{acf} plot alone is not enough to test whether autocorrelations are statistically significant or not,
        <<dax_acf,echo=3:30,fig.width=4,fig.height=3.5,fig.show='hide'>>=
par(mar=c(5,0,1,2), oma=c(1,2,1,0), mgp=c(2,1,0), cex.lab=0.8, cex.axis=1.0, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# improved autocorrelation function
acf_plus(coredata(dax_rets), lag=10, main="")
title(main="acf of DAX returns", line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_acf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{U.S. Macroeconomic Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{Ecdat} contains the \texttt{Macrodat} U.S. macroeconomic data,
      \vskip1ex
      "\texttt{lhur}" is the unemployment rate (average of months in quarter),
      \vskip1ex
      "\texttt{fygm3}" 3 month treasury bill interest rate (last month in quarter)
      <<macro_data,echo=1:30,fig.show='hide'>>=
library(Ecdat)  # load Ecdat
colnames(Macrodat)  # United States Macroeconomic Time Series
macro_zoo <- as.zoo(  # coerce to "zoo"
          Macrodat[, c("lhur", "fygm3")])
colnames(macro_zoo) <- c("unemprate", "3mTbill")
# ggplot2 in multiple panes
autoplot(  # generic ggplot2 for "zoo"
  object=macro_zoo, main="US Macro",
  facets=Series ~ .) + # end autoplot
  xlab("") + 
theme(  # modify plot theme
  legend.position=c(0.1, 0.5),
  plot.title=element_text(vjust=-2.0),
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"),
  plot.background=element_blank(),
  axis.text.y=element_blank()
)  # end theme
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/macro_data-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation of Econometric Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most econometric data displays a high degree of autocorrelation,
      \vskip1ex
      But time series of tradeable prices display very low autocorrelation,
      <<macro_corr,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
macro_diff <- na.omit(diff(macro_zoo))

acf_plus(coredata(macro_diff[, "unemprate"]), 
         lag=10)
title(main="quarterly unemployment rate", 
      line=-1)

acf_plus(coredata(macro_diff[, "3mTbill"]), 
         lag=10)
title(main="3 month T-bill EOQ", line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/macro_corr-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Ljung-Box Test of Autocorrelation}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Ljung-Box} test \emph{null hypothesis} is that autocorrelations are equal to zero,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        Q = n(n+2) \sum_{k=1}^{maxlag} \frac{{\hat\rho}_{k}^2}{n-k}
      \end{displaymath}
      Where $n$ is the sample size, and the ${\hat\rho}_{k}$ are sample autocorrelations,
      \vskip1ex
      The \emph{Ljung-Box} statistic follows the \emph{chi-squared} distribution with \emph{maxlag} degrees of freedom,
      \vskip1ex
      The \emph{Ljung-Box} statistic is small for time series that are \emph{not} autocorrelated,
      \vskip1ex
      The \emph{p}-value for DAX returns is large, and we conclude that the \emph{null hypothesis} is \texttt{TRUE}, and that DAX returns are \emph{not} autocorrelated,
      \vskip1ex
      The \emph{p}-value for changes in econometric data is extremely small, and we conclude that the \emph{null hypothesis} is \texttt{FALSE}, and that econometric data \emph{are} autocorrelated,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=1:30>>=
# Ljung-Box test for DAX data
# 'lag' is the number of autocorrelation coefficients
Box.test(dax_rets, lag=10, type="Ljung")

# changes in 3 month T-bill rate are autocorrelated
Box.test(macro_diff[, "3mTbill"], 
         lag=10, type="Ljung")

# changes in unemployment rate are autocorrelated
Box.test(macro_diff[, "unemprate"], 
         lag=10, type="Ljung")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Filtering Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-1em}
      <<dax_filter,fig.width=6,fig.height=5,fig.show='hide'>>=
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(gridExtra)  # load gridExtra
# extract DAX time series
dax_ts <- EuStockMarkets[, 1]
# filter past values only (sides=1)
dax_filt <- filter(dax_ts, 
                   filter=rep(1/5,5), sides=1)
# coerce to zoo and merge the time series
dax_filt <- merge(as.zoo(dax_ts), 
                  as.zoo(dax_filt))
colnames(dax_filt) <- c("DAX", "DAX filtered")
dax_data <- window(dax_filt, 
                   start=1997, end=1998)
autoplot(  # plot ggplot2
    dax_data, main="Filtered DAX", 
    facets=NULL) +  # end autoplot
xlab("") + ylab("") +
theme(  # modify plot theme
    legend.position=c(0.1, 0.5), 
    plot.title=element_text(vjust=-2.0), 
    plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
    plot.background=element_blank(),
    axis.text.y=element_blank()
    )  # end theme
# end ggplot2
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_filter-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation Function of Filtered Time Series}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Filtering a time series creates autocorrelations,
      <<dax_filter_acf,echo=2:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
dax_rets <- na.omit(diff(log(dax_filt)))
par(mfrow=c(2,1))  # set plot panels

acf_plus(coredata(dax_rets[, 1]), lag=10, 
         xlab="")
title(main="DAX", line=-1)

acf_plus(coredata(dax_rets[, 2]), lag=10, 
         xlab="")
title(main="DAX filtered", line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_filter_acf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Partial Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{partial autocorrelation} of lag \texttt{k} is the autocorrelation after all the autocorrelations of lag \texttt{1,..., k-1} have been removed,
        <<eustx_pacf,echo=2:30,fig.height=8,eval=TRUE,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# autocorrelation from "stats"
acf_plus(dax_rets[, 2], lag=10, xlab=NA, ylab=NA)
title(main="DAX filtered autocorrelations", line=-1)
# partial autocorrelation
pacf(dax_rets[, 2], lag=10, xlab=NA, ylab=NA)
title(main="DAX filtered partial autocorrelations", 
      line=-1)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_pacf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulating Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{autoregressive} time series process is defined by the formula:
      \begin{displaymath}
        x_{i} = c + {\varphi}_{1} x_{i-1} + {\varphi}_{2} x_{i-2} + \ldots + {\varphi}_{p} x_{i-p} + {\varepsilon}_{i}
      \end{displaymath}
      Where the ${\varepsilon}_{i}$ are independent random variables with zero mean and constant variance,
      \vskip1ex
      The function \texttt{arima.sim()} simulates an ARIMA process,
      \vspace{-1em}
    <<ar_process,echo=4:30,fig.height=5,fig.show='hide'>>=
# ARIMA processes
library(ggplot2)  # load ggplot2
library(gridExtra)  # load gridExtra
daily_index <- Sys.Date() + 0:364  # one year daily series
ar_zoo <- zoo(  # AR time series of returns
  x=arima.sim(n=365, model=list(ar=0.2)),
  order.by=daily_index)  # ar_zoo
ar_zoo <- cbind(ar_zoo, cumsum(ar_zoo))
colnames(ar_zoo) <- c("AR returns", "AR prices")
# plot AR returns
autoplot(object=ar_zoo, 
     facets="Series ~ .", 
     main="Autoregressive process (phi=0.2)") + 
  facet_grid("Series ~ .", scales="free_y") +
  xlab("") + ylab("") + 
theme(
  legend.position=c(0.1, 0.5), 
#  plot.title=element_text(vjust=-1.0), 
  plot.background=element_blank(),
  axis.text.y=element_blank())
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_process-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Examples of Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      <<ar_param,echo=1:30,fig.height=5,fig.show='hide'>>=
ar_coeff <- c(0.01, 0.4, 0.8)  # AR coefficients
ar_zoo <- sapply(  # create three AR time series
  ar_coeff, function(phi)
          arima.sim(n=365, model=list(ar=phi)))
ar_zoo <- zoo(x=ar_zoo, order.by=daily_index)
ar_zoo <- cumsum(ar_zoo)  # returns to prices
colnames(ar_zoo) <- paste("autocorr", ar_coeff)
autoplot(ar_zoo, main="AR prices", 
         facets=Series ~ .) + 
    facet_grid(Series ~ ., scales="free_y") +
xlab("") + 
theme(
  legend.position=c(0.1, 0.5), 
  plot.title=element_text(vjust=-2.0), 
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
  plot.background=element_blank(),
  axis.text.y=element_blank())
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_param-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation in Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{autoregressive} process of order \emph{one} \emph{AR}(1) is defined by the formula:
      \begin{displaymath}
        x_{i} = c + {\varphi}_{1} x_{i-1} + {\varepsilon}_{i}
      \end{displaymath}
      An \emph{AR}(1) process has an exponentially declining ACF and a non-zero PACF at lag one,
      <<ar_acf,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# ACF of AR(1) process
acf_plus(na.omit(diff(ar_zoo[, 2])), lag=10, 
       xlab="", ylab="", main="ACF of AR(1) process")

# PACF of AR(1) process
pacf(na.omit(diff(ar_zoo[, 2])), lag=10,
     xlab="", ylab="", main="PACF of AR(1) process")
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_acf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Identification of Autoregressive Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{AR}(3) process of order \emph{three} is defined by the formula:
      \begin{displaymath}
        x_{i} = c + {\varphi}_{1} x_{i-1} + {\varphi}_{2} x_{i-2} + {\varphi}_{3} x_{i-3} + {\varepsilon}_{i}
      \end{displaymath}
      Autoregressive processes \emph{AR}(n) of order \emph{n} have an exponentially declining ACF and a non-zero PACF up to lag \emph{n},
      <<ar_pacf,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
ar3_zoo <- zoo(  # AR(3) time series of returns
  x=arima.sim(n=365, 
          model=list(ar=c(0.1, 0.5, 0.1))),
  order.by=daily_index)  # ar_zoo
# ACF of AR(3) process
acf_plus(ar3_zoo, lag=10, 
       xlab="", ylab="", main="ACF of AR(3) process")

# PACF of AR(3) process
pacf(ar3_zoo, lag=10,
     xlab="", ylab="", main="PACF of AR(3) process")
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ar_pacf-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fitting Autoregressive Models}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{arima()} from the base package \texttt{stats} fits a specified ARIMA model to a univariate time series,
      \vskip1ex
      The function \texttt{auto.arima()} from the package \texttt{forecast} automatically fits an ARIMA model to a univariate time series,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=1:30>>=
ar3_zoo <- arima.sim(n=1000, 
            model=list(ar=c(0.1, 0.3, 0.1)))
arima(ar3_zoo, order = c(5,0,0))  # fit AR(5) model
library(forecast)  # load forecast
auto.arima(ar3_zoo)  # fit ARIMA model
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Regression Analysis}


%%%%%%%%%%%%%%%
\subsection{Formula Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Formulas in \texttt{R} are defined using the "\textasciitilde{}" operator followed by a series of terms separated by the "\texttt{+}" operator,
      \vskip1ex
      Formulas can be defined as separate objects, manipulated, and passed to functions,
      \vskip1ex
      The formula "\texttt{z} \textasciitilde{} \texttt{x}" means the response (independent) variable \texttt{z} is explained by the predictor \texttt{x},
      \vskip1ex
      The formula "\texttt{z \textasciitilde{} x + y}" represents a linear model: \texttt{z = ax  + by + c},
      \vskip1ex
      The formula "\texttt{y \textasciitilde{} x - 1}" or "\texttt{y \textasciitilde{} x + 0}" represents a linear model with zero intercept: $y = ax$,
      \vskip1ex
      The function \texttt{update()} modifies existing \texttt{formulas},
      \vskip1ex
      The "\texttt{.}" symbol represents either all the remaining data, or the variable that was in this part of the formula,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
# formula of linear model with zero intercept
lin_formula <- z ~ x + y - 1
lin_formula

# collapsing a character vector into a text string
paste0("x", 1:5)
paste(paste0("x", 1:5), collapse="+")

# creating formula from text string
lin_formula <- as.formula(  # coerce text strings to formula
              paste("y ~ ", 
                paste(paste0("x", 1:5), collapse="+")
                )  # end paste
            )  # end as.formula
class(lin_formula)
lin_formula
# modify the formula using "update"
update(lin_formula, log(.) ~ . + beta)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Linear Regression Using \texttt{lm()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A linear model between a response variable \texttt{z} and explanatory variables \texttt{x} is defined by the formula:
      \begin{displaymath}
        z_{i} = {\alpha} + \sum_{j=1}^{k} {{\beta}_{j} x_{i,j}} + {\varepsilon}_{i}
      \end{displaymath}
      Where the ${\varepsilon}_{i}$ are the errors, assumed to be normally distributed, independent, and stationary,
      \vskip1ex
      The function \texttt{lm()} fits a linear model (regression) into the data (a set of observations),
      \vskip1ex
      \texttt{lm()} returns an object of class \texttt{lm()}, which is a list containing the results of fitting the model:
      \begin{itemize}
        \item call - the model formula,
        \item coefficients - the fitted model coefficients (${\alpha}$, ${\beta}_{j}$),
        \item residuals - the model residuals (response minus fitted values),
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
set.seed(1121)  # initialize random number generator
indep_var <- 0.1*1:30  # independent (explanatory) variable
# dependent (response) variable equals linear form plus noise
depend_var <- 3 + 2*indep_var + rnorm(30)
# specify regression formula
reg_formula <- depend_var ~ indep_var
reg_model <- lm(reg_formula)  # perform regression
class(reg_model)  # regressions have class lm
attributes(reg_model)
eval(reg_model$call$formula)  # the regression formula
reg_model$coefficients  # the regression formula coefficients
coef(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Regression Scatterplot}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The generic function \texttt{plot()} produces a scatterplot when it's called on the regression formula,
      \vskip1ex
      \texttt{abline()} plots a straight line corresponding to the regression coefficients, when it's called on the regression object,
      \vskip1ex
      The fitted (predicted) values are the values of the response variable obtained from applying the regression model to the explanatory variables,
        <<reg_scatter_plot,echo=2:30,fig.show='hide'>>=
par(oma=c(1, 2, 1, 0), mgp=c(2, 1, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=1.0, cex.main=0.8, cex.sub=0.5)
plot(reg_formula)  # plot scatterplot using formula
title(main="Simple Regression", line=-1)
# add regression line
abline(reg_model, lwd=2, col="red")
# plot fitted (predicted) response values
points(x=indep_var, y=reg_model$fitted.values, 
       pch=16, col="blue")
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/reg_scatter_plot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regression Summary}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{summary.lm()} produces a list of summary statistics for a regression model,
      \vskip1ex
      The \texttt{summary} list includes:
      \begin{itemize}
        \item coefficients: matrix with estimated coefficients, their \emph{t}-statistics, and \emph{p}-values,
        \item r.squared: fraction of response variable variance explained by the model (correlation between response and explanatory variables),
        \item adj.r.squared: r.squared adjusted for higher model complexity,
        \item fstatistic: \emph{F}-statistic - ratio of variance explained by model divided by unexplained variance,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
reg_model_sum <- summary(reg_model)  # copy regression summary
reg_model_sum  # print the summary to console
attributes(reg_model_sum)$names  # get summary elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpreting the Regression Statistics}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The regression \texttt{summary} is a list, and its elements can be accessed individually,
      \vskip1ex
      The \emph{null} hypothesis is that the regression coefficients are \emph{zero},
      \vskip1ex
      A small \emph{p}-value is often interpreted as meaning that the coefficients are very unlikely to be zero (given the data),
      \vskip1ex
      The \emph{t}-statistic and the \emph{F}-statistic assume that the errors in the data are drawn from independent normal distributions,
      \vskip1ex
      But financial data is very far from normal, so the \emph{p}-values shouldn't be automatically interpreted as meaning that the coefficients are non-zero,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
reg_model_sum$coefficients
reg_model_sum$r.squared
reg_model_sum$adj.r.squared
reg_model_sum$fstatistic
anova(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Weak Regression}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      If the relationship between the response and explanatory variables is weak compared to the noise, then the regression will have low statistical significance,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
set.seed(1121)  # initialize random number generator
# small coefficient between response and explanatory variables
depend_var <- 3 + 0.2*indep_var + rnorm(30)
reg_model <- lm(reg_formula)  # perform regression
# the estimate of the coefficient is not statistically significant
summary(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regression Diagnostic Plots}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{plot()} produces diagnostic scatterplots for the residuals, when called on the regression object,
      \vskip1ex
      {\scriptsize
      The diagnostic scatterplots allow for visual inspection to determine the quality of the regression fit,
      \vskip1ex
      "Residuals vs Fitted" is a scatterplot of the residuals vs. the predicted responses,
      \vskip1ex
      "Scale-Location" is a scatterplot of the square root of the standardized residuals vs. the predicted responses,
      \vskip1ex
      The residuals should be randomly distributed around the horizontal line representing zero residual error,
      \vskip1ex
      A pattern in the residuals indicates that the model was not able to capture the relationship between the variables, or that the variables don't follow the statistical assumptions of the regression model,
      \vskip1ex
      "Normal Q-Q" is the standard Q-Q plot, and the points should fall on the diagonal line, indicating that the residuals are normally distributed,
      \vskip1ex
      "Residuals vs Leverage" is a scatterplot of the residuals vs. their leverage,
      \vskip1ex
      Leverage measures the amount by which the predicted response would change if the observed response were shifted by a small amount,
      \vskip1ex
      Cook's distance measures the influence of a single observation on the predicted values, and is proportional to the sum of the squared differences between predictions made with all observations and predictions made without the observation,
      \vskip1ex
      Points with large leverage, or a Cook's distance greater than 1 suggest the presence of an outlier or a poor model,
      }
    \column{0.5\textwidth}
      \vspace{-1em}
      <<plot_reg,echo=3:30,fig.show='hide'>>=
# set plot paramaters - margins and font scale
par(oma=c(1, 0, 1, 0), mgp=c(2, 1, 0), mar=c(2, 1, 2, 1), cex.lab=0.8, cex.axis=1.0, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2, 2))  # plot 2x2 panels
plot(reg_model)  # plot diagnostic scatterplots
plot(reg_model, which=2)  # plot just Q-Q
      @
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/plot_reg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Durbin-Watson Test of Autocorrelation of Residuals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Durbin-Watson} test is designed to test the \emph{null hypothesis} that the autocorrelations of regression residuals are equal to zero,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        DW = \frac {\sum_{i=2}^{n} (\varepsilon_{i} - \varepsilon_{i-1})^2} {\sum_{i=1}^{n} \varepsilon_{i}^2}
      \end{displaymath}
      Where $\varepsilon_{i}$ are the regression residuals,
      \vskip1ex
      The value of the \emph{Durbin-Watson} statistic \emph{DW} is close to zero for large positive autocorrelations, and close to four for large negative autocorrelations,
      \vskip1ex
      The \emph{DW} is close to two for autocorrelations close to zero,
      \vskip1ex
      The \emph{p}-value for the \texttt{my\_reg} regression is large, and we conclude that the \emph{null hypothesis} is \texttt{TRUE}, and the regression residuals are uncorrelated,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=4:30>>=
depend_var <- 3 + 2*indep_var + rnorm(30)
reg_formula <- depend_var ~ indep_var
reg_model <- lm(reg_formula)  # perform regression
library(lmtest)  # load lmtest

# perform Durbin-Watson test
dwtest(reg_model)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Omitted Variable Bias}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Omitted Variable Bias} occurs in a regression model that omits important predictors,
      \vskip1ex
      The parameter estimates are biased, even though the \emph{t}-statistics, \emph{p}-values, and \emph{R}-squared all indicate a statistically significant regression,
      \vskip1ex
      But the Durbin-Watson test shows residuals are autocorrelated, invalidating other tests,
      \vspace{-1em}
        <<ovb_reg,echo=4:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
library(lmtest)  # load lmtest
design_matrix <- data.frame(  # design matrix
  indep_var=1:30, omit_var=sin(0.2*1:30))
# response depends on both explanatory variables
depend_var <- with(design_matrix, 
          0.2*indep_var + omit_var + 0.2*rnorm(30))
# mis-specified regression only one explanatory
reg_model <- lm(depend_var ~ indep_var, 
                data=design_matrix)
reg_model_sum <- summary(reg_model)
reg_model_sum$coefficients
reg_model_sum$r.squared
# Durbin-Watson test shows residuals are autocorrelated
dwtest(reg_model)$p.value
plot(reg_formula, data=design_matrix)
abline(reg_model, lwd=2, col="red")
title(main="OVB Regression", line=-1)
plot(reg_model, which=2, ask=FALSE)  # plot just Q-Q
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ovb_reg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Spurious Time Series Regression}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Regression of non-stationary time series creates \emph{spurious} regressions,
      \vskip1ex
      The \emph{t}-statistics, \emph{p}-values, and \emph{R}-squared all indicate a statistically significant regression,
      \vskip1ex
      But the Durbin-Watson test shows residuals are autocorrelated, which invalidates the other tests,
      \vskip1ex
      The Q-Q plot also shows that residuals are \emph{not} normally distributed,
        <<spur_reg,echo=6:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(0, 0.5, 0), mar=c(1, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
set.seed(1121)
library(lmtest)
# spurious regression in unit root time series
indep_var <- cumsum(rnorm(100))  # unit root time series
depend_var <- cumsum(rnorm(100))
reg_formula <- depend_var ~ indep_var
reg_model <- lm(reg_formula)  # perform regression
# summary indicates statistically significant regression
reg_model_sum <- summary(reg_model)
reg_model_sum$coefficients
reg_model_sum$r.squared
# Durbin-Watson test shows residuals are autocorrelated
dw_test <- dwtest(reg_model)
c(dw_test$statistic[[1]], dw_test$p.value)
plot(reg_formula, xlab="", ylab="")  # plot scatterplot using formula
title(main="Spurious Regression", line=-1)
# add regression line
abline(reg_model, lwd=2, col="red")
plot(reg_model, which=2, ask=FALSE)  # plot just Q-Q
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/spur_reg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Predictions Using Regression Models}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{predict()} is a generic function for performing predictions based on a given model,
      \vskip1ex
      \texttt{predict.lm()} is the predict method for linear models (regressions),
      \vspace{-1em}
        <<predict_lm,echo=1:30,fig.show='hide'>>=
indep_var <- 0.1*1:30  # explanatory variable
depend_var <- 3 + 2*indep_var + rnorm(30)
reg_formula <- depend_var ~ indep_var
reg_model <- lm(reg_formula)  # perform regression
new_data <- data.frame(indep_var=0.1*31:40)
predict_lm <- predict(object=reg_model, 
                      newdata=new_data, level=0.95, 
                      interval="confidence")
predict_lm <- as.data.frame(predict_lm)
head(predict_lm, 2)
plot(reg_formula, xlim=c(1.0, 4.0), 
     ylim=range(depend_var, predict_lm),
     main="Regression predictions")
abline(reg_model, col="red")
with(predict_lm, {
  points(x=new_data$indep_var, y=fit, pch=16, col="blue")
  lines(x=new_data$indep_var, y=lwr, lwd=2, col="red")
  lines(x=new_data$indep_var, y=upr, lwd=2, col="red")
})  # end with
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/predict_lm-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  \begin{itemize}[]
    \item create a data directory on your computer, and save all files to that directory,
    \item remember the location of the data directory for future use,
    \item read the ETF database file called "etf\_list.csv" into a data frame called "etf\_list", using read.csv(),
    \item create a vector of symbols called "\texttt{sym\_bols}":
    \item \texttt{sym\_bols <- c("VTI", "VEU", "IEF", "VNQ", "DBC", "XLY", "XLP", "XLE", "XLF", "XLV", "XLI", "XLB", "XLK", "XLU", "IWB", "IWD", "IWF", "IWM", "IWN", "IWO", "IWP", "IWR", "IWS", "IWV", "IUSV", "IUSG")}
    \item subset etf\_list to include only those ETF's in \texttt{sym\_bols}, using the "\texttt{\%in\%}" operator,
    \item download 10yrs of price and volume data for the list of \texttt{sym\_bols}, and call it "zoo\_series",
    \item use \texttt{get.hist.quote()} and an \texttt{lapply()} loop,
    \item for each symbol download the fields "AdjClose" and "Volume",
    \item name the list returned by lapply as "\texttt{zoo\_series}" (each list element is a zoo object),
    \item assign a \texttt{names()} attribute to \texttt{zoo\_series}, equal to the \texttt{sym\_bols} vector (result should be a named list),
  \end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment (cont.)}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  \begin{itemize}[]
    \item flatten \texttt{zoo\_series} into a single zoo object, using \texttt{do.call()} and \texttt{merge()},
    \item assign new \texttt{names()} to \texttt{zoo\_series}, in the format "XLI.Close", "XLI.Volume", etc.
    \item use \texttt{sapply()} and \texttt{paste()},
    \item save \texttt{zoo\_series} to a comma-separated CSV file called "zoo\_series.csv", using \texttt{write.zoo()},
    \item save \texttt{zoo\_series} to a binary file called "zoo\_series.Rdata", using \texttt{save()},
    \item plot the time series \texttt{zoo\_series[, "VTI.Close"]} using \texttt{autoplot()}
  \end{itemize}
  hint: use the required functions, and find examples in the lecture notes,
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 3-5: \fullcite{website:Farnsworth}
    \item Read chapters 4, 5, 9-10: \citetitle{rupperttexbook}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
