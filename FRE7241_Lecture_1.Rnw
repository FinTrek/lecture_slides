% FRE7241_Lecture_1

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE7241 Lecture\#1]{FRE7241 Algorithmic Portfolio Management}
\subtitle{Lecture\#1, Spring 2015}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{April 7, 2015}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%%
\subsection{FRE7241 Course Description and Objectives}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Course Description}
The course will explore time series analysis, asset pricing, risk factor models, portfolio optimization, and algorithmic portfolio management strategies. 
The course will demonstrate how to apply the \texttt{R} programming language to the implementation of algorithmic portfolio management strategies, illustrated with working \texttt{R} code.
\end{block}
\pause

\begin{block}{Course Objectives}
Students will learn how to use \texttt{R} in order to:\\
\hskip1em - download data from external sources, scrub, and format it,\\
\hskip1em - estimate time series parameters,\\
\hskip1em - fit models such as \texttt{ARIMA}, \texttt{GARCH}, and factor models,\\
\hskip1em - identify potential pricing anomalies,\\
\hskip1em - optimize portfolios under different constraints and risk-return objectives,\\
\hskip1em - backtest active portfolio management strategies and evaluate their performance,\\
\end{block}
\pause

\begin{block}{Course Prerequisites}
FRE6123 Financial Risk Management and Asset Pricing.  Students should also have some experience with the \texttt{R} language or equivalent languages such as \texttt{Matlab} or \texttt{Python}.  
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Homeworks and Tests}
Grading will be based on homework assignments and several in-class tests.  There will be no final exam.\\
The homeworks and tests will require writing code that should run directly when pasted into an \texttt{R} session, and produce the required output, without any modifications.\\
Students will be allowed to consult, and to copy code from course slides, books, or any online sources, but will be required to provide references to those external sources (such as links or titles and page numbers).\\
The homeworks and tests will be closely based on code contained in the course slides, so students are encouraged to become very familiar with those slides.\\
Homeworks will be due two weeks after they're announced (unless stated otherwise).\\
\end{block}
\pause

\begin{block}{Teaching Assistant}
The TA will be Luping Liu (\emph{\color{blue}ll2525@nyu.edu})\\
All homework and test files \emph{should be mailed to the TA}.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Course Grading Policies}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Numerical Scores}
Homeworks and tests will contain several parts.  Each part will be graded separately and assigned a numerical score.\\
Homework and test scores will be equal to the sum of scores of their parts.\\
Maximum scores will be given only for complete and correct code.
Partial credit will be given even for code that doesn't produce the right answer, but that has elements of code that can be useful for producing the right answer.
\end{block}
\pause

\begin{block}{Plagiarism}
Plagiarism (copying from other students) and cheating will be punished.\\
But copying code from course slides, books, or any online sources is allowed and encouraged.
Students must provide references to any external sources from which they copy code (such as links or titles and page numbers).
\end{block}
\pause

\begin{block}{Letter Grades}
Letter grades for the course will be based on the average of homework and test scores.\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE7241 Course Materials}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Course Slides}
The course will be mostly self-contained, using detailed course slides containing extensive, working \texttt{R} code examples.\\
The course will also utilize data and tutorials which are freely available on the internet.
\end{block}
\pause

\begin{block}{FRE7241 Recommended Textbooks}
\begin{itemize}[]
  \item \emph{"Financial Risk Modelling"} introduces volatility models, portfolio optimization, and tactical asset allocation, with great review of \texttt{R} packages and examples in \texttt{R}:\\
  \fullcite{pfaffbook}\\
  \item \emph{"Analysis for Financial Engineering"} introduces regression, cointegration, multivariate time series analysis, \texttt{ARIMA}, \texttt{GARCH}, \texttt{CAPM}, and factor models, with examples in \texttt{R}:\\
  \fullcite{ruppertbook}\\
  \item \emph{"Applied Econometrics"} introduces advanced statistical models and econometrics:\\
  \fullcite{kleiberbook}
  \item \emph{"Econometrics in R"} contains a good review of regression and time series analysis:
  \url{http://cran.r-project.org/doc/contrib/Farnsworth-EconometricsInR.pdf}
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE7241 Supplementary Textbooks}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Supplementary Textbooks}
\begin{itemize}[]
  \item \emph{"The Art of R Programming"} is a good introduction to \texttt{R} and to statistical models (you can download it for free):\\
  \fullcite{matloffbook}
  \item The \emph{"Statistical Learning"} book introduces machine learning techniques using \texttt{R} - it's a must have for advanced finance applications (you can download it for free):\\
  \fullcite{islbook}
  \item \emph{"Advanced \texttt{R}"} is the best book for learning the advanced features of \texttt{R}:\\
  \fullcite{hadleybook}
  \item \emph{"Numerical Recipes"} is a great reference for linear algebra and numerical methods, implemented in working \texttt{C++} code:\\
  \fullcite{numrecipesbook}
  \item \emph{"\texttt{R} in Action"} is a good introduction to \texttt{R} and to statistical models:\\
  \fullcite{kabacoffbook}
  \item \emph{"\texttt{R} for Everyone"} is a good introduction to \texttt{R} and to statistical models:\\
  \fullcite{landerbook}
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE7241 Supplementary Materials}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{Notepad++} is a free source code editor for \texttt{MS Windows}, that supports several programming languages, including \texttt{R}. 
      \vskip1ex
      \texttt{Notepad++} has a very convenient and fast \emph{search and replace} function, that allows \emph{search and replace} in multiple files.\\
      \hskip1em\url{http://notepad-plus-plus.org/}
    \column{0.3\textwidth}
      \includegraphics[height=0.5\textwidth]{npp.jpg}
  \end{columns}
\end{block}
\pause

\begin{block}{Introduction to Computational Finance with \texttt{R}}
Good course by prof. Eric Zivot, with lots of \texttt{R} examples:
\hskip1em\url{https://www.datacamp.com/courses/computational-finance-and-financial-econometrics-with-r/}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Probability and Statistics}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Numbers}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Random number generators produce the same deterministic sequence of numbers after their \texttt{seed} value is reset,
      \vskip1ex
      The function \texttt{set.seed()} initializes the random number generator by specifying the \texttt{seed} value,
      \vskip1ex
      The function \texttt{runif()} produces random numbers from the uniform distribution,
      \vskip1ex
      The function \texttt{rnorm()} produces random numbers from the normal distribution,
      \vskip1ex
      The function \texttt{pnorm()} calculates the cumulative normal distribution,
      \vskip1ex
      The function \texttt{qnorm()} calculates the inverse cumulative normal distribution,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
set.seed(1121)  # initialize the random number generator
runif(3)  # three random numbers from the uniform distribution
runif(3)  # produce another three numbers
set.seed(1121)  # re-initialize the random number generator
runif(3)  # produce another three numbers

# produce random number from standard normal distribution
rnorm(1)
# produce five random numbers from standard normal distribution
rnorm(5)
# produce five random numbers from the normal distribution
rnorm(n=5, mean=1, sd=2)  # match arguments by name
# calculate cumulative standard normal distribution
c(pnorm(-2), pnorm(2))
# calculate inverse cumulative standard normal distribution
c(qnorm(0.75), qnorm(0.25))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Statistical Estimators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A data \emph{sample} is a set of data selected from a statistical population (distribution),
      \vskip1ex
      Let $\{x_{1},\ldots ,x_{n}\}$ be a data \emph{sample} from a given distribution,
      \vskip1ex
      A \emph{statistic} is a function of a data \emph{sample}:  $f( x_{1},\ldots ,x_{n} )$,
      \vskip1ex
      A \emph{statistic} is itself a \emph{random variable},
      \vskip1ex
      A statistical \emph{estimator} is a \emph{statistic} that provides an estimate of a \emph{distribution} parameter,
      \vskip1ex
      For example:
      \begin{displaymath}
        \bar{x}=\frac{1}{n}{\sum_{i=1}^{n}x_{i}}
      \end{displaymath}
      Is an \emph{estimator} of the \emph{mean} of the \emph{distribution},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2))>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
# sample from Standard Normal Distribution
rand_sample <- rnorm(1000)

mean(rand_sample)  # sample mean

median(rand_sample)  # sample median

sd(rand_sample)  # sample standard deviation
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Estimators of Moments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The estimators of moments of a probability distribution are given by:
      \vskip1ex
      Mean: $\bar{x}=\frac{1}{k} \sum_{i=1}^{k} x_{i}$
      \vskip1ex
      Variance: $\hat{\sigma}^2=\frac{1}{k-1} \sum_{i=1}^{k} (x_{i}-\bar{x})^2$
      \vskip1ex
      Skewness:
      \begin{displaymath}
        \hat{s}=\frac{k}{(k-1)(k-2)} \sum_{i=1}^{k} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^3
      \end{displaymath}
      Kurtosis:
      \begin{displaymath}
        \hat{k}=\frac{k(k+1)}{(k-1)^3} \sum_{i=1}^{k} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^4
      \end{displaymath}
      The normal distribution has zero skewness and kurtosis equal to 3,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
ts_rets <- diff(log(EuStockMarkets[, 1]))  # DAX returns
len_rets <- length(ts_rets)  # number of observations
mean_rets <- mean(ts_rets)  # calculate mean
sd_rets <- sd(ts_rets)  # calculate standard deviation
# calculate skew
len_rets*(sum(((ts_rets - mean_rets)/sd_rets)^3))/
  ((len_rets-1)*(len_rets-2))
# calculate kurtosis
len_rets*(len_rets+1)*(sum(((ts_rets - mean_rets)/sd_rets)^4))/
  ((len_rets-1)^3)
ts_rets <- rnorm(len_rets, sd=2)  # random normal returns
mean_rets <- mean(ts_rets); sd_rets <- sd(ts_rets)
# calculate skew
len_rets*(sum(((ts_rets - mean_rets)/sd_rets)^3))/
  ((len_rets-1)*(len_rets-2))
# calculate kurtosis
len_rets*(len_rets+1)*(sum(((ts_rets - mean_rets)/sd_rets)^4))/
  ((len_rets-1)^3)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Date and Time Objects}


%%%%%%%%%%%%%%%
\subsection{Date Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has a \texttt{Date} class for date objects (but without time),
      \vskip1ex
      The function \texttt{as.Date()} parses a \texttt{character} string into a date object,
      \vskip1ex
      \texttt{R} stores \texttt{Date} objects as the number of days since the \texttt{epoch} (January 1, 1970),
      \vskip1ex
      \texttt{Numeric} objects can be coerced to \texttt{Date} objects using the functions \texttt{attributes()} and \texttt{structure()},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
Sys.Date()  # get today's date
date_time <- as.Date("2014-07-14")  # "%Y-%m-%d" or "%Y/%m/%d"
date_time
class(date_time)  # Date object
as.Date("07-14-2014", "%m-%d-%Y")  # specify format
date_time + 20  # add 20 days
as.numeric(date_time)  # get internal integer representation
date_old <- as.Date("07/14/2013", "%m/%d/%Y")
date_old
# difference between dates
difftime(date_time, date_old, units="weeks")
weekdays(date_time)  # get day of the week
# coerce numeric into date-times
date_time <- 0
attributes(date_time) <- list(class="Date")
date_time  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{POSIXct} Date-time Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} has a class \texttt{POSIXct} for Date-time (date-time) objects,
      \vskip1ex
      The function \texttt{as.POSIXct()} parses a \texttt{character} string into a \texttt{POSIXct} object,
      \vskip1ex
      \texttt{format.POSIXct()} parses \texttt{POSIXct} objects to \texttt{character} strings,
      \vskip1ex
      \texttt{R} stores \texttt{POSIXct} objects as the number of seconds since the \texttt{epoch} (January 1, 1970 UTC),
      \vskip1ex
      \texttt{POSIX} is an acronym for "Portable Operating System Interface",
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
date_time <- Sys.time()  # get today's date and time
date_time
class(date_time)  # POSIXct object
as.numeric(date_time)  # get internal integer representation
# parse character string "%Y-%m-%d %H:%M:%S" to POSIXct object
as.POSIXct("2014-07-14 13:30:10")
format(date_time)  # convert POSIXct to character string
class(format(date_time))  # character string
date_time + 20  # add 20 seconds
as.POSIXct(as.Date(date_time)+1)  # add a day
trunc(date_time, units="hours")  # truncate to closest hour
as.POSIXct(as.character(as.Date(date_time)))  # truncate to closest day
methods(trunc)  # trunc methods
trunc.POSIXt
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{POSIXlt} Date-time Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} has a class \texttt{POSIXlt} for \emph{date-time} objects,
      \vskip1ex
      \texttt{R} stores \texttt{POSIXlt} objects as a list,
      \vskip1ex
      The function \texttt{as.POSIXlt()} parses a \texttt{character} string into a \texttt{POSIXlt} object,
      \vskip1ex
      \texttt{format.POSIXlt()} converts \texttt{POSIXlt} objects to \texttt{character} strings,
      \vskip1ex
      Adding a number to \texttt{POSIXlt} causes implicit coercion to \texttt{POSIXct},
      \vskip1ex
      \texttt{POSIXct} and \texttt{POSIXlt} are two derived classes of the more general \texttt{POSIXt} class,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
# parse character string "%Y-%m-%d %H:%M:%S" to POSIXlt object
date_time <- as.POSIXlt("2014-07-14 18:30:10")
date_time
class(date_time)  # POSIXlt object
aperm(as.matrix(unclass(date_time)))  # get internal representation

date_time + 20  # add 20 seconds
class(date_time + 20)  # implicit coercion to POSIXct
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Zones and Date-time Conversion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{date-time} objects require a time zone to be uniquely specified,
      \vskip1ex
      \texttt{UTC} stands for "Universal Time Coordinated", and is synonymous with \texttt{GMT}, but doesn't change with Daylight Saving Time,
      \vskip1ex
      \texttt{EST} stands for "Eastern Standard Time", \texttt{UTC} - 5 hours,
      \vskip1ex
      \texttt{EDT} stands for "Eastern Daylight Time", \texttt{UTC} - 4 hours,
      \vskip1ex
      The function \texttt{Sys.setenv()} can be used to set the default time zone,
      \vskip1ex
      \texttt{format()} converts \emph{date-time} objects to \texttt{character} strings, given a time zone,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<>>=
Sys.timezone()  # get time-zone
Sys.setenv(tz="UTC")  # set time-zone to UTC
Sys.timezone()  # get time-zone
# Standard Time in effect
as.POSIXct("2013-03-09 11:00:00", tz="America/New_York")
# Daylight Savings Time in effect
as.POSIXct("2013-03-10 11:00:00", tz="America/New_York")
date_time <- Sys.time()  # today's date and time
# convert to character in different TZ
format(date_time, tz="America/New_York")
format(date_time, tz="UTC")
# parse back to POSIXct
as.POSIXct(format(date_time, tz="America/New_York"))
# difference between local time and UTC
as.POSIXct(format(Sys.time(), tz="UTC")) - 
  as.POSIXct(format(Sys.time(), tz="America/New_York"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Review of Date-time Classes in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{Date} class from the \texttt{base} package is suitable for \emph{daily} time series,
      \vskip1ex
      The \texttt{POSIXct} class from the \texttt{base} package is suitable for \emph{intra-day} time series,
      \vskip1ex
      The \texttt{yearmon} and  \texttt{yearqtr} classes from the \texttt{zoo} package are suitable for \emph{quarterly} and \emph{monthly} time series,
    \column{0.7\textwidth}
      \vspace{-2em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
date_time <- Sys.Date()  # create date series of class 'Date'
date_index <- date_time + 0:365  # daily series over one year
head(date_index, 4)  # print first few dates
format(head(date_index, 4), "%m/%d/%Y")  # print first few dates
# create daily date-time series of class 'POSIXct'
date_index <- seq(Sys.time(), by="days", length.out=365)
head(date_index, 4)  # print first few dates
format(head(date_index, 4), "%m/%d/%Y %H:%M:%S")  # print first few dates
# create series of monthly dates of class 'zoo'
monthly_index <- yearmon(2010+0:36/12)
head(monthly_index, 4)  # print first few dates
# create series of quarterly dates of class 'zoo'
qrtly_index <- yearqtr(2010+0:16/4)
head(qrtly_index, 4)  # print first few dates
# parse quarterly 'zoo' dates to POSIXct
Sys.setenv(tz="UTC")
as.POSIXct(head(qrtly_index, 4))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Time Series Objects}


%%%%%%%%%%%%%%%
\subsection{\texttt{ts} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{stats} package contains functions for manipulating time series objects of class \texttt{ts},
        \vspace{-1em}
        <<ts_obj,echo=(-(1:2)),fig.show='hide'>>=
set.seed(1121)  # for reproducibility
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# create monthly time series starting 1990
ts_series <- ts(data=cumsum(rnorm(96)), 
             frequency=12, start=c(1990, 1))
class(ts_series)  # class 'ts'
attributes(ts_series)
matrix(methods(class="ts")[3:8], ncol=2)
# window the time series
window(ts_series, start=1992, end=1992.25)

plot(ts_series, type="l",  # create plot
     col="red", lty="solid", xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ts_obj-1}
      \vspace{-5em}
      The function \texttt{ts()} creates a \texttt{ts} time series object from a \texttt{numeric} vector or matrix containing the values, and associated \emph{date-time} information (the number of years),
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{EuStockMarkets}
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Data}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} includes a number of 'base' packages that are already installed and loaded,
      \vskip1ex
      \texttt{datasets} is a base package containing various datasets, for example \texttt{EuStockMarkets},
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices,
        <<eustx_ts,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
class(EuStockMarkets)  # multiple ts object
dim(EuStockMarkets)
head(EuStockMarkets, 3)  # get first three rows
# plot all the columns
plot(EuStockMarkets, main="", xlab="")
# add title
title(main="EuStockMarkets", line=-1)
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Distribution of \subsecname \hskip0.5em Returns}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{hist()} calculates and plots a histogram,
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      The function \texttt{density()} calculates a kernel estimate of the probability density,
      \vskip1ex
      The function \texttt{lines()} draws a line through specified points,
        \vspace{-1em}
        <<eustx_rets,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate DAX percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# mean and standard deviation of returns
c(mean(dax_rets), sd(dax_rets))
# plot histogram
hist(dax_rets, breaks=30, main="", 
     xlim=c(-0.04, 0.04), ylim=c(0, 60), 
     xlab="", ylab="", freq = FALSE)
# draw kernel density of histogram
lines(density(dax_rets), col='red', lwd=2)
# add density of normal distribution
curve(expr=dnorm(x, mean=mean(dax_rets), sd=sd(dax_rets)), 
      add=TRUE, type="l", lwd=2, col="blue")
title(main="Return distributions", line=0)  # add title
# add legend
legend("topright", inset=0.05, cex=0.8, title=NULL, 
       leg=c(colnames(EuStockMarkets)[1], "Normal"), 
       lwd=2, bg="white", col=c("red", "blue"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_rets-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Quantile-Quantile Plot}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \texttt{Q-Q} plot is a plot of points from two probability distributions with the same quantiles,
      \vskip1ex
      The function \texttt{qqnorm()} produces a normal Q-Q plot,
      \vskip1ex
      The function \texttt{qqline()} fits a line to the normal quantiles,
      \vskip1ex
      The \texttt{DAX} Q-Q plot shows that the \texttt{DAX} return distribution has fat tails,
        <<eustx_qq,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# create normal Q-Q plot
qqnorm(dax_rets, ylim=c(-0.04, 0.04), 
       xlab='Normal Quantiles', main='')
# fit a line to the normal quantiles
qqline(dax_rets, col='red', lwd=2)
plot_title <- paste(colnames(EuStockMarkets)[1], 
                  'Q-Q Plot')
title(main=plot_title, line=-1)  # add title
shapiro.test(dax_rets)  # Shapiro-Wilk test
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_qq-1}
      \vskip2ex
      The \emph{p}-value of the \emph{Shapiro-Wilk} test is very small, which shows that the \texttt{DAX} returns are not normal,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Boxplots}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{Box Plot} (box-and-whisker plot) is a graphical display of a distribution of values,
      \vskip1ex
      The \emph{box} represents the upper and lower quartiles, \\
      the vertical lines (whiskers) represent values beyond the quartiles, \\
      and open circles represent values beyond the nominal range (outliers),
      \vskip1ex
      The function \texttt{boxplot()} plots a box-and-whisker plot for a distribution of values,
      \vskip1ex
      \texttt{boxplot()} has two \texttt{methods}: one for \texttt{formula} objects (involving categorical variables), and another for \texttt{data frames},
      <<box_plots,echo=(-(1:2)),fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(1.5, 0.5, 0), mar=c(2.5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# boxplot method for formula
boxplot(formula=mpg ~ cyl, data=mtcars, 
        main="Mileage by number of cylinders", 
        xlab="Cylinders", ylab="Miles per gallon")

# calculate EuStockMarkets percentage returns
eu_rets <- diff(log(EuStockMarkets))
# boxplot method for data frame
boxplot(x=eu_rets)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/box_plots-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} is designed for managing \emph{time series} and ordered objects,
      \vskip1ex
      The function \texttt{zoo()} creates a \texttt{zoo} object from a \texttt{numeric} vector or matrix, and an associated \emph{date-time} index,
      \vskip1ex
      The \texttt{zoo()} index is a vector of \emph{date-time} objects, and can be from any \emph{date-time} class,
      <<zoo_ts,echo=(-(1:2)),fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create index of daily dates
date_index <- seq(from=as.Date("2014-07-14"), 
                  by="day", length.out=1000)
# create zoo time series
zoo_series <- zoo(cumsum(rnorm(length(date_index))), 
                  order.by=date_index)

class(zoo_series)  # class 'zoo'
tail(zoo_series, 4)  # get last few elements

# call plot.zoo
plot(zoo_series, xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operations on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{coredata()} extracts the data contained in \texttt{zoo} object, and returns a vector or matrix,
      \vskip1ex
      The function \texttt{index()} extracts the time index of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{start()} and \texttt{end()} return the time index values of the first and last elements of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{cumsum()}, \texttt{cummax()}, and \texttt{cummin()} return cumulative sums, minima and maxima of a \texttt{zoo} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:3
zoo_series <- zoo(rnorm(length(date_index)), 
               order.by=date_index)
zoo_series
index(zoo_series)  # extract time index
coredata(zoo_series)  # extract coredata
zoo_series[start(zoo_series)]  # first element
zoo_series[end(zoo_series)]  # last element
coredata(zoo_series) <- rep(1, 4)  # replace coredata
cumsum(zoo_series)  # cumulative sum
cummax(cumsum(zoo_series))
cummin(cumsum(zoo_series))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lag()} and \texttt{diff()} Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lag()} returns a lagged version of a time series, shifting the time index back by a given number of observations,
      \vskip1ex
      The function \texttt{diff()} returns the difference between a time series and its lagged version, 
      \vskip1ex
      For \texttt{zoo} objects, both these functions omit any \texttt{NA} values they may have produced,
    \column{0.6\textwidth}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
coredata(zoo_series) <- 1:4  # replace coredata
zoo_series
diff(zoo_series)  # diff with one day lag
lag(zoo_series, 2)  # two day lag
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Sequential Joining \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be joined sequentially using \texttt{rbind},
      <<zoo_join_seq,echo=(-(1:2)),fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily date series of class 'Date'
date_index1 <- seq(Sys.Date(), by="days", 
                   length.out=365)
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
                 order.by=date_index1)
# create another zoo time series
date_index2 <- seq(Sys.Date()+350, by="days", 
                   length.out=365)
zoo_series2 <- zoo(rnorm(length(date_index2)), 
                 order.by=date_index2)
# rbind the two time series - ts1 supersedes ts2
zoo_series3 <- rbind(zoo_series1,
                 zoo_series2[index(zoo_series2) > end(zoo_series1)])
plot(cumsum(zoo_series3), xlab="", ylab="")
# add vertical lines at stitch point
abline(v=end(zoo_series1), col="blue", lty="dashed")
abline(v=start(zoo_series2), col="red", lty="dashed")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_join_seq-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Merging \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{zoo} time series can be combined concurrently by joining their columns using \texttt{merge()},
      \vskip1ex
      \texttt{merge()} is similar to \texttt{cbind()},
      \vskip1ex
      If the \texttt{all=TRUE} option is set, then \texttt{merge()} returns the union of their dates, otherwise it returns their intersection,
      \vskip1ex
      The \texttt{merge()} operation can produce \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
# create daily date series of class 'Date'
date_index1 <- Sys.Date() + -3:1
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
               order.by=date_index1)
# create another zoo time series
date_index2 <- Sys.Date() + -1:3
zoo_series2 <- zoo(rnorm(length(date_index2)), 
               order.by=date_index2)
merge(zoo_series1, zoo_series2)  # union of dates
# intersection of dates
merge(zoo_series1, zoo_series2, all=FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for NA and NaN values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove NAs from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, NaN, 0/0, 1/0))  # test for NA
is.nan(c(NA, NaN, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
bad_data <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
mean(bad_data)  # returns NA, when NAs are input
mean(bad_data, na.rm=TRUE)  # remove NAs from input data
bad_data[!is.na(bad_data)]  # delete the NA values
sum(!is.na(bad_data))  # count non-NA values
      @
  \end{columns}
\end{block}

\begin{block}{}
  \texttt{NULL} isn't bad data, but is a reserved word and represents a null object,\\
  \texttt{NULL} is returned by functions whose value is undefined,\\
  Very often variables are initialized to \texttt{NULL} before iteration,\\
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
head(airquality[!complete.cases(airquality), ])  # display some NAs
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from library \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
good_air <- airquality[complete.cases(airquality), ]  # remove NAs
dim(good_air)
head(good_air)  # NAs removed
library(zoo)  # load package zoo
good_air <- na.locf(airquality)  # replace NAs
dim(good_air)
head(good_air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Managing \texttt{NA} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Operations on time series can produce \texttt{NA} values,
      \vskip1ex
      There are two dedicated functions for managing \texttt{NA} values in time series: 
      \begin{itemize}
        \item \texttt{na.omit()} removes observations containing \texttt{NA} values,
        \item \texttt{na.locf()} carries the last non-\texttt{NA} observation forward,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
# create zoo time series
zoo_series <- zoo(sample(4), 
                  order.by=(Sys.Date() + 0:3))
# add NA
zoo_series[3] <- NA
zoo_series

na.locf(zoo_series)  # replace NA's using locf

na.omit(zoo_series)  # remove NA's using omit
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Aggregating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{aggregate()} performs temporal aggregations of \texttt{zoo} objects,
      <<zoo_agg,echo=(-(1:6)),fig.show='hide'>>=
set.seed(1121)  # for reproducibility
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:365
zoo_series <- zoo(rnorm(length(date_index)), order.by=date_index)
# create monthly dates
dates_agg <- as.Date(as.yearmon(index(zoo_series)))
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using locf
zoo_agg <- na.locf(zoo_agg)
# extract aggregated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and aggregated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Aggregated Prices", 
       leg=c("orig prices", "agg prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_agg-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpolating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has two functions for replacing \texttt{NA} values using interpolation:
      \begin{itemize}
        \item \texttt{na.approx()} performs linear interpolation,
        \item \texttt{na.spline()} performs spline interpolation,
      \end{itemize}
      \vspace{-1em}
      <<zoo_interpol,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using linear interpolation
zoo_agg <- na.approx(zoo_agg)
# extract interpolated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Interpolated Prices", 
       leg=c("orig prices", "interpol prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_interpol-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Rolling Functions on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has several functions for rolling calculations:
      \begin{itemize}
        \item \texttt{rollapply()} applying function to rolling margins,
        \item \texttt{rollmean()} calculate rolling means,
        \item \texttt{rollmedian()} calculate rolling median,
        \item \texttt{rollmax()} calculate rolling max,
      \end{itemize}
      \vspace{-1em}
      <<zoo_roll,echo=(-1),fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_mean <- rollapply(zoo_series, width=11, FUN=mean)
# merge with original zoo - union of dates
zoo_mean <- merge(zoo_series, zoo_mean)
# replace NA's using na.locf
zoo_mean <- na.locf(zoo_mean, fromLast=TRUE)
# extract mean zoo
zoo_mean <- zoo_mean[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_mean), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Mean Prices", 
       leg=c("orig prices", "mean prices"), lwd=2, bg="white", 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_roll-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Time Series Objects Into \texttt{zoo}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The generic function \texttt{as.zoo()} converts objects into \texttt{zoo} time series,
      \vskip1ex
      Coercing a \texttt{ts} time series creates a \texttt{zoo} object with a \texttt{numeric} \emph{date-time} index, with \emph{date-time} encoded as a \emph{year-fraction},
      \vskip1ex
      The \emph{year-fraction} can be \emph{approximately} converted to a \texttt{Date} object by first calculating the number of days since the \texttt{epoch} (\texttt{1970}), and then coercing the \texttt{numeric} days using \texttt{as.Date()},
      \vskip1ex
      The function \texttt{date\_decimal()} from package \texttt{lubridate} converts \texttt{numeric} objects into \texttt{POSIXct} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:3))>>=
library(lubridate)  # load lubridate
library(zoo)  # load package zoo
# methods(as.zoo)  # many methods of coercing into zoo
class(EuStockMarkets)  # multiple ts object
# convert mts object into zoo
zoo_series <- as.zoo(EuStockMarkets)
class(index(zoo_series))  # index is numeric
head(zoo_series, 3)
# approximately convert index into class 'Dates'
index(zoo_series) <- as.Date(365*(index(zoo_series)-1970))
head(zoo_series, 3)
# convert index into class 'Dates'
zoo_series <- as.zoo(EuStockMarkets)
index(zoo_series) <- date_decimal(index(zoo_series))
head(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package \texttt{tseries} for Time Series Analysis}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<tseries_intro,echo=(-1),eval=FALSE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(tseries)  # load package tseries
zoo_msft <- suppressWarnings(  # load MSFT data
  get.hist.quote(instrument="MSFT", 
                 start=Sys.Date()-365, 
                 end=Sys.Date(), 
                 origin="1970-01-01")
)  # end suppressWarnings
class(zoo_msft)
dim(zoo_msft)
tail(zoo_msft, 4)

# calculate Sharpe ratio
sharpe(zoo_msft[, "Close"], r=0.01)
# add title
plot(zoo_msft[, "Close"], xlab="", ylab="")
title(main="MSFT Close Prices", line=-1)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/tseries_intro-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading Time Series Data Using Package \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<zoo_plot_2y,echo=(-(1:2)),eval=FALSE,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(tseries)  # load package tseries
zoo_eurusd <- suppressWarnings(  # load EUR/USD data
  get.hist.quote(
    instrument="EUR/USD", provider="oanda",
    start=Sys.Date()-365, 
    end=Sys.Date(), 
    origin="1970-01-01")
)  # end suppressWarnings
# bind and scrub data
zoo_msfteur <- merge(zoo_eurusd, 
                     zoo_msft[, "Close"])
colnames(zoo_msfteur) <- c("EURUSD", "MSFT")
zoo_msfteur <- 
  zoo_msfteur[complete.cases(zoo_msfteur),]
### plot with two "y" axes
par(las=1)  # set text printing to "horizontal"
# plot first ts
plot(zoo_msfteur[, 1], xlab=NA, ylab=NA)
# set range of "y" coordinates for second axis
par(usr=c(par("usr")[1:2], range(zoo_msfteur[,2])))
lines(zoo_msfteur[, 2], col="red")  # second plot
axis(side=4, col="red")  # second "y" axis on right
# print axis labels
mtext(colnames(zoo_msfteur)[1], side=2, padj=-6, line=-4)
mtext(colnames(zoo_msfteur)[2], col="red", side=4, padj=-2, line=-3)
title(main="EUR and MSFT")  # add title
# add legend without box
legend("bottomright", legend=colnames(zoo_msfteur), bg="white", 
       lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")

save(zoo_msft, zoo_eurusd, file="C:/Develop/data/zoo_data.RData")

##########

# slightly different method using par(new=TRUE)
# par(las=1)  # set text printing to "horizontal"
# plot(zoo_msfteur[, 1], xlab=NA, ylab=NA)
# par(new=TRUE)  # allow new plot on same chart
# plot(zoo_msfteur[, 2], xlab=NA, ylab=NA, yaxt="n", col="red")
# axis(side=4, col="red")  # second "y" axis on right
# mtext(colnames(zoo_msfteur)[1], side=2, padj=-6, line=-4)
# mtext(colnames(zoo_msfteur)[2], col="red", side=4, padj=-2, line=-3)
# title(main="EUR and MSFT", line=-1)  # add title
# legend("bottomright", legend=colnames(zoo_msfteur), 
#        lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")

##########

# "x" axis with monthly ticks - doesn't work
# plot first ts wthout "x" axis
# plot(zoo_msfteur[, 1], xaxt="n", xlab=NA, ylab=NA)
# # add "x" axis with monthly ticks
# month.ticks <- unique(as.yearmon(index(zoo_eurusd)))
# axis(side=1, at=month.ticks, labels=format(month.ticks, "%b-%y"), tcl=-0.7)

      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_plot_2y-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Series Classes in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has a number of different time series classes:
      \begin{itemize}
        \item Class \texttt{"ts"} from base package \texttt{stats},
        \item Class \texttt{"zoo"} ordered observations,
        \item Class \texttt{"xts"} extension of \texttt{zoo} class,
        \item Class \texttt{"timeSeries"} from the \emph{Rmetrics} suite,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
load(file="C:/Develop/data/zoo_data.RData")
ts_msft <- as.ts(zoo_msft)
class(ts_msft)
# rename colnames
colnames(ts_msft) <- paste0("MSFT.", colnames(ts_msft))
tail(ts_msft)

library(timeSeries)
tser_msft <- as.timeSeries(zoo_msft)
class(ts_msft)
tail(tser_msft)
      @
  \end{columns}
\end{block}

\end{frame}




%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  TBA
\end{block}

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 1-3: \fullcite{website:rintro}
    \item Read chapters 1, 2, 11: \citetitle{matloffbook}
    \item Read: \fullcite{website:googlestyler}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
