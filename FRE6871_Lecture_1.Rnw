% FRE6871_Lecture_1
% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
\usepackage{listings}
\usepackage{xcolor}
\definecolor{anti_flashwhite}{rgb}{0.95, 0.95, 0.96}
\definecolor{cmd_background}{rgb}{0.2, 0.2, 0.0}
\definecolor{vba_background}{rgb}{0.0, 0.0, 0.9}
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture\#1]{FRE6871 \texttt{R} in Finance}
\subtitle{Lecture\#1, Spring 2019}

\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@nyu.edu}
\date{September 10, 2018}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Course Description and Objectives}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Course Description}
The course will study the applications of the \texttt{R} statistical language to financial data analysis and modeling.
The applications will include \emph{classification} for credit scoring, \emph{Monte Carlo simulation} for option pricing and credit portfolio modeling, and \emph{Principal Component Analysis} (\emph{PCA}) for interest rate yield curve modeling.
The course will apply statistical techniques, such as \emph{hypothesis testing}. \emph{linear regression}, \emph{logistic regression}, and \emph{bootstrap simulation}.
\end{block}
\pause

\begin{block}{Course Objectives}
Students will learn through \texttt{R} coding exercises how to:\\
\hskip1em - Manipulate data structures (vectors, data frames, dates, and time series).\\
\hskip1em - Download data from external sources, and to scrub and format it.\\
\hskip1em - Create interactive plots and visualizations.\\
\hskip1em - Build financial models.\\
\hskip1em - Perform exception and error handling, and debugging.\\
\end{block}
\pause

\begin{block}{Course Prerequisites}
The \texttt{R} language is considered to be challenging, so this course requires some programming experience with other languages such as \texttt{C++} or \texttt{Python}.  Students should also have knowledge of basic statistics (random variables, estimators, hypothesis testing, regression, etc.)
The course \emph{FRE7241 Algorithmic Portfolio Management} is designed as a followup course to \emph{FRE6871}.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Homeworks and Tests}
Grading will be based on homeworks and in-class tests.  There will be no final exam.
      \vskip1ex
The tests will require writing code, which should run directly when pasted into an \texttt{R} session, and should produce the required output, without any modifications.
      \vskip1ex
Students will be allowed to consult course slides, and to copy code from them, and to copy from books or any online sources, but they will be required to provide references to those external sources (such as links or titles and page numbers).
      \vskip1ex
The tests will be closely based on code contained in the course slides, so students are encouraged to become very familiar with those slides.
      \vskip1ex
Students will submit their homework and test files only through \emph{NYU Classes} (not emails).
      \vskip1ex
Students will be required to bring their laptop computers to class and run the \texttt{R} Interpreter, and the \texttt{RStudio} Integrated Development Environment (\emph{IDE}), during the lecture.
      \vskip1ex
Homeworks will also include reading assignments designed to help prepare for tests.
\end{block}
\pause

\begin{block}{Graduate Assistant}
The graduate assistant (GA) will be announced.\\
% Anshuang Fu \href{af3007@nyu.edu}{af3007@nyu.edu}.\\
The GA will answer questions during office hours, or via \emph{NYU Classes} forums, not via emails.  Please send emails regarding lecture matters from \emph{NYU Classes} (not personal emails).
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Tips for Solving Homeworks and Tests}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
  \begin{block}{Tips for Solving Homeworks and Tests}
    The tests will require mostly copying code samples from the course slides, making some modifications to them, and combining them with other code samples,
    \vskip1ex
    Partial credit will be given even for code that doesn't produce the correct output, but that has elements of code that can be useful for producing the right answer,
    \vskip1ex
    So don't leave test assignments unanswered, and instead copy any code samples from the course slides that are related to the solution and make sense,
    \vskip1ex
    Contact the GA during office hours via text or phone, and submit questions to the GA or to me via \emph{NYU Classes}, 
  \end{block}
\pause
  \begin{block}{Please Submit \emph{Minimal Working Examples} With Your Questions}
    When submitting questions, students should provide a \emph{minimal working example} that produces the error in \texttt{R}, with the following items:
      \begin{itemize}
        \item The \emph{complete} \texttt{R} code that produces the error, including the seed value for random numbers,
        \item The version of \texttt{R} (output of command: \texttt{sessionInfo()}), and the versions of \texttt{R} packages, 
        \item The type and version of your operating system (Windows or OSX),
        \item The dataset file used by the \texttt{R} code,
        \item The text or screenshots of error messages,
      \end{itemize}
    \vskip1ex
    You can read more about producing \emph{minimal working examples} here:
      \url{http://stackoverflow.com/help/mcve}\\
      \url{http://www.jaredknowles.com/journal/2013/5/27/writing-a-minimal-working-example-mwe-in-r}
  \end{block}
\end{frame}


%%%%%%%%%%%%%%%
\subsection{Course Grading Policies}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Numerical Scores}
  Homeworks and tests will be graded and assigned numerical scores.  
  Each part of homeworks and tests will be graded separately and assigned a numerical score.\\
  Maximum scores will be given only for complete code, that produces the correct output when it's pasted into an \texttt{R} session, without any modifications. 
  As long as the \texttt{R} code uses the required functions and produces the correct output, it will be given full credit.\\
  Partial credit will be given even for code that doesn't produce the correct output, but that has elements of code that can be useful for producing the right answer.
\end{block}
\pause

\begin{block}{Plagiarism}
  Plagiarism (copying from other students) and cheating will be punished.\\
  But copying code from course slides, books, or any online sources is allowed and encouraged.\\
  Students must provide references to any external sources from which they copy code (such as links or titles and page numbers).
\end{block}
\pause

\begin{block}{Letter Grades}
  Letter grades for the course will be derived from the cumulative scores obtained for all the homeworks and tests.  Very high numerical scores close to the maximum won't guarantee an A letter grade, since grading will also depend on the difficulty of the assignments.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Course Materials}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Course Slides}
The course will be mostly self-contained, using detailed course slides containing extensive, working \texttt{R} code examples.\\
The course will also utilize data and tutorials which are freely available on the internet.
\end{block}
\pause

\begin{block}{FRE6871 Recommended Textbooks}
\begin{itemize}[]
  \item There will be no required textbook, but a recommended textbook is \emph{"The Art of R Programming"} (you can download it for free):\\
  \fullcite{matloffbook}
  \item The \emph{"Statistical Learning"} book introduces machine learning techniques using \texttt{R} - it's a must have for advanced finance applications (you can download it for free):\\
  \fullcite{islbook}
  \item \emph{"Advanced \texttt{R}"} is the best book for learning the advanced features of \texttt{R}:\\
  \fullcite{hadleybook}
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Supplementary Textbooks}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{Supplementary Textbooks}
\begin{itemize}[]
  \item \emph{"\texttt{R} in Action"} is a good introduction to \texttt{R} and to statistical models:\\
  \fullcite{kabacoffbook}
  \item \emph{"\texttt{R} for Everyone"} is a good introduction to \texttt{R} and to statistical models:\\
  \fullcite{landerbook}
  \item \emph{"Applied Econometrics"} introduces advanced statistical models and econometrics:\\
  \fullcite{kleiberbook}
  \item \emph{"Numerical Recipes"} is a great reference for linear algebra and numerical methods, implemented in working \texttt{C++} code:\\
  \fullcite{numrecipesbook}
\end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{FRE6871 Supplementary Materials}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{Notepad++} is a free source code editor for \texttt{MS Windows}, that supports several programming languages, including \texttt{R}. 
      \vskip1ex
      \texttt{Notepad++} has a very convenient and fast \emph{search and replace} function, that allows \emph{search and replace} in multiple files.\\
      \hskip1em\url{http://notepad-plus-plus.org/}
    \column{0.3\textwidth}
      \includegraphics[height=0.5\textwidth]{image/npp.jpg}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{\texttt{R} Help and Documentation}


%%%%%%%%%%%%%%%
\subsection{Internal \texttt{R} Help and Documentation}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{help()} displays documentation on a function or subject,\\
      \vskip1ex
      Preceding the keyword with a single \texttt{"?"} is equivalent to calling \texttt{help()},
    \column{0.5\textwidth}
      \vspace{-1em}
% tidy=FALSE prevents translation of "?getwd" into "`?`(getwd)"
      <<eval=FALSE>>=
# display documentation on function "getwd"
help(getwd)
?getwd  # equivalent to "help(getwd)"
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{help.start()} displays a page with links to internal documentation,
      \vskip1ex
      \texttt{R} documentation is also available in \texttt{RGui} under the help tab,
      \vskip1ex
      The \emph{pdf} files with \texttt{R} documentation are also available directly under:\\
%      \texttt{\color{blue}{C:/Program Files/R/R-3.1.2/bin/x64}}\\
      \href{C:/Program Files/R/R-3.1.2/doc/manual/}{C:/Program Files/R/R-3.1.2/doc/manual/}\\
      (the exact path will depend on the \texttt{R} version.)
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
help.start()  # open the hypertext documentation
      @
      \vskip1ex
      \includegraphics[height=0.2\textwidth]{image/Rlogo.jpg}
  \end{columns}
\end{block}

\begin{block}{}
  "Introduction to \texttt{R}" by Venables and \texttt{R} Core Team:\\
  \fullcite{website:rintro}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Help and Documentation}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{\texttt{R} Cheat Sheets}
  \emph{Cheat Sheets} are a fast way to find what you want\\
  \hskip1em\url{https://www.rstudio.com/resources/cheatsheets/
}
\end{block}

\begin{block}{\texttt{R} Programming \texttt{Wikibook}}
  \texttt{Wikibooks} are crowdsourced textbooks\\
  \hskip1em\url{http://en.wikibooks.org/wiki/R_Programming/}\\
\end{block}

\begin{block}{\texttt{R FAQ}}
  Frequently Asked Questions about \texttt{R}\\
  \hskip1em\url{http://cran.r-project.org/doc/FAQ/R-FAQ.html}\\
\end{block}

\begin{block}{\texttt{R}-seek Online Search Tool}
  \texttt{R}-seek allows online searches specific to the \texttt{R} language\\
  \hskip1em\url{http://www.rseek.org/}
\end{block}

\begin{block}{\texttt{R}-help Mailing List}
  \texttt{R}-help is a very comprehensive Q\&A mailing list\\
  \hskip1em\url{https://stat.ethz.ch/mailman/listinfo/r-help}\\
  \texttt{R}-help has archives of past Q\&A - search it before you ask\\
  \hskip1em\url{https://stat.ethz.ch/pipermail/r-help/}\\
  GMANE allows searching the \texttt{R}-help archives using a usenet newsgroup style GUI\\
  \hskip1em\url{http://news.gmane.org/gmane.comp.lang.r.general}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Style Guides}
\begin{frame}[t]{\subsecname}
\vspace{-1em}

\begin{block}{DataCamp \texttt{R} style guide}
  The DataCamp \texttt{R} style guide is very close to what I have adopted:\\
  \hskip1em\href{https://www.datacamp.com/teach/documentation\#tab_style_guide_r}{DataCamp R style guide}
\end{block}

\begin{block}{Google \texttt{R} style guide}
  The Google \texttt{R} style guide is similar to DataCamp's:\\
  \hskip1em\href{https://google.github.io/styleguide/Rguide.xml}{Google R style guide}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Stack Exchange}
\begin{frame}[t]{\subsecname}

\begin{columns}[T]
  \column{0.5\textwidth}
    \begin{block}{Stack Overflow}
      Stack Overflow is a Q\&A forum for computer programming, and is part of Stack Exchange\\
%  Stack Overflow is a Q\&A forum for programmers (covers many different languages)\\
      \hskip1em\url{http://stackoverflow.com}\\
      \hskip1em\url{http://stackoverflow.com/questions/tagged/r}\\
      \hskip1em\url{http://stackoverflow.com/tags/r/info}\\
    \end{block}

    \begin{block}{Stack Exchange}
      Stack Exchange is a family of Q\&A forums in a variety of fields\\
      \hskip1em\url{http://stackexchange.com/}\\
      \hskip1em\url{http://stackexchange.com/sites\#technology}\\
      \hskip1em\url{http://quant.stackexchange.com/}\\
    \end{block}
  \column{0.5\textwidth}
    \includegraphics[height=0.9\textwidth]{image/stack_exchange2.png}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{RStudio} Support}
\begin{frame}[t]{\subsecname}

\begin{block}{}
\emph{RStudio} has extensive online help, Q\&A database, and documentation\\
\hskip1em\url{https://support.rstudio.com/hc/en-us}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200107586-Using-RStudio}\\
\vskip1ex
\hskip1em\url{https://support.rstudio.com/hc/en-us/sections/200148796-Advanced-Topics}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Books and Courses}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{Companion website to the book \emph{"Advanced \texttt{R}"} by Hadley Wickham - chief scientist at \emph{RStudio}}
The best book for learning the advanced features of \texttt{R}:
\hskip1em\url{http://adv-r.had.co.nz/}
\end{block}

\begin{block}{Endmemo web book}
Good, but not interactive:
\hskip1em\url{http://www.endmemo.com/program/R/}
\end{block}

\begin{block}{Quick-R by Robert Kabacoff}
Good, but not interactive:
\hskip1em\url{http://www.statmethods.net/}
\end{block}

\begin{block}{\texttt{R} for Beginners by Emmanuel Paradis}
Good, basic introduction to \texttt{R}:
\hskip1em\url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf}
\end{block}

\begin{block}{Cookbook for \texttt{R} by Winston Chang from \emph{RStudio}}
Good plotting, but not interactive:
\hskip1em\url{http://www.cookbook-r.com/}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Online Interactive Courses}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{Datacamp Interactive Courses}
  Datacamp introduction to \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/courses/introduction-to-r/}
  \vskip1ex
  Datacamp list of free courses:
  \hskip1em\url{https://www.datacamp.com/community/open-courses}
  \vskip1ex
  Datacamp basic statistics in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/basic-statistics}
  \vskip1ex
  Datacamp computational finance in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/computational-finance-and-financial-econometrics-with-r}
  \vskip1ex
  Datacamp machine learning in \texttt{R}:
  \hskip1em\url{https://www.datacamp.com/community/open-courses/kaggle-r-tutorial-on-machine-learning}
\end{block}

\begin{block}{Try \texttt{R}}
  Interactive \texttt{R} tutorial, but rather basic:
  \hskip1em\url{http://tryr.codeschool.com/}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Blogs and Experts}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{R-Bloggers}
R-Bloggers is an aggregator of blogs dedicated to \texttt{R}\\
\hskip1em\url{http://www.r-bloggers.com/}\\
Tal Galili is the author of R-Bloggers and has his own excellent blog\\
\hskip1em\url{http://www.r-statistics.com/}\\
\end{block}

\begin{block}{Dirk Eddelbuettel}
Dirk is a \emph{Top Answerer} for \texttt{R} questions on Stackoverflow, the author of the \texttt{Rcpp} package, and the CRAN Finance View\\
\hskip1em\url{http://dirk.eddelbuettel.com/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/code/}\\
\hskip1em\url{http://dirk.eddelbuettel.com/blog/}\\
\hskip1em\url{http://www.rinfinance.com/}\\
\end{block}

\begin{block}{Romain Frangois}
Romain is an \texttt{R} Enthusiast and \texttt{Rcpp} Hero\\
\hskip1em\url{http://romainfrancois.blog.free.fr/}\\
\hskip1em\url{http://romainfrancois.blog.free.fr/index.php?tag/graphgallery}\\
\hskip1em\url{http://blog.r-enthusiasts.com/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{More \subsecname}

\begin{block}{Revolution Analytics Blog}
\texttt{R} blog by Revolution Analytics software vendor\\
\hskip1em\url{http://blog.revolutionanalytics.com/}\\
\end{block}

\begin{block}{\emph{RStudio} Blog}
\texttt{R} blog by \emph{RStudio}\\
\hskip1em\url{http://blog.rstudio.org/}\\
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{GitHub} for Hosting Software Projects Online}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{GitHub} is an internet-based online service for hosting repositories of software projects,
      \vskip1ex
      \emph{GitHub} provides version control using \emph{git} (designed by Linus Torvalds),
      \vskip1ex
      Most \texttt{R} projects are now hosted on \emph{GitHub},
      \vskip1ex
      \emph{Google} uses \emph{GitHub} to host its \emph{tensorflow} library for machine learning:\\
      \hskip1em\url{https://github.com/tensorflow/tensorflow}
      \vskip1ex
      All the \emph{FRE-7241} and \emph{FRE-6871} lectures are hosted on \emph{GitHub}:\\
      \hskip1em\url{https://github.com/algoquant/lecture_slides}\\
      \hskip1em\url{https://github.com/algoquant}
      \vskip1ex
      Hosting projects on \emph{Google} is a great way to advertize your skills and network with experts,
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{image/github_algoquant.png}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Getting Started With \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{What is \texttt{R}?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \begin{itemize}
      \item Is an open-source software environment for statistical computing and graphics,
      \item Is an interpreted language, allowing interactive code development,
      \item Is a functional language where every operator is an \texttt{R} function,
      \item Supports object-oriented programming with \emph{classes} and \emph{methods},
      \item Is a very expressive language that allows performing complex operations with very few lines of code,
      \item Has metaprogramming facilities that allow programming on the language,
      \item Is written in \texttt{R} itself and in \texttt{C/C++},
      \item Has vectorized functions written in \texttt{C/C++}, allowing very fast execution of loops over vector elements,
      \item Is extended through user-created \emph{packages} (function libraries), providing for the latest developments, such as \emph{Machine Learning},
    \end{itemize}
    \hskip1em\url{http://www.r-project.org/}\\
    \hskip1em\url{http://en.wikipedia.org/wiki/R_(programming_language)}\\
%    \hskip1em\url{http://blog.revolutionanalytics.com/2011/08/what-language-is-r-written-in.html}\\
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{image/Rlogo.jpg}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Why is \texttt{R} More Difficult Than Other Languages?}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
\begin{columns}[T]
  \column{0.7\textwidth}
    \texttt{R} is more difficult than other languages because:
    \begin{itemize}
      \item \texttt{R} is a \emph{functional} language, and the functional syntax may be unfamiliar to users of procedural languages like \texttt{C/C++},
      \item There are many dozens of user-created \emph{packages} (function libraries), and it's often difficult to tell which are the most useful or best for a particular application,
      \item The \texttt{R} interpreter produces very cryptic \emph{warnings} and \emph{error} messages,
      \item This is because the \texttt{R} interpreter is a programming environment, which means that it performs many additional complex calculations quietly (\emph{under-the-hood}) to assist the user,
      \item But if there's a bug in the code or bad data then the complex functions underlying the \texttt{R} interpreter produce \emph{warnings} and \emph{error} messages, which exposeses the user to the complexity of the \texttt{R} interpreter,
    \end{itemize}
    This course is designed to teach the most useful elements of \texttt{R} for financial analysis, through case studies and examples,
  \column{0.3\textwidth}
    \includegraphics[height=0.2\textwidth]{image/Rlogo.jpg}
\end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} License}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      \texttt{R} is open-source software released under the GNU General Public License:
      \vskip1ex
      \hskip1em\url{http://www.r-project.org/Licenses}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/GPLv3_Logo.png}
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Some other \texttt{R} packages are released under the Creative Commons Attribution-ShareAlike License:
      \vskip1ex
      \hskip1em\url{http://creativecommons.org}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.1\textwidth]{image/CC_License.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installing \texttt{R} and \protect\emph{RStudio}}
\begin{frame}[t]{\subsecname}

\begin{block}{}
  Students will be required to bring their laptop computers to all the lectures, and to run the \texttt{R} Interpreter and \textbf{RStudio} RStudio during the lecture,
  \vskip1ex
  Laptop computers will be necessary for following the lectures, and for performing tests,
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Students will be required to install and to become proficient with the \texttt{R} Interpreter,\\
      Students can download the \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network):\\
      \hskip1em\url{http://cran.r-project.org/}
      \vskip1ex
      To invoke the \texttt{RGui} interface, click on:\\
      \href{C:/Program Files/R/R-3.1.2/bin/x64/RGui.exe}{C:/Program Files/R/R-3.1.2/bin/x64/RGui.exe}\\
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/Rlogo.jpg}
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.7\textwidth}
      Students will be required to install and to become proficient with the \emph{RStudio} Integrated Development Environment (\emph{IDE}),\\
      \hskip1em\url{http://www.rstudio.com/products/rstudio/}
    \column{0.3\textwidth}
      \includegraphics[height=0.2\textwidth]{image/RStudio_logo.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Using \protect\emph{RStudio}}
\begin{frame}[t]{\subsecname}

% Snapshot of \emph{RStudio} GUI
\includegraphics[height=0.6\textwidth]{image/RStudio.png}

\end{frame}



%%%%%%%%%%%%%%%
\section{The \texttt{R} Environment}


%%%%%%%%%%%%%%%
\subsection{A First \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Variables are created by an assignment operation, and they don't have to be declared,
      \vskip1ex
      The standard assignment operator in \texttt{R} is the arrow symbol \texttt{"<-"},
      \vskip1ex
      \texttt{R} interprets text in quotes ("") as character strings,
      \vskip1ex
      Text that is not in quotes ("") is interpreted as a \emph{symbol} or \emph{expression},
      \vskip1ex
      Typing a \emph{symbol} or \emph{expression} evaluates it,
      \vskip1ex
      \texttt{R} uses the hash "\texttt{\#}" sign to mark text as comments, 
      \vskip1ex
      All text after the hash "\texttt{\#}" sign is treated as a comment, and is not executed as code, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=TRUE>>=
# "<-" and "=" are valid assignment operators
my_var <- 3

# typing a symbol or expression evaluates it
my_var

# text in quotes is interpreted as a string
my_var <- "Hello World!"

# typing a symbol or expression evaluates it
my_var

my_var  # text after hash is treated as comment
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring an \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{getwd()} returns a vector of length \texttt{1}, with the first element containing a string with the name of the current working directory (\texttt{cwd}),
      \vskip1ex
      The function \texttt{setwd()} accepts a character string as input (the name of the directory), and sets the working directory to that string,
      \vskip1ex
      \texttt{R} is a functional language, and \texttt{R} commands are functions, so they must be followed by parentheses \texttt{"()"},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
getwd()  # get cwd
setwd("C:/Develop/R")  # set cwd
getwd()  # get cwd
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Get system date and time
      \vskip4ex
      Just the date
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=TRUE>>=
Sys.time()  # get date and time

Sys.Date()  # get date only
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Workspace}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The workspace is the current \texttt{R} working environment, which includes all user-defined objects and the command history,
      \vskip1ex
      The function \texttt{ls()} returns names of objects in the \texttt{R} workspace,
      \vskip1ex
      The function \texttt{rm()} removes objects from the \texttt{R} workspace,
      \vskip1ex
      The workspace can be saved into and loaded back from an \texttt{*.RData} file (binary file format),
      \vskip1ex
      The function \texttt{save.image()} saves the whole workspace,
      \vskip1ex
      The function \texttt{save()} saves just the selected objects,
      \vskip1ex
      The function \texttt{load()} reads data from \texttt{*.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2)),eval=FALSE>>=
rm(list=ls())
setwd("C:/Develop/R/lecture_slides/data")
var1 <- 3  # define new object
ls()  # list all objects in workspace
# list objects starting with "v"
ls(pattern=glob2rx("v*"))
# remove all objects starting with "v"
rm(list=ls(pattern=glob2rx("v*")))
save.image()  # save workspace to file .RData in cwd
rm(var1)  # remove object
ls()  # list objects
load(".RData")
ls()  # list objects
var2 <- 5  # define another object
save(var1, var2,  # save selected objects
     file="C:/Develop/R/lecture_slides/data/my_data.RData")
rm(list=ls())  # remove all objects
ls()  # list objects
load_ed <- load(file="C:/Develop/R/lecture_slides/data/my_data.RData")
load_ed
ls()  # list objects
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When you quit \texttt{R} you'll be prompted "Save workspace image?"\\
      \vskip1ex
      If you answer $YES$ then the workspace will be saved into the \texttt{.RData} file in the \texttt{cwd},\\
      \vskip1ex
      When you start \texttt{R} again, the workspace will be automatically loaded from the existing \texttt{.RData} file,\\
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
        q()  # quit R session
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{history()} displays recent commands,\\
      \vskip1ex
      You can also save and load the command history from a file,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
history(5)  # display last 5 commands
savehistory(file="myfile")  # default is ".Rhistory" 
loadhistory(file="myfile")  # default is ".Rhistory"
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Session Info}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{sessionInfo()} returns information about the current \texttt{R} session,
      \begin{itemize}
        \item \texttt{R version},
        \item \texttt{OS platform},
        \item \texttt{locale} settings,
        \item list of packages that are loaded and attached to the search path,
        \item list of packages that are loaded, but \emph{not} attached to the search path,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=TRUE>>=
sessionInfo()  # get R version and other session info
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Environment Variables}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses environment variables to store information about its environment, such as paths to directories containing files used by \texttt{R} (startup, history, OS),
      \vskip1ex
      For example the environment variables:
      \begin{itemize}
        \item \texttt{R\_USER} and \texttt{HOME} store the \texttt{R} user Home directory,
        \item \texttt{R\_HOME} stores the root directory of the \texttt{R} installation,
      \end{itemize}
      The functions \texttt{Sys.getenv()} and \texttt{Sys.setenv()} display and set the values environment variables,
      \vskip1ex
      \texttt{Sys.getenv("env\_var")} displays the environment variable \texttt{"env\_var"},
      \vskip1ex
      \texttt{Sys.setenv("env\_var=value")} sets the environment variable \texttt{"env\_var"} equal to \texttt{"value"},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
Sys.getenv()[5:7]  # list some environment variables

Sys.getenv("Home")  # get R user HOME directory

Sys.setenv(Home="C:/Develop/data")  # set HOME directory

Sys.getenv("Home")  # get user HOME directory

Sys.getenv("R_home")  # get R_HOME directory

R.home()  # get R_HOME directory

R.home("etc")  # get "etc" sub-directory of R_HOME
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Global \protect\emph{Options} Settings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} uses a list of global \emph{options} which affect how \texttt{R} computes and displays results,
      \vskip1ex
      The function \texttt{options()} either sets or displays the values of global \emph{options},
      \vskip1ex
      \texttt{options("globop")} displays the current value of option \texttt{"globop"},
      \vskip1ex
      \texttt{getOption("globop")} displays the current value of option \texttt{"globop"},
      \vskip1ex
      \texttt{options(globop=value)} sets the option \texttt{"globop"} equal to \texttt{"value"},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
# ?options  # long list of global options
# interpret strings as characters, not factors
getOption("stringsAsFactors")  # display option
options("stringsAsFactors")  # display option
options(stringsAsFactors=FALSE)  # set option
# number of digits printed for numeric values
options(digits=3)
# control exponential scientific notation of print method
# positive "scipen" values bias towards fixed notation
# negative "scipen" values bias towards scientific notation
options(scipen=100)
# maximum number of items printed to console
options(max.print=30)
# warning levels options
# negative - warnings are ignored
options(warn=-1)
# zero - warnings are stored and printed after top-level function has completed
options(warn=0)
# one - warnings are printed as they occur
options(warn=1)
# two or larger - warnings are turned into errors
options(warn=2)
# save all options in variable
op_tions <- options()
# restore all options from variable
options(op_tions)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Objects}


%%%%%%%%%%%%%%%
\subsection{Data Objects in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      All data objects in \texttt{R} are \emph{vectors}, or consist of \emph{vectors},
      \vskip1ex
      Single numbers and character strings are vectors of length \texttt{"1"},
      \vskip1ex
      \emph{Atomic} vectors are \emph{homogeneous} objects whose elements are all of the same \emph{mode} (type),
      \vskip1ex
      \emph{Lists} and \emph{data frames} are \emph{recursive} (heterogeneous) objects, whose elements can be vectors of different \emph{mode},
      \vskip1ex
      The functions \texttt{is.atomic()} and \texttt{is.recursive()} return logical values depending on whether their arguments are \emph{atomic} or \emph{recursive},
      \vskip1ex
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{\texttt{R} Data Objects}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{\emph{Atomic}} & \text{\emph{Recursive}} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# single numbers are vectors of length 1
1
# character strings are vectors of length 1
"a"
# strings without quotes are variable names
a  # variable "a" doesn't exist
# list elements can have different mode
list(aa=c('a', 'b'), bb=1:5)
data.frame(aa=c('a', 'b'), bb=1:2)
is.atomic(data.frame(aa=c('a', 'b'), bb=1:2))
is.recursive(data.frame(aa=c('a', 'b'), bb=1:2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type, Mode, and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{type}, \emph{mode}, and \emph{class} are \texttt{character} strings representing various object properties,
      \vskip1ex
      The \emph{type} of an atomic object represents how it's stored in memory (\texttt{logical}, \texttt{character}, \texttt{integer}, \texttt{double}, etc.)
      \vskip1ex
      The \emph{mode} of an atomic object is the kind of data it represents (\texttt{logical}, \texttt{character}, \texttt{numeric}, etc.)
      \vskip1ex
      The \emph{mode} of an object often coincides with its \emph{type} (except for \texttt{integer} and \texttt{double} types),
      \vskip1ex
      Recursive objects (\texttt{lists}, \texttt{data frames}) have both \emph{type} and \emph{mode} equal to the recursive type (\texttt{list}),
      \vskip1ex
      The \emph{class} of an object is given by either an explicit \emph{class} attribute, or is derived from the object \emph{mode} and its \texttt{dim} attribute (implicit \emph{class}),
      \vskip1ex
      The function \texttt{class()} returns the explicit or implicit \emph{class} of an object,
      \vskip1ex
      The object \emph{class} is used for method dispatching in the \texttt{S3} object-oriented programming system in \texttt{R},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
my_var <- "hello"
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- runif(5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(1:10, 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- matrix(runif(10), 2, 5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- list(aa=c('a', 'b'), bb=1:5)
c(typeof(my_var), mode(my_var), class(my_var))

my_var <- data.frame(aa=c('a', 'b'), bb=1:2)
c(typeof(my_var), mode(my_var), class(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{R} Object Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} objects can have different attributes, such as: \texttt{names}, \texttt{dimnames}, \texttt{dimensions}, \emph{class}, etc.,
      \vskip1ex
      The attributes of an object is a named \texttt{list} of \texttt{symbol=value} pairs,
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
      \vskip1ex
      The attributes of an \texttt{R} object can be modified using the \texttt{"attributes() <-"} assignment,
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it,
      \vskip1ex
      A \texttt{vector} that is assigned an attribute other than \texttt{names} is not treated as a \texttt{vector},
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# a simple vector has no attributes
attributes(5:10)
my_var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
# named vector has "names" attribute
attributes(my_var)
my_var <- 1:10
is.vector(my_var)  # is the object a vector?
attributes(my_var) <- list(my_attr="foo")
my_var
is.vector(my_var)  # is the object a vector?
my_var <- 0
attributes(my_var) <- list(class="Date")
my_var  # "Date" object
structure(0, class="Date")  # "Date" object
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Modifying \protect\emph{class} Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Objects without an explicit \emph{class} don't have a \emph{class} attribute, and the function \texttt{class()} returns the implicit \emph{class},
      \vskip1ex
      The \emph{class} of an object can be modified using the \texttt{"class() <-"} assignment,
      \vskip1ex
      An object can have a main \emph{class}, and also an inherited \emph{class} (the \emph{class} attribute can be a vector of strings),
      \vskip1ex
      The function \texttt{unclass()} removes the explicit class attribute from an object,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
my_var <- matrix(runif(10), 2, 5)
class(my_var)  # has implicit class
# but no explicit "class" attribute
attributes(my_var)
c(typeof(my_var), mode(my_var), class(my_var))
# assign explicit "class" attribute
class(my_var) <- "my_class"
class(my_var)  # has explicit "class"
# has explicit "class" attribute
attributes(my_var)
is.matrix(my_var)  # is the object a matrix?
is.vector(my_var)  # is the object a vector?
attributes(unclass(my_var))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Implicit Class of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an object has no explicit \emph{class}, then its implicit \emph{class} is derived from its \emph{mode} and \texttt{dim} attribute (except for \texttt{integer} vectors which have the implicit class \texttt{"integer"} derived from their \emph{type}),
      \vskip1ex
      If an \emph{atomic} object has a \texttt{dim} attribute, then its implicit \emph{class} is \texttt{matrix} or \texttt{array},
      \vskip1ex
      \texttt{Data frames} have no explicit \texttt{dim} attribute, but \texttt{dim()} returns a value, so they have an implicit \texttt{dim} attribute,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# integer implicit class derived from type
my_var <- vector(mode="integer", length=10)
c(typeof(my_var), mode(my_var), class(my_var))
# numeric implicit class derived from mode
my_var <- vector(mode="numeric", length=10)
c(typeof(my_var), mode(my_var), class(my_var))
# adding dim attribute changes implicit class to matrix
dim(my_var) <- c(5, 2)
c(typeof(my_var), mode(my_var), class(my_var))
# data frames have implicit dim attribute
my_var <- data.frame(aa=c('a', 'b'), bb=1:2)
c(typeof(my_var), mode(my_var), class(my_var))
attributes(my_var)
dim(my_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Object Coercion}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Coercion} means changing the \emph{type}, \emph{mode}, or \emph{class} of an object, often without changing the underlying data,
      \vskip1ex
      Changing the \emph{mode} of an object can change its \emph{class} as well, but not always,
      \vskip1ex
      Objects can be explicitly coerced using the \texttt{"as.*"} coercion functions,
      \vskip1ex
      Most coercion functions strip the \emph{attributes} from the object,
      \vskip1ex
      Implicit coercion occurs when objects with different \texttt{modes} are combined into a vector, forcing the elements to have the same \emph{mode},
      \vskip1ex
      Implicit coercion can cause bugs that are difficult to trace,
      \vskip1ex
      The rule is that coercion is into larger types (\texttt{numeric} objects are coerced into \texttt{character} strings),
      \vskip1ex
      Coercion can introduce bad data, such as \texttt{NA} values,
    \column{0.5\textwidth}
      \vspace{-2em}
      <<echo=TRUE,eval=FALSE>>=
my_var <- 1:5
c(typeof(my_var), mode(my_var), class(my_var))
mode(my_var) <- "character"  # coerce to "character"
my_var
c(typeof(my_var), mode(my_var), class(my_var))
# explicitly coerce to "character"
my_var <- as.character(1:5)
c(typeof(my_var), mode(my_var), class(my_var))
mat_rix <- matrix(1:10, 2, 5)  # create matrix
# explicitly coerce to "character"
mat_rix <- as.character(mat_rix)
c(typeof(mat_rix), mode(mat_rix), class(mat_rix))
# coercion converted matrix to vector
c(is.matrix(mat_rix), is.vector(mat_rix))
as.logical(0:3)  # explicit coercion to "logical"
as.numeric(c(FALSE, TRUE, TRUE, TRUE))
c(1:3, 'a')  # implicit coercion to "character"
# explicit coercion to "numeric"
as.numeric(c(1:3, 'a'))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Atomic Data Objects}


%%%%%%%%%%%%%%%
\subsection{Basic \texttt{R} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The quotation marks \texttt{""} (or \texttt{''}) around a character string tell \texttt{R} that it's a string, not a variable name,
      \vskip1ex
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"},
      \vskip1ex
      A character string is also a vector with a single element, with the first element of the vector containing the string of text,
      \vskip1ex
      The colon binary operator \texttt{':'} produces a vector,
      \vskip1ex
      The function \texttt{c()} combines objects into a vector,
      \vskip1ex
      The \texttt{"[1]"} symbol means the return value is a vector,
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
"Hello World!"  # type some text
# hello is a variable name, because it's not in quotes
hello  # R interprets "hello" as a variable name
is.vector(1)  # single number is a vector
is.vector("a")  # string is a vector
4:8  # create a vector
# create vector using c() combine function
c(1, 2, 3, 4, 5)
# create vector using c() combine function
c('a', 'b', 'c')
# create vector using c() combine function
c(1, 'b', 'c')
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Character \texttt{strings} are sequences of characters (and vectors of length one),
      \vskip1ex
      The function \texttt{nchar()} returns the length of a string,
      \vskip1ex
      Special characters in strings:\\
      \texttt{"\textbackslash{}t"} for TAB,\\
      \texttt{"\textbackslash{}n"} for new-line,\\
      "\texttt{\textbackslash{}}\texttt{\textbackslash{}}" for a (single) backslash character
      \vskip1ex
      The function \texttt{cat()} concatenates strings and echos them to console, without returning any values,
      \vskip1ex
      The function \texttt{cat()} is useful in user-defined functions,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
str_var <- "Some string"
str_var
str_var[1]
str_var[2]

length(str_var)  # length of vector
nchar(str_var)  # length of string

# concatenate and echo to console
cat("Hello", "World!")
cat("Enter\ttab")
cat("Enter\nnewline")
cat("Enter\\backslash")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{paste()} concatenates its arguments into a string, coerces them to characters if needed, and returns the string,
      \vskip1ex
      If a vector or list is passed to \texttt{paste()}, together with a \texttt{collapse} string, then \texttt{paste()} concatenates the elements into a string, separated by the \texttt{collapse} string,
      \vskip1ex
      The function \texttt{strsplit()} splits the elements of a character vector,
      \vskip1ex
      Splitting on the \texttt{"."} character requires surrounding it with brackets: \texttt{"[.]"}, or using argument \texttt{fixed=TRUE},
      \vskip1ex
      The function \texttt{substring()} extracts or replaces substrings in a character string,
      \vskip1ex
      The recycling rule extends the length to match the longest object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
str_var1 <- "Hello"  # define a character string
str_var2 <- "World!"  # define a character string
paste(str_var1, str_var2, sep=' ')  # concatenate and return value
cat(str_var1, str_var2)  # concatenate and echo to console
paste('a', 1:4, sep='-')  # convert, recycle and concatenate
paste(c("a1", "a2", "a3"), collapse="+")  # collapse vector to string
paste(list("a1", "a2", "a3"), collapse="+")
paste("Today is", Sys.time())  # coerce and concatenate strings
paste("Today is", format(Sys.time(), "%B-%d-%Y"))
strsplit("Hello World", split='r')  # split string
strsplit("Hello.World", split='[.]')  # split string
strsplit("Hello.World", split='.', fixed=TRUE)  # split string
substring("Hello World", 3, 6)  # extract characters from 3 to 6
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Regular Expressions in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has Regex functions for pattern matching and replacement,
      \vskip1ex
      The function \texttt{gsub()} replaces all matches of a pattern in a string,
      \vskip1ex
      The function \texttt{grep()} searches for matches of a pattern in a string,
      \vskip1ex
      The function \texttt{glob2rx()} converts globbing wildcard patterns into regular expressions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
gsub("is", "XX", "is this gratis?")  # replace "is" with "XX"

grep("b", c("abc", "xyz", "cba d", "bbb"))  # get indexes

grep("b", c("abc", "xyz", "cba d", "bbb"), value=TRUE)  # get values

glob2rx("abc.*")  # convert globs into regex
glob2rx("*.doc")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vectors are the basic building blocks of \texttt{R} objects,
      \vskip1ex
      There are no scalars in \texttt{R}, and single values are stored as vectors of length \texttt{"1"},
      \vskip1ex
      The function \texttt{c()} combines values into a vector,
      \vskip1ex
      The function \texttt{is.vector()} returns \texttt{TRUE} if its argument is a vector, and returns \texttt{FALSE} otherwise,
      \vskip1ex
      The object \texttt{letters} is a constant and a vector,
     \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
is.vector(1)  # single number is a vector
is.vector("a")  # string is a vector
vec_tor <- c(8, 6, 5, 7)  # create vector
vec_tor
vec_tor[2]  # extract second element
# extract all elements, except the second element
vec_tor[-2]
# create Boolean vector
c(FALSE, TRUE, TRUE)
# extract second and third elements
vec_tor[c(FALSE, TRUE, TRUE)]
letters[5:10]  # vector of letters
c('a', letters[5:10])  # combine two vectors of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Creating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The colon operator (\texttt{":"}) provides a simple way of creating a numeric vector,
      \vskip1ex
      The function \texttt{vector()} returns a vector of the specified \emph{mode},
      \vskip1ex
      The functions \texttt{seq()}, \texttt{seq\_len()}, and \texttt{seq\_along()} return a sequence (vector) of numbers,
      \vskip1ex
      The function \texttt{rep()} replicates an object multiple times,
      \vskip1ex
      The functions \texttt{character()} and \texttt{numeric()} return zero-length vectors of the specified \emph{mode} (not to be confused with a \texttt{NULL} object),
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
0:10  # vector of integers from 0 to 10
vector()  # create empty vector
vector(mode="numeric", length=10)  # numeric vector of zeros
seq(10)  # sequence from 1 to 10
seq(along=(-5:5))  # instead of 1:length(obj)
seq_along(c("a", "b", "c"))  # instead of 1:length(obj)
seq(from=0, to=1, len=11)  # decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # decimals from 0 to 1.0
seq(-2,2, len=11)  # 10 numbers from -2 to 2
rep(100, times=5)  # replicate a number
character(5)  # create empty character vector
numeric(5)  # create empty numeric vector
numeric(0)  # create zero-length vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Arithmetic and Logical Operations on \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vectors can be multiplied and squared element by element, as if they were single elements,
      \vskip1ex
      When vectors are manipulated as if they were single elements, then \texttt{R} automatically performs a loop over the vector elements, and applies the operation element-wise,
      \vskip1ex
      This is a very powerful feature of \texttt{R} called \emph{vectorized arithmetic},
      \vskip1ex
      \emph{Vectorized arithmetic} avoids writing loops and simplifies notation,
      \vskip1ex
      Vectors can be combined together and appended,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
2*4:8  # multiply a vector
2*(4:8)  # multiply a vector
4:8/2  # divide a vector
(0:10)/10  # divide vector - decimals from 0 to 1.0
vec_tor <- c(8, 6, 5, 7)  # create vector
vec_tor
# Boolean vector TRUE if element is equal to second one
vec_tor == vec_tor[2]
# Boolean vector TRUE for elements greater than six
vec_tor > 6
2*vec_tor  # multiply all elements by 2
vec_tor^2  # square all elements
c(11, 5:10)  # combine two vectors
c(vec_tor, 2.0)  # append number to vector
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Naming and Manipulating \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vector elements can be assigned \texttt{names} using a list of symbol-value pairs,
      \vskip1ex
      The function \texttt{names()} returns the \texttt{names} attribute of an object,
      \vskip1ex
      The \texttt{names} attribute of a vector can be modified by assigning to the \texttt{names()} function ("\texttt{names() <-}" assignment),
      \vskip1ex
      The function \texttt{unname()} removes the \texttt{names} attribute,
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vec_tor <- # create named vector
  c(pi_const=pi, euler=exp(1), gamma=-digamma(1))
vec_tor
names(vec_tor)  # get names of elements
vec_tor["euler"]  # get element named "euler"
names(vec_tor) <- c("pie","eulery","gammy")  # rename elements
vec_tor
unname(vec_tor)  # remove names attribute
letters[5:10]  # vector of letters
c('a', letters[5:10])  # combine two vectors of letters
# create named vector
structure(sample(1:5), names=paste0("el", 1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Vector elements can be \emph{subset} (indexed, dereferenced) using the \texttt{"[]"} operator,
      \vskip1ex
      Vectors can be \emph{subset} using vectors of:
      \begin{itemize}
        \item positive integers,
        \item negative integers,
        \item characters (names),
        \item Boolean vectors,
      \end{itemize}
      \vskip1ex
      Negative integers remove the vector elements,
      \vskip1ex
      Subsetting with \texttt{zero} returns a zero-length vector,
      \vskip1ex
      A named vector can be \emph{subset} using element names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vec_tor  # named vector
# extract second element
vec_tor[2]
# extract all elements, except the second element
vec_tor[-2]
# extract zero elements - returns zero-length vector
vec_tor[0]
# extract second and third elements
vec_tor[c(FALSE, TRUE, TRUE)]
# extract elements using their names
vec_tor["eulery"]
# extract elements using their names
vec_tor[c("pie", "gammy")]
# subset whole vector
vec_tor[] <- 0
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Filtering \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Filtering} means extracting elements from a vector that satisfy a logical condition,
      \vskip1ex
      When logical comparison operators are applied to vectors, they produce Boolean vectors,
      \vskip1ex
      Boolean vectors can then be applied to subset the original vectors, to extract their elements,
      \vskip1ex
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a Boolean \texttt{vector} or \texttt{array},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
vec_tor <- runif(5)
vec_tor
vec_tor > 0.5  # Boolean vector
# Boolean vector of elements equal to the second one
vec_tor == vec_tor[2]
# extract all elements equal to the second one
vec_tor[vec_tor == vec_tor[2]]
vec_tor < 1  # Boolean vector of elements less than one
# extract all elements greater than one
vec_tor[vec_tor > 1]
vec_tor[vec_tor > 0.5]  # filter elements > 0.5
which(vec_tor > 0.5)  # index of elements > 0.5
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{matrix()} creates a matrix from a vector, and the matrix dimensions,
      \vskip1ex
      By default \texttt{matrix()} creates matrices column-wise, unless the argument \texttt{byrow=TRUE} is used,
      \vskip1ex
      The elements of matrices can be subset (dereferenced) using the \texttt{"[]"} operator,
      \vskip1ex
      The functions \texttt{nrow()} and \texttt{ncol()} return the number of rows and columns of a matrix,
      \vskip1ex
      The functions \texttt{NROW()} and \texttt{NCOL()} also return the number of rows or columns of a matrix, but they can also be applied to vectors, and treat vectors as single column matrices,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
mat_rix <- matrix(5:10, nrow=2, ncol=3)  # create a matrix
mat_rix  # by default matrices are constructed column-wise
# create a matrix row-wise
matrix(5:10, nrow=2, byrow=TRUE)
mat_rix[2, 3]  # extract third element from second row
mat_rix[2, ]  # extract second row
mat_rix[, 3]  # extract third column
mat_rix[, c(1,3)]  # extract first and third column
mat_rix[, -2]  # remove second column
# subset whole matrix
mat_rix[] <- 0
# get the number of rows or columns
nrow(vec_tor); ncol(vec_tor)
NROW(vec_tor); NCOL(vec_tor)
nrow(mat_rix); ncol(mat_rix)
NROW(mat_rix); NCOL(mat_rix)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Attributes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Arrays are vectors with a dimension attribute,
      \vskip1ex
      Matrices are two-dimensional arrays,
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
      \vskip1ex
      The \texttt{dimnames} attribute is a list, with vector elements containing row and column names,
      \vskip1ex
      A named matrix can be subset using row and column names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
attributes(mat_rix)  # get matrix attributes
dim(mat_rix)  # get dimension attribute
class(mat_rix)  # get class attribute
rownames(mat_rix) <- c("row1", "row2")  # rownames attribute
colnames(mat_rix) <- c("col1", "col2", "col3")  # colnames attribute
mat_rix
mat_rix["row2", "col3"]  # third element from second row
names(mat_rix)  # get the names attribute
dimnames(mat_rix)  # get dimnames attribute
attributes(mat_rix)  # get matrix attributes
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Subsetting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Matrices can be subset in a similar way as Vectors, either by indices (integers), by characters (names), or Boolean vectors,
      \vskip1ex
      Subsetting a matrix to a single row or column produces a vector, unless the parameter \texttt{"drop=FALSE"} is used,
      \vskip1ex
      Subsetting with the parameter \texttt{"drop=FALSE"} prevents the implicit coercion and preserves the matrix \emph{class},
      \vskip1ex
      This is an example of implicit coercion in \texttt{R}, which can cause difficult to trace bugs,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
mat_rix  # matrix with column names
mat_rix[1, ]  # subset rows by index
mat_rix[, "col1"]  # subset columns by name
mat_rix[, c(TRUE, FALSE, TRUE)]  # subset columns Boolean vector
mat_rix[1, ]  # subsetting can produce a vector!
class(mat_rix); class(mat_rix[1, ])
is.matrix(mat_rix[1, ]); is.vector(mat_rix[1, ])
mat_rix[1, , drop=FALSE]  # drop=FALSE preserves matrix
class(mat_rix[1, , drop=FALSE])
is.matrix(mat_rix[1, , drop=FALSE]); is.vector(mat_rix[1, , drop=FALSE])
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the following logical operators:
      \begin{itemize}
        \item \texttt{"<"} less than,
        \item \texttt{"<="} less than or equal to,
        \item \texttt{">"} greater than,
        \item \texttt{">="} greater than or equal to,
        \item \texttt{"=="} exactly equal to,
        \item \texttt{"!="} not equal to,
        \item \texttt{"!x"} Not \texttt{x},
        \item \texttt{"x \& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x | y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
vec_tor1 <- c(2, 4, 6)
vec_tor1 < 5  # element-wise comparison
(vec_tor1 < 5) & (vec_tor1 > 3)
vec_tor1[(vec_tor1 < 5) & (vec_tor1 > 3)]
vec_tor2 <- c(-10, 0, 10)
vec_tor1 < vec_tor2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} also has two long form logical operators:
      \begin{itemize}
        \item \texttt{"x \&\& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x || y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first elements of their vector arguments,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use \texttt{"\&\&"} and \texttt{"||"} in if-clauses,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
echo_true <- function() {cat("echo_true\t"); TRUE}
echo_false <- function() {cat("echo_false\t"); FALSE}
echo_true() | echo_false()
echo_true() || echo_false()  # echo_false() isn't evaluated at all!
vec_tor <- c(2, 4, 6)
# works (does nothing) using '&&'
if (is.matrix(vec_tor) && (vec_tor[2, 3] > 0)) {
  vec_tor[2, 3] <- 1
}
# no short-circuit so fails (produces an error)
if (is.matrix(vec_tor) & (vec_tor[2, 3] > 0)) {
  vec_tor[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Arithmetic Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Arithmetic \emph{operators} perform arithmetic operations on \texttt{numeric} or \texttt{complex} vectors,
      \begin{itemize}
        \item "\texttt{+}" performs addition,
        \item "\texttt{-}" performs subtraction,
        \item "\texttt{*}" performs multiplication,
        \item "\texttt{/}" performs division,
        \item "\texttt{\textasciicircum{}}" and "\texttt{**}" perform exponentiation,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
?Arithmetic
4.7 * 0.5  # multiplication
4.7 / 0.5  # division
# exponentiation
2**3
2^3
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Comparing Objects With \texttt{identical()} and \texttt{all.equal()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{identical()} tests if two objects are exactly the same, and always returns a single logical \texttt{TRUE} or \texttt{FALSE} (never \texttt{NA} or logical \texttt{vectors}),
      \vskip1ex
      For atomic arguments \texttt{identical()} often gives the same result as the \texttt{"=="} operator, but it's not synonymous with it in general,
      \vskip1ex
      The \texttt{"=="} operator applies the \emph{recycling rule} to vector arguments and returns logical \texttt{vectors}, but \texttt{identical()} doesn't and returns a single logical value,
      \vskip1ex
      The function \texttt{all.equal()} tests the equality of two objects to within the square root of the \emph{machine precision},
      \vskip1ex
      The variable \texttt{.Machine} contains information about the numerical characteristics of the computer \texttt{R} is running on, such as the largest \texttt{double} and \texttt{integer} numbers, and the \emph{machine precision},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
num_var <- 2
num_var==2
identical(num_var, 2)

identical(num_var, NULL)
# this doesn't work:
# num_var==NULL
is.null(num_var)

vec_tor <- c(2, 4, 6)
vec_tor==2
identical(vec_tor, 2)

# num_ber is equal to "1.0" within machine precision
num_ber <- 1.0 + 2*sqrt(.Machine$double.eps)
all.equal(num_ber, 1.0)

# info machine precision of computer R is running on
# ?.Machine
# machine precision
.Machine$double.eps
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{which()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a Boolean \texttt{vector} or \texttt{array},
      \vskip1ex
      If the argument is an \texttt{array} and \texttt{arr.ind=TRUE}, then \texttt{which()} returns a matrix with rows containing the indices of the \texttt{TRUE} elements,
      \vskip1ex
      The functions \texttt{which.max()} and \texttt{which.min()} return the index of the minimum or maximum of a \texttt{numeric} or \texttt{Boolean} vector,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
vec_tor <- sample(1:6, 21, replace=TRUE)
mat_rix <- matrix(vec_tor, ncol=3)
vec_tor
which(vec_tor == 5)
# equivalent but slower than above
(1:length(vec_tor))[vec_tor == 5]
which(vec_tor > 5)
# find indices of TRUE elements of Boolean matrix
which((mat_rix == 5)|(mat_rix == 6),
      arr.ind=TRUE)
# equivalent but slower than above
arrayInd(which((mat_rix == 5)|(mat_rix == 6)),
         dim(mat_rix), dimnames(mat_rix))
which.max(vec_tor)
# equivalent but slower than above
which(vec_tor == max(vec_tor))
which.min(vec_tor)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching Using \texttt{match()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{match()} returns the index of the first element of its second argument, that matches its first argument,
      \vskip1ex
      The binary operator \texttt{\%in\%} returns a Boolean \texttt{vector} with \texttt{TRUE} values corresponding to elements that have matches,
      \vskip1ex
      \texttt{\%in\%} is a wrapper for \texttt{match()} defined as follows:\\
      \texttt{"\%in\%" <- function(x, table) match(x, table, nomatch=0) > 0},
      \vskip1ex
      \texttt{\%in\%} never returns \texttt{NA}, so it's preferred in \texttt{if ()} statements,
      \vskip1ex
      \texttt{any()} returns \texttt{TRUE} if at least one element of a Boolean vector is \texttt{TRUE}, and \texttt{FALSE} otherwise,
      \vskip1ex
      Given a single argument, \texttt{any()} is equivalent to \texttt{\%in\%}, but is much faster because it's a \emph{compiled} function,
      \vskip1ex
      \texttt{pmatch()} performs partial matching of strings,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
match(5, vec_tor)
# more general but slower than above
which(vec_tor == 5)
match(-5, vec_tor)
5 %in% vec_tor
# equivalent to above
match(5, vec_tor, nomatch=0) > 0
-5 %in% vec_tor
c(5, -5) %in% vec_tor
# equivalent to "5 %in% vec_tor"
any(vec_tor == 5)
# equivalent to "-5 %in% vec_tor"
any(vec_tor == (-5))
if (any(vec_tor < 0))
  cat("vector contains negative values\n")
# partial matching of strings
pmatch("med", c("mean", "median", "mode"))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Finding Closest Match Using \texttt{findInterval()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{match()} returns the index of the first element of its second argument, that \emph{exactly} matches its first argument,
      \vskip1ex
      \texttt{findInterval()} returns the indices of the intervals specified by \texttt{"vec"} that contain the elements of \texttt{"x"},
      \vskip1ex
      If there's an exact match, then \texttt{findInterval()} returns the same index as function \texttt{match()},
      \vskip1ex
      If there's no exact match, then \texttt{findInterval()} finds the element of \texttt{"vec"} that is closest to, but not greater than, the element of \texttt{"x"},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
str(findInterval)
# get index of the element of "vec" that matches 5
findInterval(x=5, vec=c(3, 5, 7))
match(5, c(3, 5, 7))
# no exact match
findInterval(x=6, vec=c(3, 5, 7))
match(6, c(3, 5, 7))
# indices of "vec" that match elements of "x"
findInterval(x=1:8, vec=c(3, 5, 7))
# return only indices of inside intervals
findInterval(x=1:8, vec=c(3, 5, 7),
             all.inside=TRUE)
# make rightmost interval inclusive
findInterval(x=1:8, vec=c(3, 5, 7),
             rightmost.closed=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard assignment operator in \texttt{R} is \texttt{"<-"},
      \vskip1ex
      Both \texttt{"<-"} and \texttt{"="} are valid assignment operators in \texttt{R},
      \vskip1ex
      The \texttt{"<-"} operator may cause an error if \texttt{R} confuses it with the \texttt{"<"} logical operator,
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} (\texttt{"<-"} has higher precedence than \texttt{"="}),
      \vskip1ex
      The \texttt{"="} operator is used for named arguments in function calls,
      \vskip1ex
      When variables are assigned within an argument list using the \texttt{"="} operator, their \emph{scope} is limited to the function,
      \vskip1ex
      {\color{red}{Rule of Thumb}}:\\
      Use \texttt{"<-"} in \texttt{R} scripts and inside functions,\\
      Use \texttt{"="} only in function calls,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
num_var1 <- 3  # "<-" and "=" are valid assignment operators
num_var1
num_var1 = 3
num_var1
2<-3  # "<" operator confused with "<-"
2 < -3  # add space or brackets to avoid confusion
# "=" assignment within argument list
median(x=1:10)
x  # x doesn't exist outside the function
# "<-" assignment within argument list
median(x <- 1:10)
x  # x exists outside the function
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{The Parenthesis \texttt{"()"} and Curly Braces \texttt{"\{\}"} Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are used to enclose and to group (combine) expressions,
      \vskip1ex
      The parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and they return values,
      \vskip1ex
      An expression enclosed by the parenthesis \texttt{"()"} operator is evaluated separatately from other expressions, and its result is returned,
      \vskip1ex
      Enclosing expressions in parenthesis makes them less ambiguous,
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator can group several expressions, that can be written either on separate lines, or be separated by the semicolon \texttt{";"} operator, 
      \vskip1ex
      The curly braces \texttt{"\{\}"} operator returns the last expression it encloses,
      \vskip1ex
      Both the parenthesis \texttt{"()"} and curly braces \texttt{"\{\}"} operators are functions, and executing them requires a little additional processing time,
      \vskip1ex
      The square braces (brackets) \texttt{"[]"} operator subsets (dereferences) the elements of vectors, matrices, and lists,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# expressions enclosed in parenthesis are less ambiguous
-2:5
(-2):5
-(2:5)
# expressions enclosed in parenthesis are less ambiguous
-2*3+5
-2*(3+5)

# expressions can be separated by semicolons or by lines
{1+2; 2*3; 1:5}
# or
{1+2
2*3
1:5}

mat_rix <- matrix(nr=3, nc=4)
mat_rix <- 0
# subset whole matrix
mat_rix[] <- 0

# parenthesis and braces require a little additional processing time
library(microbenchmark)
summary(microbenchmark(
  ba_se=sqrt(rnorm(10000)^2),
  pa_ren=sqrt(((((rnorm(10000)^2))))),
  bra_ce=sqrt({{{{rnorm(10000)^2}}}}),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{"if () else"} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has the familiar \texttt{"if () \{...\} else \{...\}"} statement to control execution flow depending on logical conditions,
      \vskip1ex
      The logical conditions must be either a \texttt{Boolean} or \texttt{numeric} type, otherwise an error is produced,
      \vskip1ex
      The \texttt{"else"} statement can also be omitted,
      \vskip1ex
      \texttt{"if"} statements can be nested using multiple \texttt{"else if"} statements,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
num_var1 <- 1

if (num_var1) {  # numeric zero is FALSE, all other numbers are TRUE
  num_var2 <- 4
} else if (num_var1 == 0) {  # 'else if' together on same line
  num_var2 <- 0
} else {  # 'else' together with curly braces
  num_var2 <- -4
}  # end if

num_var2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{switch()} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{switch()} matches its first argument \texttt{"EXPR"} with one of the symbols in the following arguments, evaluates the corresponding expression, and returns it,
      \vskip1ex
      The arguments that follow the first argument \texttt{"EXPR"} should be given as \emph{symbol=value} pairs,
      \vskip1ex
      If \texttt{"EXPR"} is a character string, then the expression bound to that symbol is returned by \texttt{switch()},
      \vskip1ex
      If \texttt{"EXPR"} is an integer, then \texttt{switch()} returns the expression from that position,
      \vskip1ex
      If \texttt{switch()} can't match \texttt{"EXPR"} to any symbol, then it returns \texttt{NULL} invisibly,
      \vskip1ex
      Using \texttt{switch()} is a convenient alternative to a cascade of \texttt{"if () else"} statements,
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
switch("a", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("c", a="aaahh", b="bee", c="see", d=2,
       "else this")
switch(3, a="aaahh", b="bee", c="see", d=2,
       "else this")
switch("cc", a="aaahh", b="bee", c="see", d=2,
       "else this")
# measure of central tendency
centra_lity <- function(in_put,
            meth_od=c("mean", "mean_narm", "median")) {
# validate "meth_od" argument
  meth_od <- match.arg(meth_od)
  switch(meth_od,
         mean=mean(in_put),
         mean_narm=mean(in_put, na.rm=TRUE),
         median=median(in_put))
}  # end centra_lity
my_var <- rnorm(100, mean=2)
centra_lity(my_var, "mean")
centra_lity(my_var, "mean_narm")
centra_lity(my_var, "median")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using \texttt{for()} and \texttt{while()} Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop statement:
      \vspace{-1em}
      <<echo=TRUE, eval=FALSE>>=
for (in_dex in vec_tor) {ex_pressions}
@
      \vspace{-1em}
      iterates the \emph{bound} variable \texttt{in\_dex} over the elements of the vector or list \texttt{vec\_tor}, and evaluates in a loop the \texttt{ex\_pressions} contained in the body of the \texttt{for()} loop, 
      \vskip1ex
      Upon loop exit the \emph{bound} variable \texttt{in\_dex} is left equal to the last element of the vector \texttt{vec\_tor},
      \vskip1ex
      \texttt{while()} loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE},
      \vskip1ex
      But \texttt{while()} loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
color_list <- list("red", "white", "blue")
# loop over list
for (some_color in color_list) {
  print(some_color)
}  # end for
# loop over vector
for (in_dex in 1:3) {
  print(color_list[[in_dex]])
}  # end for

# while loops require initialization
in_dex <- 1
# while loop
while (in_dex < 4) {
  print(color_list[[in_dex]])
  in_dex <- in_dex + 1
}  # end while
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using \texttt{for()} and \texttt{apply()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{for()} loop doesn't return a value, so values calculated in the \texttt{for()} loop body must be assigned to variables in the parent environment, or otherwise they are lost, 
      \vskip1ex
      The expressions in the \texttt{for()} loop body have access to variables in the parent environment in which the \texttt{for()} loop is executed, and they can modify those variables,
      \vskip1ex
      So even though \texttt{for()} loops don't return a value, they can be used to perform calculations on variables in the parent environment, but this is discouraged since it can produce errors that are hard to debug,
      \vskip1ex
      {\color{red}{Rule of Thumb:}}\\
      \begin{itemize}
        \item \texttt{for()} loops are preferred for producing \emph{side effects}, like plotting or reading and writing data to files,
        \item \texttt{apply()} loops are preferred for performing calculations which produce vectors or matrices of values,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# loop over a vector and overwrite it
vec_tor <- integer(7)
for (i in 1:7) {
  cat("Changing element:", i, "\n")
  vec_tor[i] <- i^2
}  # end for
# equivalent way (without cat side effect)
for (i in seq_along(vec_tor)) 
  vec_tor[i] <- i^2

# sapply() loop returns vector of values
vec_tor <- sapply(seq_along(vec_tor), 
                  function(x) (x^2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using \texttt{for()} Loop}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_n = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_1 = 0, F_2 = 1,
      \end{displaymath}
      \begin{displaymath}
        F_n = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by the Italian mathematician \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration,
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector,
      \vskip1ex
      The function \texttt{numeric()} returns an zero length \texttt{numeric} vector,
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1))>>=
rm(list=ls())
# fib_seq <- numeric()  # zero length numeric vector
# pre-allocate vector instead of "growing" it
fib_seq <- numeric(10)
fib_seq[1] <- 0  # initialize
fib_seq[2] <- 1  # initialize
for (i in 3:10) {  # perform recurrence loop
  fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2]
}  # end for
fib_seq
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Manipulating Vectors and Matrices}


%%%%%%%%%%%%%%%
\subsection{Allocating Memory to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} automatically allocates memory to new objects as needed during runtime, but at the cost of slowing down calculations,
      \vskip1ex
      Allocating memory of the correct \emph{mode} speeds up calculations by avoiding automatic memory allocation by \texttt{R},
      \vskip1ex
      The functions \texttt{character()}, \texttt{integer()}, and \texttt{numeric()} return zero-length vectors of the specified \emph{mode},
      \vskip1ex
      Zero length vectors are not the same as \texttt{NULL} objects,
      \vskip1ex
      The function \texttt{character(k)} returns a \texttt{character} vector of empty strings of length \texttt{k},
      \vskip1ex
      The function \texttt{integer(k)} returns a \texttt{integer} vector of zeros of length \texttt{k},
      \vskip1ex
      The function \texttt{numeric(k)} returns a \texttt{numeric} vector of zeros of length \texttt{k},
      \vskip1ex
      The function \texttt{vector()} by default returns a \texttt{Boolean} vector, unless the \emph{mode} is specified,
      \vskip1ex
      The function \texttt{matrix()} by default returns a \texttt{Boolean} matrix containing \texttt{NA} values, unless the \emph{mode} is specified,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# allocate character vector
character()
character(5)
is.character(character(5))
# allocate integer vector
integer()
integer(5)
is.integer(integer(5))
is.numeric(integer(5))
# allocate numeric vector
numeric()
numeric(5)
is.integer(numeric(5))
is.numeric(numeric(5))
# allocate Boolean vector
vector()
vector(length=5)
# allocate numeric vector
vector(length=5, mode="numeric")
is.null(vector())
# allocate Boolean matrix
matrix()
is.null(matrix())
# allocate integer matrix
matrix(NA_integer_, nrow=3, ncol=2)
is.integer(matrix(NA_integer_, nrow=3, ncol=2))
# allocate numeric matrix
matrix(NA_real_, nrow=3, ncol=2)
is.numeric(matrix(NA_real_, nrow=3, ncol=2))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Logical Operators Applied to Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      When logical operators are applied to vectors and matrices, they are applied element-wise, producing \texttt{Boolean} vectors and matrices,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
vec_tor <- sample(1:9)
vec_tor
vec_tor < 5  # element-wise comparison
vec_tor == 5  # element-wise comparison
mat_rix <- matrix(vec_tor, ncol=3)
mat_rix
mat_rix < 5  # element-wise comparison
mat_rix == 5  # element-wise comparison
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Vectors Into Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be coerced into matrices by adding a dimension attribute,
      \vskip1ex
      The \texttt{dimnames} attribute can be assigned a named list to convert it into a named matrix,
      \vskip1ex
      The function \texttt{structure()} adds attributes (specified as \texttt{symbol=value} pairs) to an object, and returns it,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
mat_rix <- 1:6  # create a vector
class(mat_rix)  # get its class
# is it vector or matrix?
c(is.vector(mat_rix), is.matrix(mat_rix))
structure(mat_rix, dim=c(2, 3))  # matrix object
# adding dimension attribute coerces into matrix
dim(mat_rix) <- c(2, 3)
class(mat_rix)  # get its class
# is it vector or matrix?
c(is.vector(mat_rix), is.matrix(mat_rix))
# assign dimnames attribute
dimnames(mat_rix) <- list(rows=c("row1", "row2"),
                        columns=c("col1", "col2", "col3"))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Coercing Matrices Into Other Types}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be explicitly coerced using the \texttt{"as.*"} coercion functions,
      \vskip1ex
      But coercion functions strip the \emph{attributes} from an object,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
mat_rix <- matrix(1:10, 2, 5)  # create matrix
mat_rix
# as.numeric strips dim attribute from matrix
as.numeric(mat_rix)
# explicitly coerce to "character"
mat_rix <- as.character(mat_rix)
c(typeof(mat_rix), mode(mat_rix), class(mat_rix))
# coercion converted matrix to vector
c(is.matrix(mat_rix), is.vector(mat_rix))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()},
      \vskip1ex
      The \emph{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
vec_tor1 <- 1:3  # define vector
vec_tor2 <- 6:4  # define vector
# bind vectors into columns
cbind(vec_tor1, vec_tor2)
# bind vectors into rows
rbind(vec_tor1, vec_tor2)
# extend to four elements
vec_tor2 <- c(vec_tor2, 7)
# recycling rule applied
cbind(vec_tor1, vec_tor2)
# another example of recycling rule
1:6 + c(10, 20)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Replicating Objects Using \texttt{rep()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{rep()} replicates vectors and lists a given number of times,
      \vskip1ex
      \texttt{rep()} accepts a vector or list \texttt{"x"}, and an integer specifying the type and number of replications,
      \vskip1ex
      Argument \texttt{"times"} replicates the whole vector a given number of times,
      \vskip1ex
      Argument \texttt{"each"} replicates each vector element a given number of times,
      \vskip1ex
      Argument \texttt{"length.out"} replicates the whole vector a certain number of times, so that the output vector length is equal to \texttt{"length.out"},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# replicate a single element
rep("a", 5)
# replicate the whole vector several times
rep(c("a", "b"), 5)
rep(c("a", "b"), times=5)
# replicate the first element, then the second, etc.
rep(c("a", "b"), each=5)
# replicate to specified length
rep(c("a", "b"), length.out=5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Multiplying Vectors and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The multiplication \texttt{"*"} \emph{operator} performs \emph{element-wise} (\emph{element-by-element}) multiplication of vectors and matrices,
      \vskip1ex
      By default the matrix elements are multiplied column-wise by the vector elements: the first matrix element in the first column is multiplied by the first vector element, then the second matrix column is multiplied by the remaining vector elements, etc.
      \vskip1ex
      The \emph{recycling rule} is applied to the vector elements as needed,
      \vskip1ex
      The transpose function \texttt{t()} can be applied if we want to perform row-wise multiplication,
     \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# define vector and matrix
vec_tor1 <- c(2, 4, 3)
mat_rix <- matrix(sample(1:12), ncol=3)
# multiply matrix by vector column-wise
vec_tor1 * mat_rix
mat_rix * vec_tor1
# multiply matrix by vector row-wise
t(vec_tor1 * t(mat_rix))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Inner Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{\%*\%} operator performs \emph{inner} (\emph{scalar}) multiplication of vectors and matrices,
      \vskip1ex
      \emph{Inner} multiplication multiplies the rows of one matrix with the columns of another matrix, so that each pair produces a single number:
      \begin{displaymath}
        C_{i,j} = \sum_{k=1}^n A_{i,k} B_{k,j}
      \end{displaymath}
      \emph{Inner} multiplication produces a vector or matrix with a reduced dimension,
      \vskip1ex
      \emph{Inner} multiplication requires the dimensions of the matrices to be \emph{conformable} (number of columns in the first matrix must be equal to the number of rows in the second),
      \vskip1ex
      The function \texttt{drop()} removes any dimensions of length \emph{one},
      \vskip1ex
      The functions \texttt{rowSums()} and \texttt{colSums()} calculate the sums of rows and columns, and they're very fast because they pass their data to compiled \texttt{C++} code,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1))>>=
vec_tor1
vec_tor2 <- 6:4  # define vector
# multiply two vectors element-by-element
vec_tor1 * vec_tor2
# calculate inner product
vec_tor1 %*% vec_tor2
# calculate inner product and drop dimensions
drop(vec_tor1 %*% vec_tor2)
# multiply columns of matrix by vector
mat_rix %*% vec_tor1  # single column matrix
drop(mat_rix %*% vec_tor1)  # vector
rowSums(t(vec_tor1 * t(mat_rix)))
# using rowSums() and t() is 10 times slower than %*%
library(microbenchmark)
summary(microbenchmark(
  in_ner=drop(mat_rix %*% vec_tor1),
  row_sums=rowSums(t(vec_tor1 * t(mat_rix))),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Transpose}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{t()} returns the transpose of a matrix,
      \vskip1ex
      The function \texttt{crossprod()} also performs \emph{inner} (\emph{scalar}) multiplication, exactly the same as the \texttt{\%*\%} operator, but is slightly faster,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=FALSE>>=
library(microbenchmark)
# multiply matrix by vector fails because dimensions aren't conformable
vec_tor1 %*% mat_rix
# works after transpose
drop(vec_tor1 %*% t(mat_rix))
# calculate inner product
crossprod(vec_tor1, vec_tor2)
# create matrix and vector
mat_rix <- matrix(1:3000, ncol=3)
tmat_rix <- t(mat_rix)
vec_tor <- 1:3
# crossprod is slightly faster than "%*%" operator
summary(microbenchmark(
  cross_prod=crossprod(tmat_rix, vec_tor),
  inner_prod=mat_rix %*% vec_tor,
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Matrix Outer Multiplication}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An \emph{outer} product consists of all possible products of pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = A_i \cdot B_j
      \end{displaymath}
      An \emph{outer} product of a function consists of applying it to all possible pairs of elements of two objects:
      \begin{displaymath}
        C_{i,j} = f(A_i, B_j)
      \end{displaymath}
      \emph{Outer} multiplication produces an object with dimension equal to the sum of the factors' dimensions, and with the number of elements equal to the product of the factors' elements,
      \vskip1ex
      The function \texttt{outer()} calculates the \emph{outer} product of two matrices, and by default multiplies the elements of its arguments,
      \vskip1ex
      \texttt{outer()} can also calculate the values of a vectorized function of two variables passed to the \texttt{"FUN"} argument,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# define named vectors
vec_tor1 <- sample(1:4)
names(vec_tor1) <-
  paste0("row", 1:4, "=", vec_tor1)
vec_tor1
vec_tor2 <- sample(1:3)
names(vec_tor2) <-
  paste0("col", 1:3, "=", vec_tor2)
vec_tor2
# calculate outer product of two vectors
mat_rix <- outer(vec_tor1, vec_tor2)
mat_rix
# calculate vectorized function spanned over two vectors
mat_rix <- outer(vec_tor1, vec_tor2,
                 FUN=function(x1, x2) x2*sin(x1))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions have three components:
      \begin{itemize}
        \item a list of formal arguments,
        \item a body containing \texttt{R} code,
        \item an environment,
      \end{itemize}
      An \texttt{R} function plus its environment is referred to as a function \emph{closures},
      \vskip1ex
      The function body should be enclosed in curly braces \texttt{\{\}}, unless it contains a single command, then it doesn't have to enclosed,
      \vskip1ex
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body,
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a function with two arguments
test_func <- function(first_arg, second_arg) {  # body
  first_arg + second_arg  # returns last evaluated statement
}  # end test_func

test_func(1, 2)  # apply the function
args(test_func)  # display argument

# define function that uses variable from enclosure environment
test_func <- function(first_arg, second_arg) {
  first_arg + second_arg + glob_var
}  # end test_func

test_func(3, 2)  # error - glob_var doesn't exist yet!
glob_var <- 10  # create glob_var
test_func(3, 2)  # now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The formal arguments of a function are defined in its argument list,
      \vskip1ex
      When a function is called, it's passed a list of actual function arguments,
      \vskip1ex
      Formal arguments can be \emph{bound} to actual arguments either by name or by position:
      \begin{itemize}
        \item by name: formal arguments are \emph{bound} to actual arguments with the same name,
        \item by position: the first formal argument is \emph{bound} to the first actual argument, etc.
      \end{itemize}
      \emph{Binding} by name takes precedence over \emph{binding} by position: first all the named arguments are \emph{bound}, then the remaining arguments are \emph{bound} by position,
      \vskip1ex
      Partial argument names are \emph{bound} to full names,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
test_func <- function(first_arg, second_arg) {
# last statement of function is return value
  first_arg + 2*second_arg
}  # end test_func
test_func(first_arg=3, second_arg=2)  # bind by name
test_func(first=3, second=2)  # partial name binding
test_func(3, 2)  # bind by position
test_func(second_arg=2, 3)  # mixed binding
test_func(3, 2, 1)  # too many arguments
test_func(2)  # not enough arguments
      @
      \vspace{-1em}
      All the actual arguments must be \emph{bound} to formal arguments, and if not then an \texttt{"unused argument"} error is produced,
      \vskip1ex
      If there aren't enough formal arguments, then an \texttt{"argument is missing"} error is produced,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Default Values for Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Formal arguments may be assigned default values, so that when the actual arguments are missing then their default values are used instead,
      \vskip1ex
      Default values are often assigned to function parameters, that determine the function's behavior,
      \vskip1ex
      Default values can be specified as a vector of strings, representing the possible values of a function's parameter,
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it,
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# function "paste" has two arguments with default values
str(paste)
# default values of arguments can be specified in argument list
test_func <- function(first_arg, fac_tor=1) {
  fac_tor*first_arg
}  # end test_func
test_func(3)  # default value used for second argument
test_func(3, 2)  # default value over-ridden
# default values can be a vector of strings
test_func <- function(in_put=c("first_val", "second_val")) {
  in_put <- match.arg(in_put)  # match to arg list
  in_put
}  # end test_func
test_func("second_val")
test_func("se")  # partial name binding
test_func("some_val")  # invalid string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Return Values of \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body,
      \vskip1ex
      \texttt{return()} statements are inserted in logical branches to terminate function execution and return its intended value,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define function that returns NULL for non-numeric argument
test_func <- function(in_put) {
  if (!is.numeric(in_put)) {
    warning(paste("argument", in_put, "isn't numeric"))
    return(NULL)
  }
  2*in_put
}  # end test_func

test_func(2)
test_func("hello")
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Plotting in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{Plotting in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
  \begin{columns}[T]
    \column{0.45\textwidth}
\begin{block}{Functions in package \emph{graphics} for creating static plots:}
      \texttt{plot()} plots a line or scatter plot,\\
      \texttt{lines()} adds lines to a plot,\\
      \texttt{curve()} plots a function given by its name,\\
      \texttt{title()} adds a title to a plot,\\
      \texttt{legend()} adds a legend to a plot,\\
      \texttt{x11()} opens a \emph{Windows} graphics device,\\
      \texttt{par()} sets graphical plot parameters,
\end{block}
\begin{block}{Functions in package \emph{ggplot2} for creating static plots:}
      \texttt{ggplot()} creates a new ggplot object,\\
      \texttt{aes()} specifies \emph{aesthetics}, i.e. mappings between data elements (rows, columns) and plot elements (points, lines),\\
      \texttt{geom\_point()} adds plot points,\\
      \texttt{geom\_line()} adds plot lines,\\
      \texttt{theme()} customizes plot objects,
\end{block}
    \column{0.45\textwidth}
\begin{block}{Functions in package \emph{plotly} for creating dynamic plots:}
      \texttt{plot\_ly()} creates a new plotly object,\\
      \texttt{add\_trace()} adds elements to a \emph{plotly} plot,\\
      \texttt{layout()} modifies the layout of a \emph{plotly} plot,\\
\end{block}
\begin{block}{Functions in package \emph{dygraphs} for creating dynamic time series plots:}
      \texttt{dygraph()} creates an interactive time series plot,\\
      \texttt{dyOptions()} adds options (like colors, etc.) to a \emph{dygraph} plot,\\
      \texttt{dyRangeSelector()} adds a date range selector to the bottom of a \emph{dygraphs} plot,
\end{block}
  \end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package \protect\emph{graphics} Help and Documentation}
\begin{frame}[t]{\subsecname}

\vspace{-1em}
\begin{block}{General}
    CRAN Graphics task view:  \url{http://cran.r-project.org/web/views/Graphics.html}
\end{block}

\begin{block}{Tutorials on Charts and Plotting}
    \hskip1em\url{http://www.statmethods.net/graphs/index.html}\\
    \hskip1em\url{http://www.statmethods.net/advgraphs/index.html}\\
    \hskip1em\url{http://en.wikibooks.org/wiki/R_Programming/Graphics\#Standard_R_graphs}\\
    \hskip1em\url{http://ww2.coastal.edu/kingw/statistics/R-tutorials/graphs.html}\\
    \hskip1em\url{http://www.harding.edu/fmccown/r/}
\end{block}

\begin{block}{Graphical Parameters}
    \hskip1em\url{http://www.statmethods.net/advgraphs/parameters.html}\\
    \hskip1em\url{http://research.stowers-institute.org/efg/R/Graphics/Basics/mar-oma/index.htm}\\
    \hskip1em\url{http://www.programmingr.com/content/controlling-margins-and-axes-oma-and-mgp/}
\end{block}

\begin{block}{Galleries of Charts}
    Vistat reproducible gallery of statistical graphics:  \url{http://vis.supstat.com/}\\
    Gallery of data charts:  \url{http://zoonek2.free.fr/UNIX/48_R/03.html}\\
    Gallery of data charts and \texttt{R} code:  \url{http://rgm3.lab.nig.ac.jp/RGM/R_image_list}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Plotting Using the Base \protect\emph{graphics} Package}


%%%%%%%%%%%%%%%
\subsection{Plotting Scatterplots With Labels}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \emph{graphics} is one of the base packages in \texttt{R}, and offers a number of plotting capabilities,
      \vskip1ex
      The function \texttt{plot()} by default plots a scatterplot, but can also plot lines using the argument \texttt{type="l"},
      \vskip1ex
      The function \texttt{text()} draws text strings on a plot, and can be used to draw plot labels,
      <<eval=FALSE,echo=(-(1:1))>>=
library(quantmod)
some_cars <- mtcars[sample(NROW(mtcars), 10), ]
# plot scatterplot horsepower vs miles per gallon
plot(some_cars[, "hp"], some_cars[, "mpg"],
     xlab="horsepower", ylab="miles per gallon",
     main="miles per gallon vs horsepower")
# add a solid red point (pch=16) for the last car
points(x=some_cars[NROW(some_cars), "hp"],
       y=some_cars[NROW(some_cars), "mpg"],
       col="red", pch=16)
# add labels with the car names
text(x=some_cars[, "hp"], y=some_cars[, "mpg"],
     labels=rownames(some_cars[, ]),
     pos=1, cex=0.8)
# or add labels using wordcloud, to prevent overlaps
library(wordcloud)
textplot(x=some_cars[, "hp"], y=some_cars[, "mpg"],
         words=rownames(some_cars))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/scatter_plot}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Line Plots Using the Base \protect\emph{graphics} Package}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{plot()} accepts many different graphical parameters, including:
      \begin{itemize}
        \item \texttt{type}: type of plot,
        \item \texttt{lwd}: line width,
        \item \texttt{col}: plotting object color,
        \item \texttt{xlab}, \texttt{ylab}: axis titles,
        \item \texttt{xlim}, \texttt{ylim}: axis range,
        \item \texttt{main}:  plot title,
      \end{itemize}
      \vspace{-1em}
      <<line_plot,eval=FALSE,echo=(-(1:1)),fig.show="hide">>=
# plot the tree Height
plot(trees[, "Height"],
     type="l",
     lwd=2,
     col="blue",
     main="Tree heights and volumes",
     xlab="tree number", ylab="",
     ylim=c(min(trees[, c("Height", "Volume")]),
            max(trees[, c("Height", "Volume")])))
# plot the tree Volume
lines(trees[, "Volume"], lwd=2, col="green")
# add legend
legend(x="left", legend=c("Height", "Volume"),
       inset=0.1, cex=1.0, bg="white",
       lwd=2, lty=c(1, 1), col=c("blue", "green"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/line_plot.png}\\
      The function \texttt{lines()} adds lines to a plot,
      \vskip1ex
      The function \texttt{legend()} adds a legend to a plot,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Mathematical Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plotting functions in package \emph{graphics}:
      \vskip1ex
      \texttt{x11()} opens a \emph{Windows} graphics device,
      \vskip1ex
      \texttt{plot()} creates a scatterplot or line plot,
      \vskip1ex
      \texttt{lines()} plots a line on an existing plot,
      \vskip1ex
      \texttt{title()} adds a title to a plot,
      <<sincosplot,eval=FALSE,fig.show="hide">>=
x_var <- seq(-2*pi, 2*pi, len=100)  # x values

# open Windows graphics device
x11(width=11, height=7, title="simple plot")

# plot a sine function using basic line plot
plot(x=x_var, y=sin(x_var), xlab="x-val",
     ylab="y-val", type="l", lwd=2, col="red")
# add a cosine function
lines(x=x_var, y=cos(x_var), lwd=2, col="blue")
# add title
title(main="sine and cosine functions", line=0.1)
# add legend
legend(x="topright", legend=c("sine", "cosine"),
       title="legend", inset=0.1, cex=1.0, bg="white",
       lwd=2, lty=c(1, 1), col=c("red", "blue"))
graphics.off()  # close all graphics devices
      @
    \column{0.5\textwidth}
    \vspace{-3em}
    \includegraphics[width=0.5\paperwidth]{figure/sincosplot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting Mathematical Functions Using \texttt{curve()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} has dedicated functions for plotting mathematical functions,
      \vskip1ex
      The function \texttt{curve()} plots a function defined by its name,
      <<funplot,eval=FALSE,echo=(-(1:1)),fig.show="hide">>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# plot a Normal probability distribution
curve(expr=dnorm, type="l", xlim=c(-3, 3),
      xlab="", ylab="", lwd=2, col="blue")
# add shifted Normal probability distribution
curve(expr=dnorm(x, mean=1), add=TRUE,
      type="l", lwd=2, col="red")

# add title
title(main="Normal probability distribution functions",
      line=0.1)
# add legend
legend(x="topright", legend=c("Normal", "shifted"),
       title="legend", inset=0.05, cex=0.8, bg="white",
       lwd=2, lty=c(1, 1), col=c("blue", "red"))
      @
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{figure/funplot-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Graphical Parameters}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{par()} sets graphical parameters used for plotting, and invisibly returns existing parameters as a named list,
      <<par_ams,eval=FALSE,fig.show="hide">>=
graph_params <- par()  # get existing parameters
par("mar")  # get plot margins
par(mar=c(2, 1, 2, 1))  # set plot margins
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 1, 0))  # set title and label margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(las=1)  # set axis labels to horizontal
par(ask=TRUE)  # pause, ask before plotting
par(mfrow=c(2, 2))  # plot on 2x2 grid by rows
for (i in 1:4) {  # plot 4 panels
  barplot(sample(1:6), main=paste("panel", i),
          col=rainbow(6), border=NA, axes=FALSE)
  box()
}  # end for
par(ask=FALSE)  # restore automatic plotting
par(new=TRUE)  # allow new plot on same chart
par(graph_params)  # restore original parameters
      @
    \column{0.5\textwidth}
      \vspace{-3em}
      \includegraphics[width=0.5\paperwidth]{figure/par_ams-1}
      \vspace{-3em}
      \begin{itemize}
        \item \texttt{cex} set graphic scales,
        \item \texttt{mar} \& \texttt{oma} set plot margins,
        \item \texttt{mgp} set title and label margins,
        \item \texttt{las} set orientation of axis labels,
        \item \texttt{mfcol} \& \texttt{mfrow} set number of plot panels,
      \end{itemize}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Plotting Probability Distributions}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Normal (Gaussian)} Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Normal (Gaussian)} probability density function is given by:
      \begin{displaymath}
        N(x, \mu, \sigma) = \frac{e^{-(x-\mu)^2/2\sigma^2}}{\sigma\sqrt{2 \pi}}
      \end{displaymath}
      The \emph{Standard Normal} distribution $N(0, 1)$ is a special case of the \emph{Normal} $N(\mu, \sigma)$ with $\mu=0$ and $\sigma=1$,
      \vskip1ex
      The function \texttt{dnorm()} calculates the \emph{Normal} probability density,
      <<echo=TRUE,eval=FALSE>>=
x_var <- seq(-5, 7, length=100)
y_var <- dnorm(x_var, mean=1.0, sd=2.0)
plot(x_var, y_var, type="l", lty="solid",
     xlab="", ylab="")
title(main="Normal Density Function", line=0.5)
star_t <- 3; fin_ish <- 5  # set lower and upper bounds
# set polygon base
are_a <- ((x_var >= star_t) & (x_var <= fin_ish))
polygon(c(star_t, x_var[are_a], fin_ish),  # draw polygon
        c(-1, y_var[are_a], -1), col="red")
      @
    \column{0.5\textwidth}
    \includegraphics[width=0.5\paperwidth]{figure/norm_dist}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Normal (Gaussian)} Probability Distributions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plots of several \emph{Normal} distributions with different values of $\sigma$, using the function \texttt{curve()} for plotting functions given by their name,
      <<norm_dist_mult_curves,eval=FALSE,echo=(-(1:1)),fig.show="hide">>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
sig_mas <- c(0.5, 1, 1.5, 2)  # sigma values
# create plot colors
col_ors <- c("red", "black", "blue", "green")
# create legend labels
lab_els <- paste("sigma", sig_mas, sep="=")
for (in_dex in 1:4) {  # plot four curves
curve(expr=dnorm(x, sd=sig_mas[in_dex]),
      type="l", xlim=c(-4, 4),
      xlab="", ylab="", lwd=2,
      col=col_ors[in_dex],
      add=as.logical(in_dex-1))
}  # end for
# add title
title(main="Normal Distributions", line=0.5)
# add legend
legend("topright", inset=0.05, title="Sigmas",
       lab_els, cex=0.8, lwd=2, lty=c(1, 1, 1, 1),
       col=col_ors)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/norm_dist_mult_curves-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Normal} Probability Distributions as Lines}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Plots of several \emph{Normal} distributions with different values of $\sigma$,
      <<norm_dist_mult,eval=FALSE,echo=(-(1:2)),fig.show="hide">>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
x_var <- seq(-4, 4, length=100)
sig_mas <- c(0.5, 1, 1.5, 2)  # sigma values
# create plot colors
col_ors <- c("red", "black", "blue", "green")
# create legend labels
lab_els <- paste("sigma", sig_mas, sep="=")
# plot the first chart
plot(x_var, dnorm(x_var, sd=sig_mas[1]),
     type="n", xlab="", ylab="",
     main="Normal Distributions")
# add lines to plot
for (in_dex in 1:4) {
  lines(x_var, dnorm(x_var, sd=sig_mas[in_dex]),
        lwd=2, col=col_ors[in_dex])
}  # end for
# add legend
legend("topright", inset=0.05, title="Sigmas",
       lab_els, cex=0.8, lwd=2, lty=c(1, 1, 1, 1),
       col=col_ors)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/norm_dist_mult-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Chi-squared} Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_1, \ldots , z_k$ be independent standard \emph{Normal} random variables,
      \vskip1ex
      Then the random variable $X = \sum_{i=1}^k z_i^2$ is distributed according to the \emph{Chi-squared} distribution with \texttt{k} degrees of freedom: $X \sim \chi_k^2$, and its probability density function is given by:
      \begin{displaymath}
        P(x) = \frac{x^{k/2-1}\,e^{-x/2}}{2^{k/2}\, \Gamma(k/2)}
      \end{displaymath}
        <<eval=FALSE,echo=(-(1:2))>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
deg_free <- c(2, 5, 8, 11)  # df values
# create plot colors
col_ors <- c("red", "black", "blue", "green")
# create legend labels
lab_els <- paste("df", deg_free, sep="=")
for (in_dex in 1:4) {  # plot four curves
curve(expr=dchisq(x, df=deg_free[in_dex]),
      type="l", xlim=c(0, 20), ylim=c(0, 0.3),
      xlab="", ylab="", lwd=2,
      col=col_ors[in_dex],
      add=as.logical(in_dex-1))
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/chisq_dist_mult.png}\\
      \vspace{-1em}
        <<eval=FALSE,echo=TRUE>>=
# add title
title(main="Chi-squared Distributions", line=0.5)
# add legend
legend("topright", inset=0.05,
       title="Degrees of freedom", lab_els,
       cex=0.8, lwd=6, lty=c(1, 1, 1, 1),
       col=col_ors)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{Chi-squared} Distribution as Line}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_1, \ldots , z_k$ be independent standard \emph{Normal} random variables,
      \vskip1ex
      Then the random variable $X = \sum_{i=1}^k z_i^2$ is distributed according to the \emph{Chi-squared} distribution with \texttt{k} degrees of freedom: $X \sim \chi_k^2$, and its probability density function is given by:
      \begin{displaymath}
        P(x) = \frac{x^{k/2-1}\,e^{-x/2}}{2^{k/2}\, \Gamma(k/2)}
      \end{displaymath}
        <<eval=FALSE,echo=(-(1:2))>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
deg_free <- c(2, 5, 8, 11)  # df values
# create plot colors
col_ors <- c("red", "black", "blue", "green")
# create legend labels
lab_els <- paste("df", deg_free, sep="=")
# plot an empty chart
x_var <- seq(0, 20, length=100)
plot(x_var, dchisq(x_var, df=deg_free[1]),
     type="n", xlab="", ylab="", ylim=c(0, 0.3))
# add lines to plot
for (in_dex in 1:4) {
  lines(x_var, dchisq(x_var, df=deg_free[in_dex]),
        lwd=2, col=col_ors[in_dex])
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/chisq_dist_mult.png}\\
      \vspace{-1em}
        <<eval=FALSE,echo=TRUE>>=
# add title
title(main="Chi-squared Distributions", line=0.5)
# add legend
legend("topright", inset=0.05,
       title="Degrees of freedom", lab_els,
       cex=0.8, lwd=6, lty=c(1, 1, 1, 1),
       col=col_ors)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Student's \protect\emph{t-distribution}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_{1},\ldots , z_{\nu}$ be independent standard normal random variables, with sample mean: $\bar{z}=\frac{1}{\nu} \sum_{i=1}^{\nu} z_i$ ($\mathbb{E}[\bar{z}]=\mu$) and sample variance: $\hat\sigma^2=\frac{1}{\nu-1} \sum_{i=1}^{\nu} (z_i-\bar{z})^2$
      \vskip1ex
      Then the random variable (\emph{t-ratio}):
      \begin{displaymath}
        t = \frac{\bar{z} - \mu}{\hat\sigma / \sqrt{\nu}}
      \end{displaymath}
      Follows the \emph{t-distribution} with $\nu$ degrees of freedom, with the probability density function:
      \begin{displaymath}
        P(t) = \frac{\Gamma((\nu+1)/2)}{\sqrt{\pi \nu}\,\Gamma(\nu/2)}\, (1 + t^2/\nu)^{-(\nu+1)/2}
      \end{displaymath}
      \vspace{-1em}
        <<eval=FALSE,echo=(-(1:2))>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
deg_free <- c(3, 6, 9)  # df values
col_ors <- c("black", "red", "blue", "green")
lab_els <- c("normal", paste("df", deg_free, sep="="))
# plot a Normal probability distribution
curve(expr=dnorm, type="l", xlim=c(-4, 4),
      xlab="", ylab="", lwd=2)
for (in_dex in 1:3) {  # plot three t-distributions
curve(expr=dt(x, df=deg_free[in_dex]),
      type="l", xlab="", ylab="", lwd=2,
      col=col_ors[in_dex+1], add=TRUE)
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/t_dist_mult.png}\\
      \vspace{-1em}
        <<eval=FALSE,echo=TRUE>>=
# add title
title(main="t-distributions", line=0.5)
# add legend
legend("topright", inset=0.05,
       title="Degrees\n of freedom", lab_els,
       cex=0.8, lwd=6, lty=c(1, 1, 1, 1),
       col=col_ors)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Student's \protect\emph{t-distribution} as Line}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $z_{1},\ldots , z_{\nu}$ be independent standard normal random variables, with sample mean: $\bar{z}=\frac{1}{\nu} \sum_{i=1}^{\nu} z_i$ ($\mathbb{E}[\bar{z}]=\mu$) and sample variance: $\hat\sigma^2=\frac{1}{\nu-1} \sum_{i=1}^{\nu} (z_i-\bar{z})^2$
      \vskip1ex
      Then the random variable (\emph{t-ratio}):
      \begin{displaymath}
        t = \frac{\bar{z} - \mu}{\hat\sigma / \sqrt{\nu}}
      \end{displaymath}
      Follows the \emph{t-distribution} with $\nu$ degrees of freedom, with the probability density function:
      \begin{displaymath}
        P(t) = \frac{\Gamma((\nu+1)/2)}{\sqrt{\pi \nu}\,\Gamma(\nu/2)}\, (1 + t^2/\nu)^{-(\nu+1)/2}
      \end{displaymath}
      \vspace{-1em}
        <<eval=FALSE,echo=(-(1:2))>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
x_var <- seq(-4, 4, length=100)
deg_free <- c(3, 6, 9)  # df values
col_ors <- c("black", "red", "blue", "green")
lab_els <- c("normal", paste("df", deg_free, sep="="))
# plot chart of normal distribution
plot(x_var, dnorm(x_var), type="l",
     lwd=2, xlab="", ylab="")
for (in_dex in 1:3) {  # add lines for t-distributions
  lines(x_var, dt(x_var, df=deg_free[in_dex]),
        lwd=2, col=col_ors[in_dex+1])
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/t_dist_mult.png}\\
      \vspace{-1em}
        <<eval=FALSE,echo=TRUE>>=
# add title
title(main="t-distributions", line=0.5)
# add legend
legend("topright", inset=0.05,
       title="Degrees\n of freedom", lab_els,
       cex=0.8, lwd=6, lty=c(1, 1, 1, 1),
       col=col_ors)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fisher's \protect\emph{F-distribution}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Let $\chi_m^2$ and $\chi_n^2$ be independent random variables following \emph{Chi-squared} distributions with \texttt{m} and \texttt{n} degrees of freedom,
      \vskip1ex
      Then the random variable:
      \begin{displaymath}
        F = \frac{m \, \chi_n^2}{n \, \chi_m^2}
      \end{displaymath}
      Follows the \emph{F-distribution} with \texttt{m} and \texttt{n} degrees of freedom, with the probability density function:
      \begin{displaymath}
        P(F) = \frac{\Gamma((m+n)/2) m^{m/2} n^{n/2}}{\Gamma(m/2) \Gamma(n/2)} \frac{F^{n/2-1}}{(m+nF)^{(m+n)/2}}
      \end{displaymath}
      \vspace{-1em}
        <<eval=FALSE,echo=(-(1:2))>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
deg_free <- c(3, 5, 9)  # df values
col_ors <- c("black", "red", "blue", "green")
lab_els <- paste0("df1=", deg_free, ", df2=3")
for (in_dex in 1:NROW(deg_free)) {  # plot four curves
curve(expr=df(x, df1=deg_free[in_dex], df2=3),
      type="l", xlim=c(0, 4),
      xlab="", ylab="", lwd=2,
      col=col_ors[in_dex],
      add=as.logical(in_dex-1))
}  # end for
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/f_dist.png}\\
      \vspace{-1em}
        <<eval=FALSE,echo=TRUE>>=
# add title
title(main="F-Distributions", line=0.5)
# add legend
legend("topright", inset=0.05, title="degrees of freedom",
       lab_els, cex=0.8, lwd=2, lty=1,
       col=col_ors)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Poisson Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Poisson} distribution gives the probability of the number of events observed in an interval of space or time,
      \vskip1ex
      The \emph{Poisson} probability function is given by:
      \begin{displaymath}
        P(n; \lambda) = \frac{{\lambda^n}{\cdot}{e^{-\lambda}}}{n!}
      \end{displaymath}
      The \emph{Poisson} random variable \texttt{n} is the number of events observed in the interval,
      \vskip1ex
      The parameter $\lambda$ is the average number of events that are observed in the interval,
      \vskip1ex
      An example of a \emph{Poisson} distribution is the number of mail items received each day,
      <<poiss_dist,eval=FALSE,echo=(-(1:2)),fig.show="hide">>=
rm(list=ls())
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
poisson_events <- 0:11  # Poisson events
poisson_freq <- dpois(poisson_events, lambda=4)
names(poisson_freq) <- as.character(poisson_events)
# Poisson function
poisson_func <- function(x, lambda)
                    {exp(-lambda)*lambda^x/factorial(x)}
curve(expr=poisson_func(x, lambda=4), xlim=c(0, 11), main="Poisson distribution",
      xlab="No. of events", ylab="Frequency of events", lwd=2, col="red")
legend(x="topright", legend="Poisson density", title="",
       inset=0.05, cex=0.8, bg="white", lwd=4, lty=1, col="red")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/poiss_dist-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Probability and Statistics}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Numbers}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Pseudo-random numbers are deterministic sequences of numbers which have some of the properties of random numbers, but they are not truly random numbers,
      \vskip1ex
      Pseudo-random number generators depend on a \emph{seed} value, and produce the same sequence of numbers for a given \emph{seed} value,
      \vskip1ex
      The function \texttt{set.seed()} initializes the random number generator by specifying the \emph{seed} value,
      \vskip1ex
      The choice of \emph{seed} value isn't important, and a given value is just good as any other one,
      \vskip1ex
      The function \texttt{runif()} produces random numbers from the \emph{uniform} distribution,
      \vskip1ex
      The function \texttt{rnorm()} produces random numbers from the \emph{normal} distribution,
      \vskip1ex
      The function \texttt{dnorm()} calculates the normal probability density,
      \vskip1ex
      The function \texttt{pnorm()} calculates the cumulative \emph{normal} distribution,
      \vskip1ex
      The function \texttt{qnorm()} calculates the inverse cumulative \emph{normal} distribution,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
set.seed(1121)  # reset random number generator
runif(3)  # three numbers from uniform distribution
runif(3)  # produce another three numbers
set.seed(1121)  # reset random number generator
runif(3)  # produce another three numbers

# produce random number from standard normal distribution
rnorm(1)
# produce five random numbers from standard normal distribution
rnorm(5)
# produce five random numbers from the normal distribution
rnorm(n=5, mean=1, sd=2)  # match arguments by name
# calculate cumulative standard normal distribution
c(pnorm(-2), pnorm(2))
# calculate inverse cumulative standard normal distribution
c(qnorm(0.75), qnorm(0.25))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Logistic Map}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{logistic map} is a recurrence relation which produces a deterministic sequence of numbers:
      \begin{displaymath}
        x_{n+1} = r x_n (1 - x_n)
      \end{displaymath}
      If the \emph{seed} value $x_0$ is in the interval $(0, 1)$ and if $r=4$, then the sequence $x_n$ is also contained in the interval $(0, 1)$,
      \vskip1ex
      The function \texttt{curve()} plots a function defined by its name,
      <<echo=TRUE,eval=FALSE>>=
# define logistic map function
log_map <- function(x, r=4) r*x*(1-x)
log_map(0.25, 4)
# plot logistic map
x11(width=6, height=5)
curve(expr=log_map, type="l", xlim=c(0, 1),
      xlab="x[n-1]", ylab="x[n]", lwd=2, col="blue",
      main="logistic map")
lines(x=c(0, 0.25), y=c(0.75, 0.75), lwd=2, col="blue")
lines(x=c(0.25, 0.25), y=c(0, 0.75), lwd=2, col="blue")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/logistic_map.png}\\
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generating Pseudo-Random Numbers Using Logistic Map}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{logistic map} can be used to calculate sequences of pseudo-random numbers,
      \vskip1ex
      For most \emph{seed} values $x_0$ and $r=4$, the \emph{logistic map} produces a pseudo-random sequence, but it's not uniformly distributed,
      \vskip1ex
      The inverse cosine function \texttt{acos()} transforms a \emph{logistic map} sequence into a uniformly distributed sequence,
      \begin{displaymath}
        u_n = \arccos(1 - 2 x_n) / \pi
      \end{displaymath}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# calculate uniformly distributed pseudo-random
# sequence using logistic map function
uni_form <- function(see_d, len_gth=10) {
  # pre-allocate vector instead of "growing" it
  out_put <- numeric(len_gth)
  # initialize
  out_put[1] <- see_d
  # perform loop
  for (i in 2:len_gth) {
    out_put[i] <- 4*out_put[i-1]*(1-out_put[i-1])
  }  # end for
  acos(1-2*out_put)/pi
}  # end uni_form
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/logistic_map_density.png}\\
      \vspace{-2em}
      <<echo=TRUE,eval=FALSE>>=
uni_form(see_d=0.1, len_gth=15)
plot(
  density(uni_form(see_d=runif(1), len_gth=1e5)),
  xlab="", ylab="", lwd=2, col="blue",
  main="uniform pseudo-random number density")
@
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generating Binomial Random Numbers}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{binomial} trial is a coin flip, that results in either a success or failure,
      \vskip1ex
      The \emph{binomial} distribution specifies the probability of obtaining a certain number of successes in a sequence of independent \emph{binomial} trials,
      \vskip1ex
      Let $p$ be the probability of obtaining a success in a \emph{binomial} trial, and let $(1-p)$ be the probability of failure,
      \vskip1ex
      $p = 0.5$ corresponds to flipping an unbiased coin,
      \vskip1ex
      The probability of obtaining \texttt{k} successes in \texttt{n} independent \emph{binomial} trials is equal to:
      \begin{displaymath}
        {n \choose k} p^k (1-p)^{(n-k)}
      \end{displaymath}
      The function \texttt{rbinom()} produces random numbers from the \emph{binomial} distribution,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
set.seed(1121)  # reset random number generator
# flip unbiased coin once, 20 times
rbinom(n=20, size=1, 0.5)
# number of heads after flipping twice, 20 times
rbinom(n=20, size=2, 0.5)
# number of heads after flipping thrice, 20 times
rbinom(n=20, size=3, 0.5)
# number of heads after flipping biased coin thrice, 20 times
rbinom(n=20, size=3, 0.8)
# number of heads after flipping biased coin thrice, 20 times
rbinom(n=20, size=3, 0.2)
# flip unbiased coin once, 20 times
sample(x=0:1, size=20, replace=TRUE)  # fast
as.numeric(runif(20) < 0.5)  # slower
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generating Random Samples and Permutations}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{sample} is a subset of elements taken from a set of data elements,
      \vskip1ex
      The function \texttt{sample()} produces a random sample form a vector of data elements,
      \vskip1ex
      By default the \emph{size} of the sample (the \texttt{size} argument) is equal to the number of elements in the data vector,
      \vskip1ex
      So the call \texttt{sample(da\_ta)} produces a random permutation of all the elements of \texttt{da\_ta},
      \vskip1ex
      If \texttt{replace=TRUE}, then \texttt{sample()} produces samples with replacement,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# permutation of five numbers
sample(x=5)
# permutation of four strings
sample(x=c("apple", "grape", "orange", "peach"))
# sample of size three
sample(x=5, size=3)
# sample with replacement
sample(x=5, replace=TRUE)
sample(  # sample of strings
  x=c("apple", "grape", "orange", "peach"),
  size=12,
  replace=TRUE)
# binomial sample: flip coin once, 20 times
sample(x=0:1, size=20, replace=TRUE)
# flip unbiased coin once, 20 times
as.numeric(runif(20) > 0.5)  # slower
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Statistical Estimators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A data \emph{sample} is a set of observations of a \emph{random variable},
      \vskip1ex
      Let $\{x_1,\ldots ,x_n\}$ be a data \emph{sample} of a \emph{random variable} \texttt{x},
      \vskip1ex
      Let \texttt{x} follow a probability distribution with population mean equal to $\mu$ and population standard deviation equal to $\sigma$,
      \vskip1ex
      A \emph{statistic} is a function of a data \emph{sample}:  $f( x_1,\ldots ,x_n )$,
      \vskip1ex
      A \emph{statistic} is itself a \emph{random variable},
      \vskip1ex
      A statistical \emph{estimator} is a \emph{statistic} that provides an estimate of a \emph{distribution} parameter,
      \vskip1ex
      For example:
      \begin{displaymath}
        \bar{x}=\frac{1}{n}{\sum_{i=1}^n x_i}
      \end{displaymath}
      Is an \emph{estimator} of the \emph{mean} of the \emph{distribution},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2))>>=
rm(list=ls())
set.seed(1121)  # reset random number generator
# sample from Standard Normal Distribution
sam_ple <- rnorm(1000)

mean(sam_ple)  # sample mean

median(sam_ple)  # sample median

sd(sam_ple)  # sample standard deviation
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Estimators of Higher Moments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The estimators of moments of a probability distribution, based on a \emph{sample} of data, are given by:
      \vskip1ex
      Sample mean: $\bar{x}=\frac{1}{n} \sum_{i=1}^n x_i$
      \vskip1ex
      Sample variance: $\hat\sigma^2=\frac{1}{n-1} \sum_{i=1}^n (x_i-\bar{x})^2$
      \vskip1ex
      With their expected values equal to the population mean and standard deviation:\\
      $\mathbb{E}[\bar{x}]=\mu$ \hskip0.5em and \hskip0.5em $\mathbb{E}[\hat\sigma]=\sigma$
      \vskip1ex
      The sample skewness (third moment) is equal to:
      \begin{displaymath}
        \hat{s}=\frac{n}{(n-1)(n-2)} \sum_{i=1}^n (\frac{x_i-\bar{x}}{\hat\sigma})^3
      \end{displaymath}
      The sample kurtosis (fourth moment) is equal to
      \begin{displaymath}
        \hat{k}=\frac{n(n+1)}{(n-1)(n-2)(n-3)} \sum_{i=1}^n (\frac{x_i-\bar{x}}{\hat\sigma})^4
      \end{displaymath}
      The normal distribution has zero skewness and kurtosis equal to 3,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:1)),eval=FALSE>>=
rm(list=ls())
# DAX returns
re_turns <- diff(log(EuStockMarkets[, 1]))
# number of observations
len_gth <- NROW(re_turns)
# mean of DAX returns
mean_rets <- mean(re_turns)
# standard deviation of DAX returns
sd_rets <- sd(re_turns)
# skew of DAX returns
len_gth/((len_gth-1)*(len_gth-2))*
  sum(((re_turns - mean_rets)/sd_rets)^3)
# kurtosis of DAX returns
len_gth*(len_gth+1)/((len_gth-1)^3)*
  sum(((re_turns - mean_rets)/sd_rets)^4)
# random normal returns
re_turns <- rnorm(len_gth, sd=2)
# mean and standard deviation of random normal returns
mean_rets <- mean(re_turns)
sd_rets <- sd(re_turns)
# skew of random normal returns
len_gth/((len_gth-1)*(len_gth-2))*
  sum(((re_turns - mean_rets)/sd_rets)^3)
# kurtosis of random normal returns
len_gth*(len_gth+1)/((len_gth-1)^3)*
  sum(((re_turns - mean_rets)/sd_rets)^4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Standard Errors of Estimators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Statistical estimators are functions of samples (which are random variables), and therefore are themselves \emph{random variables},
      \vskip1ex
      The \emph{standard error} (SE) of an estimator is defined as its \emph{standard deviation} (not to be confused with the \emph{population standard deviation} of the underlying random variable),
      \vskip1ex
      For example, the \emph{standard error} of the estimator of the mean is equal to:
      \begin{displaymath}
        \sigma_{\mu} = \frac{\sigma}{\sqrt{n}}
      \end{displaymath}
      Where $\sigma$ is the \emph{population standard deviation} (which is usually unkown),
      \vskip1ex
      The \emph{estimator} of this \emph{standard error} is equal to:
      \begin{displaymath}
        SE_{\mu} = \frac{\hat\sigma}{\sqrt{n}}
      \end{displaymath}
      where: $\hat\sigma^2=\frac{1}{n-1} \sum_{i=1}^n (x_i-\bar{x})^2$ is the sample standard deviation (the estimator of the population standard deviation),
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=FALSE>>=
set.seed(1121)  # reset random number generator
# sample from Standard Normal Distribution
len_gth <- 1000
sam_ple <- rnorm(len_gth)
# sample mean
mean(sam_ple)
# sample standard deviation
sd(sam_ple)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Hypothesis Testing}


%%%%%%%%%%%%%%%
\subsection{Hypothesis Testing}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Hypothesis Tests} are designed to test the validity of \emph{null hypotheses}, and they consist of:
      \begin{itemize}
        \item A \emph{null hypothesis},
        \item A test \emph{statistic} derived from the data sample,
        \item A \emph{p}-value: the conditional probability of observing the test statistic value, assuming the \emph{null hypothesis} is \texttt{TRUE},
        \item A \emph{significance level} $\alpha$ corresponding to a \emph{critical value},       \end{itemize}
      The \emph{p}-value is compared to the \emph{significance level} in order to decide whether to reject the \emph{null hypothesis} or not,
      \vskip1ex
      If the \emph{p}-value is less than the \emph{significance level} $\alpha$, then the \emph{null hypothesis} is rejected, 
      \vskip1ex
      It's possible for the \emph{null hypothesis} to be \texttt{TRUE}, but to obtain a very small \emph{p}-value purely by chance,
      \vskip1ex
      The \emph{p}-value is the probability of erroneously rejecting a \texttt{TRUE} \emph{null hypothesis}, due to the randomness of the data sample,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
### Perform two-tailed test that sample is
### from Standard Normal Distribution (mean=0, SD=1)
# generate vector of samples and store in data frame
test_frame <- data.frame(samples=rnorm(1e4))
# get p-values for all the samples
test_frame$p_values <- sapply(test_frame$samples, 
              function(x) 2*pnorm(-abs(x)))
# significance level, two-tailed test, critical value=2*SD
signif_level <- 2*(1-pnorm(2))
# compare p_values to significance level
test_frame$result <-
  test_frame$p_values > signif_level
# number of null rejections
sum(!test_frame$result) / NROW(test_frame)
# show null rejections
head(test_frame[!test_frame$result, ])
      @
      \vspace{-1em}
      The \emph{p}-value is a conditional probability, and is not equal to the un-conditional probability of the hypothesis being \texttt{TRUE},
      \vskip1ex
      In statistics we cannot \emph{prove} that a hypothesis is \texttt{TRUE} or not, but we can attempt to invalidate it, and conclude that it's unlikely to be \texttt{TRUE}, given the test statistic value and its \emph{p}-value,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Two-tailed Hypothesis Tests}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      In two-tailed hypothesis tests, both tails of the probability distribution contribute to the \emph{p}-value, 
      \vskip1ex
      Two-tailed hypothesis tests are applied for testing if the absolute value of a sample  exceeds the critical value, 
      <<echo=(-(1:2)),eval=FALSE>>=
x11(width=6, height=5)
par(mar=c(2, 2, 2, 1), oma=c(1, 1, 1, 1))
# plot the Normal probability distribution
curve(expr=dnorm(x, sd=1), type="l", xlim=c(-4, 4),
      xlab="", ylab="", lwd=3, col="blue")
title(main="Two-tailed Test", line=0.5)
# plot tails of the distribution using polygons
star_t <- 2; e_nd <- 4
# plot right tail using polygon
x_var <- seq(star_t, e_nd, length=100)
y_var <- dnorm(x_var, sd=1)
y_var[1] <- (-1)
y_var[NROW(y_var)] <- (-1)
polygon(x=x_var, y=y_var, col="red")
# plot left tail using polygon
y_var <- dnorm(-x_var, sd=1)
y_var[1] <- (-1)
y_var[NROW(y_var)] <- (-1)
polygon(x=(-x_var), y=y_var, col="red")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/hyp_test_tow_tail.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Visualizing Hypothesis Testing Using Package \protect\emph{ggplot2}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      In two-tailed hypothesis tests, both tails of the probability distribution contribute to the \emph{p}-value, 
      <<hyp_test_ggp2,echo=(-(1:2)),eval=FALSE,fig.show='hide'>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(ggplot2)  # load ggplot2

qplot(  # simple ggplot2
    main="Standard Normal Distribution",
    c(-4, 4),
    stat="function",
    fun=dnorm,
    geom="line",
    xlab=NULL, ylab=NULL
    ) +  # end qplot

theme(  # modify plot theme
    plot.title=element_text(vjust=-1.0),
    plot.background=element_blank()
    ) +  # end theme

geom_vline(  # add vertical line
  aes(xintercept=c(-2.0, 2.0)),
  colour="red",
  linetype="dashed"
  )  # end geom_vline
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/hyp_test_ggp2-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Visualizing Hypothesis Testing Using \protect\emph{ggplot2} (cont.)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      In two-tailed hypothesis tests, both tails of the probability distribution contribute to the \emph{p}-value, 
      <<hyp_test_ggp2_2,echo=(-(1:2)),eval=FALSE,fig.show='hide'>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
### create ggplot2 with shaded area
x_var <- -400:400/100
norm_frame <- data.frame(x_var=x_var,
                       d.norm=dnorm(x_var))
norm_frame$shade <- ifelse(
                  abs(norm_frame$x_var) >= 2,
                  norm_frame$d.norm, NA)
ggplot(  # main function
  data=norm_frame,
  mapping=aes(x=x_var, y=d.norm)
  ) +  # end ggplot
# plot line
  geom_line() +
# plot shaded area
  geom_ribbon(aes(ymin=0, ymax=shade), fill="red") +
# no axis labels
  xlab("") + ylab("") +
# add title
  ggtitle("Standard Normal Distribution") +
# modify plot theme
  theme(
        plot.title=element_text(vjust=-1.0),
        plot.background=element_blank()
  )  # end theme
      @
    \column{0.5\textwidth}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/hyp_test_ggp2_2-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Student's \protect\emph{t-test} for the Distribution Mean}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Student's \emph{t-test} is designed to test the \emph{null hypothesis} that the \emph{population mean} of the normally distributed sample: $\{x_1,\ldots ,x_n\}$ is equal to $\mu$, 
      \vskip1ex
      The test statistic is equal to the \emph{t-ratio}:
      \begin{displaymath}
        t = \frac{\bar{x} - \mu}{\hat\sigma / \sqrt{n}}
      \end{displaymath}
      Where $\bar{x}=\frac{1}{n} \sum_{i=1}^n x_i$ is the sample mean and $\hat\sigma^2=\frac{1}{n-1} \sum_{i=1}^n (x_i-\bar{x})^2$ is the sample variance,
      \vskip1ex
      Under the \emph{null hypothesis} the \emph{t-ratio} follows the \emph{t-distribution} with \texttt{n} degrees of freedom, with the probability density function: 
      \begin{displaymath}
        P(x) = \frac{\Gamma((n+1)/2)}{\sqrt{\pi n} \, \Gamma(n/2)} \, (1 + x^2/n)^{-(n+1)/2}
      \end{displaymath}
      Student's \emph{t-test} can also be used to test if two different normally distributed samples have equal \emph{population means},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# t-test for single sample
t.test(rnorm(100))
# t-test for two samples
t.test(rnorm(100),
       rnorm(100, mean=1))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Wilcoxon} Test for the Distribution Mean}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The one-sample \emph{Wilcoxon} test is designed to test the \emph{null hypothesis} that a sample: $\{x_1, \ldots , x_n\}$ was obtained from a probability distribution with \emph{population mean} equal to zero,
      \vskip1ex
      The two-sample \emph{Wilcoxon} test is designed to test the \emph{null hypothesis} that two samples: $\{x_1, \ldots , x_n\}$ and $\{y_1, \ldots , y_n\}$ were obtained from two probability distributions with equal \emph{population means},
      \vskip1ex
      Unlike Student's \emph{t-test}, the \emph{Wilcoxon} test doesn't assume that the samples are normally distributed, 
      \vskip1ex
      The function \texttt{wilcox.test()} calculates the \emph{Wilcoxon} statistic and its \emph{p}-value,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# Wilcoxon test for normal distribution
wilcox.test(rnorm(100))
# Wilcoxon test for two normal distributions
wilcox.test(rnorm(100), rnorm(100, mean=0.1))
# Wilcoxon test for two normal distributions
wilcox.test(rnorm(100), rnorm(100, mean=1.0))
# Wilcoxon test for a uniform versus normal distribution
wilcox.test(runif(100), rnorm(100))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Kolmogorov-Smirnov} Test for Probability Distributions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Kolmogorov-Smirnov} test is designed to test the \emph{null hypothesis} that two samples: $\{x_1, \ldots , x_n\}$ and $\{y_1, \ldots , y_n\}$ were obtained from the same probability distribution,
      \vskip1ex
      The \emph{Kolmogorov-Smirnov} statistic is the maximum difference between two empirical cumulative distribution functions (cumulative frequencies):
      \begin{displaymath}
        D = \sup_i | P(x_i) - P(y_i) |
      \end{displaymath}
      The function \texttt{ks.test()} calculates the \emph{Kolmogorov-Smirnov} statistic and its \emph{p}-value,
      \vskip1ex
      The second argument is either a \texttt{numeric} vector of data values, or a name of a cumulative distribution function,
      \vskip1ex
      The \emph{Kolmogorov-Smirnov} test can be used as a \emph{goodness of fit} test, to test if a set of observations fits a probability distribution,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# KS test for normal distribution
ks.test(rnorm(100), pnorm)
# KS test for uniform distribution
ks.test(runif(100), pnorm)
# KS test for two similar normal distributions
ks.test(rnorm(100), rnorm(100, mean=0.1))
# KS test for two different normal distributions
ks.test(rnorm(100), rnorm(100, mean=1.0))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Shapiro-Wilk} Test of Normality}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Shapiro-Wilk} test is designed to test the \emph{null hypothesis} that a sample: $\{x_1,\ldots ,x_n\}$ is from a normally distributed population,
      \vskip1ex
      The test statistic is equal to:
      \begin{displaymath}
        W = \frac {(\sum_{i=1}^n a_i x_{(i)})^2} {\sum_{i=1}^n (x_i-\bar{x})^2}
      \end{displaymath}
      Where the: $\{a_1,\ldots ,a_n\}$ are proportional to the \emph{order statistics} of random variables from the normal distribution,
      \vskip1ex
      $x_{(k)}$ is the \emph{k}-th \emph{order statistic}, and is equal to the \emph{k}-th smallest value in the sample: $\{x_1,\ldots ,x_n\}$,
      \vskip1ex
      The \emph{Shapiro-Wilk} statistic follows its own distribution, and is less than or equal to one,
      \vskip1ex
      The \emph{Shapiro-Wilk} statistic is close to one for samples from normal distributions,
      \vskip1ex
      The \emph{p}-value for DAX returns is extremely small, and we conclude that the \emph{null hypothesis} is \texttt{FALSE}, and the DAX returns are not from a normally distributed population,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# calculate DAX percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))

# Shapiro-Wilk test for normal distribution
shapiro.test(rnorm(NROW(dax_rets)))

# Shapiro-Wilk test for DAX returns
shapiro.test(dax_rets)

# Shapiro-Wilk test for uniform distribution
shapiro.test(runif(NROW(dax_rets)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{Jarque-Bera} Test of Normality}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Jarque-Bera} test is designed to test the \emph{null hypothesis} that a sample: $\{x_1,\ldots ,x_n\}$ is from a normally distributed population,
      \vskip1ex
      The test statistic is equal to:
      \begin{displaymath}
        JB= \frac{n}{6} (\hat{s}^2 + \frac{1}{4} (\hat{k} - 3)^2)
      \end{displaymath}
      Where the skewness and kurtosis are defined as:
      \begin{align*}
        \hat{s} = \frac{1}{n} \sum_{i=1}^n (\frac{x_i-\bar{x}}{\hat\sigma})^3
      &&
        \hat{k} = \frac{1}{n} \sum_{i=1}^n (\frac{x_i-\bar{x}}{\hat\sigma})^4
      \end{align*}
      The \emph{Jarque-Bera} statistic asymptotically follows the \emph{Chi-squared} distribution with two degrees of freedom,
      \vskip1ex
      The \emph{Jarque-Bera} statistic is small for samples from normal distributions,
      \vskip1ex
      The \emph{p}-value for DAX returns is extremely small, and we conclude that the \emph{null hypothesis} is \texttt{FALSE}, and the DAX returns are not from a normally distributed population,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1))>>=
dax_rets <- diff(log(EuStockMarkets[, 1]))
library(tseries)  # load package tseries

# Jarque-Bera test for normal distribution
jarque.bera.test(rnorm(NROW(dax_rets)))

# Jarque-Bera test for DAX returns
jarque.bera.test(dax_rets)

# Jarque-Bera test for uniform distribution
jarque.bera.test(runif(NROW(dax_rets)))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Simulation}


%%%%%%%%%%%%%%%
\subsection{Monte Carlo Simulation}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Monte Carlo} simulation consists of generating random samples from a given probability distribution,
      \vskip1ex
      The \emph{Monte Carlo} data samples can then used to calculate different parameters of the probability distribution (moments, quantiles, etc.), and its functionals,
      \vskip1ex
      The \emph{quantile} of a probability distribution is the value of the \emph{random variable} \texttt{x}, such that the probability of values less than \texttt{x} is equal to the given \emph{probability} \texttt{p},
      \vskip1ex
      The \emph{quantile} of a data sample can be calculated by first sorting the sample, and then finding the value corresponding closest to the given \emph{probability} \texttt{p},
      \vskip1ex
      The function \texttt{quantile()} calculates the sample quantiles, but it's quite slow,
      \vskip1ex
      The function \texttt{sort()} returns a vector sorted into ascending order,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
set.seed(1121)  # reset random number generator
# sample from Standard Normal Distribution
len_gth <- 1000
sam_ple <- rnorm(len_gth)
# sample mean - MC estimate
mean(sam_ple)
# sample standard deviation - MC estimate
sd(sam_ple)
# Monte Carlo estimate of cumulative probability
sam_ple <- sort(sam_ple)
pnorm(1)
sum(sam_ple<1)/len_gth
# Monte Carlo estimate of quantile
conf_level <- 0.99
qnorm(conf_level)
sam_ple[conf_level*len_gth]
quantile(sam_ple, probs=conf_level)
# analyze the source code of quantile()
stats:::quantile.default
# microbenchmark quantile
library(microbenchmark)
summary(microbenchmark(
  sam_ple=sam_ple[cut_off],
  quan_tile=quantile(sam_ple, probs=conf_level),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulating Brownian Motion Using \texttt{while()} Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{while()} loops are often used in simulations, when the number of required loops is unknown in advance,
      \vskip1ex
      Below is an example of a simulation of the path of \emph{Brownian Motion} crossing a barrier level,
      \vspace{-1em}
        <<simu_while,eval=FALSE,echo=(-(1:3)),fig.show='hide'>>=
x11(width=6, height=5)
par(oma=c(1, 1, 1, 1), mar=c(2, 2, 2, 1), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # reset random number generator
bar_rier <- 20  # barrier level
len_gth <- 1000  # number of simulation steps
pa_th <- numeric(len_gth)  # allocate path vector
pa_th[1] <- 0  # initialize path
in_dex <- 2  # initialize simulation index
while ((in_dex <= len_gth) &&
         (pa_th[in_dex - 1] < bar_rier)) {
# simulate next step
  pa_th[in_dex] <-
    pa_th[in_dex - 1] + rnorm(1)
  in_dex <- in_dex + 1  # advance in_dex
}  # end while
# fill remaining pa_th after it crosses bar_rier
if (in_dex <= len_gth)
  pa_th[in_dex:len_gth] <- pa_th[in_dex - 1]
# create daily time series starting 2011
ts_path <- ts(data=pa_th, frequency=365, start=c(2011, 1))
plot(ts_path, type="l", col="black",
     lty="solid", lwd=2, xlab="", ylab="")
abline(h=bar_rier, lwd=2, col="red")
title(main="Brownian motion crossing a barrier level", 
      line=0.5)
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth]{figure/simu_brown_barrier.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulating Brownian Motion Using Vectorized Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Simulations in \texttt{R} can be accelerated by pre-computing a vector of random numbers, instead of generatng them one at a time in a loop,
      \vskip1ex
      Vectors of random numbers allow using \emph{vectorized} functions, instead of inefficient (slow) \texttt{while()} loops,
      \vspace{-1em}
        <<simu_vector,eval=FALSE,echo=(-(1:3)),fig.show='hide'>>=
x11(width=6, height=5)
par(oma=c(1, 1, 1, 1), mar=c(2, 2, 2, 1), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # reset random number generator
bar_rier <- 20  # barrier level
len_gth <- 1000  # number of simulation steps
# simulate path of Brownian motion
pa_th <- cumsum(rnorm(len_gth))
# find index when pa_th crosses bar_rier
cro_ss <- which(pa_th > bar_rier)
# fill remaining pa_th after it crosses bar_rier
if (NROW(cro_ss)>0) {
  pa_th[(cro_ss[1]+1):len_gth] <-
    pa_th[cro_ss[1]]
}  # end if
# create daily time series starting 2011
ts_path <- ts(data=pa_th, frequency=365,
             start=c(2011, 1))
# create plot with horizontal line
plot(ts_path, type="l", col="black",
     lty="solid", lwd=2, xlab="", ylab="")
abline(h=bar_rier, lwd=2, col="red")
title(main="Brownian motion crossing a barrier level", 
      line=0.5)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth]{figure/simu_brown_barrier.png}
      The trade-off between speed and memory usage: more memory may be used than necessary, since the simulation may stop before all the pre-computed random numbers are used up,
      \vskip1ex
      But the simulation is much faster because the path is simulated using \emph{vectorized} functions,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Standard Errors of Estimators Using Bootstrap Simulation}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard errors of estimators can be calculated using a \emph{bootstrap} simulation,
      \vskip1ex
      The \emph{bootstrap} procedure generates new data by randomly sampling with replacement from the observed (empirical) data set,
      \vskip1ex
      The \emph{bootstrapped} dataset is used to re-calculate the estimator many times, producing a vector of values,
      \vskip1ex
      The \emph{bootstrapped} estimator values are then used to calculate the probability distribution of the estimator and its standard error,
      \vskip1ex
      Bootstrapping doesn't provide accurate estimates for estimators which are sensitive to the ordering and correlations in the data,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
set.seed(1121)  # reset random number generator
# sample from Standard Normal Distribution
len_gth <- 1000
sam_ple <- rnorm(len_gth)
# sample mean
mean(sam_ple)
# sample standard deviation
sd(sam_ple)
# bootstrap of sample mean and median
boot_strap <- sapply(1:10000, function(x) {
  boot_sample <- sam_ple[sample.int(len_gth,
                                    replace=TRUE)]
  c(mean=mean(boot_sample),
    median=median(boot_sample))
})  # end sapply
boot_strap[, 1:3]
# standard error from formula
sd(sam_ple)/sqrt(len_gth)
# standard error of mean from bootstrap
sd(boot_strap["mean", ])
# standard error of median from bootstrap
sd(boot_strap["median", ])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bootstrapping Standard Errors Using Parallel Computing}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{bootstrap} procedure performs a loop, which naturally lends itself to parallel computing,
      \vskip1ex
      Different functions from package \emph{parallel} need to be called depending on the operating system (\emph{Windows}, \emph{Mac-OSX}, or \emph{Linux}),
      \vskip1ex
      The function \texttt{makeCluster()} starts running \texttt{R} processes on several CPU cores under \emph{Windows},
      \vskip1ex
      The function \texttt{parLapply()} is similar to \texttt{lapply()}, and performs apply loops under \emph{Windows}, using parallel computing on several CPU cores,
      \vskip1ex
      The \texttt{R} processes started by \texttt{makeCluster()} don't inherit any data from the parent \texttt{R} process,
      \vskip1ex
      Therefore the required data must be passed into \texttt{parLapply()} via the dots \texttt{"..."} argument,
      \vskip1ex
      The function \texttt{mclapply()} performs apply loops using parallel computing on several CPU cores under \emph{Mac-OSX} or \emph{Linux},
      \vskip1ex
      The function \texttt{stopCluster()} stops the \texttt{R} processes running on several CPU cores,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
library(parallel)  # load package parallel
num_cores <- detectCores() - 1  # number of cores
clus_ter <- makeCluster(num_cores)  # initialize compute cluster under Windows
set.seed(1121)  # reset random number generator
# sample from Standard Normal Distribution
len_gth <- 1000
sam_ple <- rnorm(len_gth)
# bootstrap mean and median under Windows
boot_strap <- parLapply(clus_ter, 1:10000,
  function(x, sam_ple, len_gth) {
  boot_sample <- sam_ple[sample.int(len_gth, replace=TRUE)]
  c(mean=mean(boot_sample), median=median(boot_sample))
  }, sam_ple=sam_ple, len_gth=len_gth)  # end parLapply
# bootstrap mean and median under Mac-OSX or Linux
boot_strap <- mclapply(1:10000,
  function(x) {
  boot_sample <- sam_ple[sample.int(len_gth, replace=TRUE)]
  c(mean=mean(boot_sample), median=median(boot_sample))
  }, mc.cores=num_cores)  # end mclapply
boot_strap <- rutils::do_call(rbind, boot_strap)
# means and standard errors from bootstrap
apply(boot_strap, MARGIN=2,
      function(x) c(mean=mean(x), sd=sd(x)))
# standard error from formula
sd(sam_ple)/sqrt(len_gth)
stopCluster(clus_ter)  # stop R processes over cluster under Windows
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  Read all the lecture slides in \texttt{FRE6871\_Lecture\_1.pdf}, and run all the code in \texttt{FRE6871\_Lecture\_1.R}
\end{block}
\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read about the \emph{Vasicek} single factor model in \texttt{BOE Credit Risk Models.pdf} and in \texttt{Vasicek Portfolio Default Distribution.pdf}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
