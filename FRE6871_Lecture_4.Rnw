% FRE6871_Lecture_4

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture \#4]{FRE6871 R in Finance}
\subtitle{Lecture \#4, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@poly.edu}
\date{November 21, 2014}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Time Series Objects}


%%%%%%%%%%%%%%%
\subsection{\texttt{ts} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{stats} package contains functions for manipulating time series objects of class \texttt{ts},
        \vspace{-1em}
        <<ts_obj,echo=3:30,fig.show='hide'>>=
set.seed(1121)  # for reproducibility
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# create monthly time series starting 1990
ts_series <- ts(data=cumsum(rnorm(96)), 
             frequency=12, start=c(1990, 1))
class(ts_series)  # class 'ts'
attributes(ts_series)
matrix(methods(class="ts")[3:8], ncol=2)
# window the time series
window(ts_series, start=1992, end=1992.25)

plot(ts_series, type="l",  # create plot
     col="red", lty="solid", xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/ts_obj-1}
      \vspace{-5em}
      The function \texttt{ts()} creates a \texttt{ts} time series object from a \texttt{numeric} vector or matrix containing the values, and associated \texttt{date-time} information (the number of years),
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{EuStockMarkets}
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Data}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} includes a number of 'base' packages that are already installed and loaded,
      \vskip1ex
      \texttt{datasets} is a base package containing various datasets, for example \texttt{EuStockMarkets},
      \vskip1ex
      The \texttt{EuStockMarkets} dataset contains daily closing prices of european stock indices,
        <<eustx_ts,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
class(EuStockMarkets)  # multiple ts object
dim(EuStockMarkets)
head(EuStockMarkets)  # get first six rows
plot(EuStockMarkets, main="", xlab="")  # plot all the columns
title(main="EuStockMarkets", line=-1)  # add title
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Distribution of \subsecname \hskip0.5em Returns}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{hist()} calculates and plots a histogram,
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      The function \texttt{density()} calculates a kernel estimate of the probability density,
      \vskip1ex
      The function \texttt{lines()} draws a line through specified points,
        \vspace{-1em}
        <<eustx_rets,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate DAX percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# mean and standard deviation of returns
c(mean(dax_rets), sd(dax_rets))
# plot histogram
hist(dax_rets, breaks=30, main="", 
     xlim=c(-0.04, 0.04), ylim=c(0, 60), 
     xlab="", ylab="", freq = FALSE)
# draw kernel density of histogram
lines(density(dax_rets), col='red', lwd=2)
# add density of normal distribution
curve(expr=dnorm(x, mean=mean(dax_rets), sd=sd(dax_rets)), 
      add=TRUE, type="l", lwd=2, col="blue")
title(main="Return distributions", line=0)  # add title
# add legend
legend("topright", inset=0.05, cex=0.8, title=NULL, 
       leg=c(colnames(EuStockMarkets)[1], "Normal"), 
       lwd=2, bg="white", col=c("red", "blue"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_rets-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Quantile-Quantile Plot}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \texttt{Q-Q} plot is a plot of points from two probability distributions with the same quantiles,
      \vskip1ex
      The function \texttt{qqnorm()} produces a normal Q-Q plot,
      \vskip1ex
      The function \texttt{qqline()} fits a line to the normal quantiles,
      \vskip1ex
      The \texttt{DAX} Q-Q plot shows that the \texttt{DAX} return distribution has fat tails,
        <<eustx_qq,echo=2:30,fig.show='hide'>>=
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate percentage returns
dax_rets <- diff(log(EuStockMarkets[, 1]))
# create normal Q-Q plot
qqnorm(dax_rets, ylim=c(-0.04, 0.04), 
       xlab='Normal Quantiles', main='')
# fit a line to the normal quantiles
qqline(dax_rets, col='red', lwd=2)
plot_title <- paste(colnames(EuStockMarkets)[1], 
                  'Q-Q Plot')
title(main=plot_title, line=-1)  # add title
shapiro.test(dax_rets)  # Shapiro-Wilk test
      @

    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_qq-1}
      \vskip2ex
      The \emph{p}-value of the \emph{Shapiro-Wilk} test is very small, which shows that the \texttt{DAX} returns are not normal,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Boxplots}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{Box Plot} (box-and-whisker plot) is a graphical display of a distribution of values,
      \vskip1ex
      The \emph{box} represents the upper and lower quartiles, \\
      the vertical lines (whiskers) represent values beyond the quartiles, \\
      and open circles represent values beyond the nominal range (outliers),
      \vskip1ex
      The function \texttt{boxplot()} plots a box-and-whisker plot for a distribution of values,
      \vskip1ex
      \texttt{boxplot()} has two \texttt{methods}: one for \texttt{formula} objects (involving categorical variables), and another for \texttt{data frames},
      <<box_plots,echo=3:30,fig.height=8,fig.show='hide'>>=
par(oma=c(15, 1, 1, 1), mgp=c(1.5, 0.5, 0), mar=c(2.5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# boxplot method for formula
boxplot(formula=mpg ~ cyl, data=mtcars, 
        main="Mileage by number of cylinders", 
        xlab="Cylinders", ylab="Miles per gallon")

# calculate EuStockMarkets percentage returns
eu_rets <- diff(log(EuStockMarkets))
# boxplot method for data frame
boxplot(x=eu_rets)
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/box_plots-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} is designed for managing \emph{time series} and ordered objects,
      \vskip1ex
      The function \texttt{zoo()} creates a \texttt{zoo} object from a \texttt{numeric} vector or matrix, and an associated \texttt{date-time} index,
      \vskip1ex
      The \texttt{zoo()} index is a vector of \texttt{date-time} objects, and can be from any \texttt{date-time} class,
      <<zoo_ts,echo=3:30,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create index of daily dates
date_index <- seq(from=as.Date("2014-07-14"), 
                  by="day", length.out=1000)
# create zoo time series
zoo_series <- zoo(cumsum(rnorm(length(date_index))), 
                  order.by=date_index)

class(zoo_series)  # class 'zoo'
tail(zoo_series, 4)  # get last few elements

# call plot.zoo
plot(zoo_series, xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_ts-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operations on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{coredata()} extracts the data contained in \texttt{zoo} object, and returns a vector or matrix,
      \vskip1ex
      The function \texttt{index()} extracts the time index of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{start()} and \texttt{end()} return the time index values of the first and last elements of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{cumsum()}, \texttt{cummax()}, and \texttt{cummin()} return cumulative sums, minima and maxima of a \texttt{zoo} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:3
zoo_series <- zoo(rnorm(length(date_index)), 
               order.by=date_index)
zoo_series
index(zoo_series)  # extract time index
coredata(zoo_series)  # extract coredata
zoo_series[start(zoo_series)]  # first element
zoo_series[end(zoo_series)]  # last element
coredata(zoo_series) <- rep(1, 4)  # replace coredata
cumsum(zoo_series)  # cumulative sum
cummax(cumsum(zoo_series))
cummin(cumsum(zoo_series))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lag()} and \texttt{diff()} Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lag()} returns a lagged version of a time series, shifting the time index back by a given number of observations,
      \vskip1ex
      The function \texttt{diff()} returns the difference between a time series and its lagged version, 
      \vskip1ex
      For \texttt{zoo} objects, both these functions omit any \texttt{NA} values they may have produced,
    \column{0.6\textwidth}
      <<echo=2:30>>=
library(zoo)  # load package zoo
coredata(zoo_series) <- 1:4  # replace coredata
zoo_series
diff(zoo_series)  # diff with one day lag
lag(zoo_series, 2)  # two day lag
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Sequential Joining \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be joined sequentially using \texttt{rbind},
      <<zoo_join_seq,echo=3:30,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily date series of class 'Date'
date_index1 <- seq(Sys.Date(), by="days", 
                   length.out=365)
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
                 order.by=date_index1)
# create another zoo time series
date_index2 <- seq(Sys.Date()+350, by="days", 
                   length.out=365)
zoo_series2 <- zoo(rnorm(length(date_index2)), 
                 order.by=date_index2)
# rbind the two time series - ts1 supersedes ts2
zoo_series3 <- rbind(zoo_series1,
                 zoo_series2[index(zoo_series2) > end(zoo_series1)])
plot(cumsum(zoo_series3), xlab="", ylab="")
# add vertical lines at stitch point
abline(v=end(zoo_series1), col="blue", lty="dashed")
abline(v=start(zoo_series2), col="red", lty="dashed")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_join_seq-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Merging \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{zoo} time series can be combined concurrently by joining their columns using \texttt{merge()},
      \vskip1ex
      \texttt{merge()} is similar to \texttt{cbind()},
      \vskip1ex
      If the \texttt{all=TRUE} option is set, then \texttt{merge()} returns the union of their dates, otherwise it returns their intersection,
      \vskip1ex
      The \texttt{merge()} operation can produce \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
# create daily date series of class 'Date'
date_index1 <- Sys.Date() + -3:1
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
               order.by=date_index1)
# create another zoo time series
date_index2 <- Sys.Date() + -1:3
zoo_series2 <- zoo(rnorm(length(date_index2)), 
               order.by=date_index2)
merge(zoo_series1, zoo_series2)  # union of dates
# intersection of dates
merge(zoo_series1, zoo_series2, all=FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Managing \texttt{NA} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Operations on time series can produce \texttt{NA} values,
      \vskip1ex
      There are two dedicated functions for managing \texttt{NA} values in time series: 
      \begin{itemize}
        \item \texttt{na.omit()} removes observations containing \texttt{NA} values,
        \item \texttt{na.locf()} carries the last non-\texttt{NA} observation forward,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
library(zoo)  # load package zoo
# create zoo time series
zoo_series <- zoo(rnorm(4), 
                  order.by=(Sys.Date() + 0:3))
# add NA
zoo_series[3] <- NA
zoo_series

na.locf(zoo_series)  # replace NA's using locf

na.omit(zoo_series)  # remove NA's using omit
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Input and Output}


%%%%%%%%%%%%%%%
\subsection{Saving \texttt{R} Output to a File}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{sink()} diverts \texttt{R} \emph{text} output (excluding \emph{graphics}) to a file, or ends the diversion,
      \vskip1ex
      Remember to call \texttt{sink()} to end the diversion!
      \vskip1ex
      The function \texttt{pdf()} diverts \emph{graphics} output to a pdf file (text output isn't diverted), in vector graphics format,
      \vskip1ex
      The functions \texttt{png()}, \texttt{jpeg()}, \texttt{bmp()}, and \texttt{tiff()} divert \emph{graphics} output to graphics files (text output isn't diverted), in pixel graphics format,
      \vskip1ex
      The function \texttt{dev.off()} ends the diversion,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
setwd("C:/Develop/data")
{
sink("sinkdata.txt")# redirect text output to file

cat("Redirect text output from R\n")
print(runif(10))
cat("\nEnd data\nbye\n")

sink()  # turn redirect off

pdf("Rgraph.pdf", width=7, height=4)  # redirect graphics to pdf file

cat("Redirect data from R into pdf file\n")
my_var <- seq(-2*pi, 2*pi, len=100)
plot(x=my_var, y=sin(my_var), main="Sine wave", 
   xlab="", ylab="", type='l', lwd=2, col="red")
cat("\nEnd data\nbye\n")

dev.off()  # turn pdf output off

png("Rgraph.png")  # redirect output to png file

cat("Redirect graphics from R into png file\n")
plot(x=my_var, y=sin(my_var), main="Sine wave", 
 xlab="", ylab="", type='l', lwd=2, col="red")
cat("\nEnd data\nbye\n")

dev.off()  # turn png output off
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Writing Text Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{cat()} concatenates strings and writes them to standard output or to files,
      \vskip1ex
      \texttt{cat()} interprets its argument character string and its escape sequences (\texttt{'\textbackslash{}'}), but doesn't return a value,
      \vskip1ex
      The function \texttt{print()} doesn't interpret its argument, and simply prints it to standard output and invisibly returns it,
      \vskip1ex
      Typing the name of an object in \texttt{R} implicitly calls \texttt{print()} on that object,
      \vskip1ex
      The function \texttt{save()} writes objects to a binary file,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
setwd("C:/Develop/data")
cat("Enter\ttab")  # cat() interprets backslash escape sequences
print("Enter\ttab")

my_text <- print("hello")
my_text  # print() returns its argument

# create string
my_text <- "Title: My Text\nSome numbers: 1,2,3,...\nRprofile files contain code executed at R startup,\n"

cat(my_text, file="mytext.txt")  # write to text file

cat("Title: My Text",  # write several lines to text file
    "Some numbers: 1,2,3,...",
    "Rprofile files contain code executed at R startup,", 
    file="mytext.txt", sep="\n")

save(my_text, file="mytext.Rdata")  # write to binary file
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading Text from Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{scan()} reads text or data from a file and returns it as a vector or a list,
      \vskip1ex
      The function \texttt{readLines()} reads lines of text from a file and returns it as a vector,
      \vskip1ex
      The function \texttt{file.show()} reads text or data from a file and displays in editor,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
setwd("C:/Develop/data")
# read text from file
scan(file="mytext.txt", what=character(), sep="\n")

readLines(con="mytext.txt")  # read text from file

# read text from file and display in editor:
# file.show("mytext.txt")
# file.show("mytext.txt", pager="")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data from \texttt{Text} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from text files,
      \vskip1ex
      \texttt{write.table()} coerces objects to data frames before it writes them,
      \vskip1ex
      \texttt{read.table()} returns a data frame, and coerces non-numeric values to \texttt{factors} (unless the \texttt{stringsAsFactors=FALSE} option is set),
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} can be used to read and write matrices from text files, but they have to be coerced back to matrices,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=4:30>>=
data_frame <- data.frame(
              type=c('rose', 'daisy', 'tulip'), 
              color=c('red', 'white', 'yellow'), 
              price=c(1.5, 0.5, 1.0), 
              row.names=c('flower1', 'flower2', 'flower3')
              )  # end data_frame
mat_var <- matrix(sample(1:12), ncol=3, dimnames=list(NULL, c("col1", "col2", "col3")))
rownames(mat_var) <- paste("row", 1:nrow(mat_var), sep="")
# write data frame to text file, and then read it back
write.table(data_frame, file='florist.txt')
data_frame <- read.table(file='florist.txt')
data_frame  # a data frame

# write matrix to text file, and then read it back
write.table(mat_var, file='matrix.txt')
mat_var <- read.table(file='matrix.txt')
mat_var  # write.table() coerced matrix to data frame
class(mat_var)
# coerce from data frame back to matrix
mat_var <- as.matrix(mat_var)
class(mat_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Copying Data Frames Between the \texttt{clipboard} and \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames stored in the \texttt{clipboard} can be copied into \texttt{R} using the function \texttt{read.table()},
      \vskip1ex
      Data frames in \texttt{R} can be copied into the \texttt{clipboard} using the function \texttt{write.table()},
      \vskip1ex
      This allows convenient copying of data frames between \texttt{Excel} and \texttt{R},
      \vskip1ex
      Data frames can also be manipulated directly in the \texttt{R} spreadsheet-style data editor,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=4:30,eval=FALSE>>=
data_frame <- data.frame(small=c(3, 5), medium=c(9, 11), large=c(15, 13))
setwd("C:/Develop/data")
data_frame <- read.table("mydata.txt", header=TRUE)
data_frame <- read.table("clipboard", header=TRUE)

write.table(x=data_frame, file="clipboard", sep="\t")

# wrapper function for copying data frame from clipboard into R
# by default, data is tab delimited, with a header
read_clip <- function(file="clipboard", sep="\t", 
                      header=TRUE, ...) {
  read.table(file=file, sep=sep, header=header, ...)
}  # end read_clip

data_frame <- read_clip()

# wrapper function for copying data frame from R into clipboard
# by default, data is tab delimited, with a header
write.clip <- function(data, row.names=FALSE, 
                       col.names=TRUE, ...) {
  write.table(x=data, file="clipboard", sep="\t", 
              row.names=row.names, col.names=col.names, ...)
}  # end write.clip

write.clip(data=data_frame)

# launch spreadsheet-style data editor
# data_frame <- edit(data_frame)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data from \texttt{.csv} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} read and write data frames from \texttt{.csv} format files,
      \vskip1ex
      These functions are wrappers for \texttt{read.table()} and \texttt{write.table()},
      \vskip1ex
      \texttt{read.csv()} reads row names as an extra column,
      \vskip1ex
      The \texttt{*.csv()} functions are very inefficient for large data sets,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=4:30>>=
data_frame <- data.frame(
              type=c('rose', 'daisy', 'tulip'), 
              color=c('red', 'white', 'yellow'), 
              price=c(1.5, 0.5, 1.0), 
              row.names=c('flower1', 'flower2', 'flower3')
              )  # end data_frame
mat_var <- matrix(sample(1:12), ncol=3, dimnames=list(NULL, c("col1", "col2", "col3")))
rownames(mat_var) <- paste("row", 1:nrow(mat_var), sep="")
# write data frame to CSV file, and then read it back
write.csv(data_frame, file='florist.csv')
data_frame <- read.csv(file='florist.csv')
data_frame  # the rownames are read in as extra column
# restore rownames
rownames(data_frame) <- as.character(data_frame[, 1])
data_frame <- data_frame[, -1]  # remove extra column

# write matrix to csv file, and then read it back
write.csv(mat_var, file='matrix.csv')
mat_var <- read.csv(file='matrix.csv')
mat_var  # write.csv() coerced matrix to data frame
class(mat_var)
# restore rownames
rownames(mat_var) <- as.character(mat_var[, 1])
mat_var <- mat_var[, -1]  # remove extra column
# coerce from data frame back to matrix
mat_var <- as.matrix(mat_var)
class(mat_var)
mat_var  # a matrix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading Matrices Containing Bad Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Very often when data is read from external sources, it contains fields with bad data,
      \vskip1ex
      Coercion of bad data elements to \texttt{numeric} introduces \texttt{NA} values,
      \vskip1ex
      Additional code is needed to scrub bad data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
mat_var <- read.csv(file='badmatrix.csv')
# restore rownames
rownames(mat_var) <- as.character(mat_var[, 1])
mat_var <- mat_var[, -1]  # remove extra column
dim_names <- dimnames(mat_var)  # save dimnames
num_col <- ncol(mat_var)  # save num columns
mat_var  # data frame with bad data
class(mat_var)
class(mat_var[, 1])
class(mat_var[, 2])  # numeric coerced to factor by bad data
# convert non-numeric to NA by coercing to matrix and then to numeric
mat_var <- as.numeric(as.matrix(mat_var))
mat_var  # vector with NAs
mat_var[is.na(mat_var)] <- 0  # overwrite NAs
# coerce from vector back to matrix
mat_var <- matrix(mat_var, ncol=num_col, dimnames=dim_names)
mat_var  # matrix without NAs
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      There are many other ways of reading and writing matrices from files, with tradeoffs between simplicity, data size, and speed,
      \vskip1ex
      The function \texttt{write.matrix()} is part of library \texttt{MASS},
      \vskip1ex
      The advantage of using the function \texttt{scan()} is its speed, but it doesn't handle rownames,
      \vskip1ex
      Reading and writing matrices without rownames can be simplified,
      \vskip1ex
      The function \texttt{system.time()} measures CPU time spent on executing code,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
mat_var <- matrix(1:6, nrow=2, ncol=3,  # create a matrix without rownames
                dimnames=list(NULL, c("col1", "col2", "col3")))
mat_var  # matrix without rownames
library('MASS')  # load library 'MASS'
# write to CSV file by row - it's very SLOW!!!
write.matrix(mat_var, file='matrix.csv', sep=',')
system.time(  # scan reads faster - skip first line with colnames
  mat_var <- scan(file='matrix.csv', sep=',', 
                  skip=1, what=numeric()))
col_names <- readLines(con='matrix.csv', n=1)  # read colnames
col_names  # this is a string!
col_names <- strsplit(col_names, s=',')[[1]]  # convert to char vector
mat_var  # mat_var is a vector, not matrix!
# coerce by row to matrix
mat_var <- matrix(mat_var, ncol=length(col_names), 
                  byrow=TRUE)
colnames(mat_var) <- col_names  # restore colnames
mat_var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing \texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functions \texttt{read.zoo()} and \texttt{write.zoo()} read and write \texttt{zoo} objects from \texttt{text} and \texttt{.csv} files,
      \vskip1ex
      By default these functions read and write data in \emph{space}-delimited format, so the parameter \texttt{sep=","} must be passed to read and write in \emph{tab}-delimited format,
      \vskip1ex
      These functions are wrappers for \texttt{read.table()} and \texttt{write.table()},
      \vskip1ex
      Very often \texttt{.csv} files contain custom date-time formats, which need to be passed as parameters into  \texttt{read.zoo()} for proper formatting,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=4:30>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
library(zoo)  # load package zoo
# create POSIXct index
date_index <- seq(from=as.POSIXct("2013-06-15"), 
                  by="hour", length.out=1000)
# create zoo time series
zoo_series <- zoo(cumsum(rnorm(length(date_index))), 
                  order.by=date_index)
# write zoo to text file, and then read it back
write.zoo(zoo_series, file="zoo_series.txt")
zoo_series <- read.zoo("zoo_series.txt")  # read it back
# write zoo to CSV file, and then read it back
write.zoo(zoo_series, file="zoo_series.csv", sep=",")
zoo_series <- read.zoo(file='zoo_series.csv', 
                  header=TRUE, sep=",", FUN=as.POSIXct)
# read zoo from CSV file, with custom date-time format
zoo_frame <- read.table(file='zoo_series2.csv', sep=",")
tail(zoo_frame, 3)  # date-time format mm/dd/yyyy hh:mm
zoo_series <- read.zoo(file='zoo_series2.csv', 
                  header=TRUE, sep=",", FUN=as.POSIXct, 
                  format="%m/%d/%Y %H:%M")
tail(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Environments in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{\secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Environments consist of a \emph{frame} (a set of symbol-value pairs) and an \emph{enclosure} (a pointer to an enclosing environment),
      \vskip1ex
      There are three system environments:
      \begin{itemize}
        \item \texttt{globalenv()} the user's workspace,
        \item \texttt{baseenv()} the environment of the base package,
        \item \texttt{emptyenv()} the only environment without an enclosure,
      \end{itemize}
      Environments form a tree structure of successive enclosures, with the empty environment at its root,
      \vskip1ex
      Packages have their own environments,
      \vskip1ex
      The enclosure of the base package is the empty environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
baseenv()  # get base environment
globalenv()  # get global environment
environment()  # get current environment
class(environment())  # get environment class
glob_var <- 1  # define variable in current environment
ls(environment())  # get objects in current environment

new_env <- new.env()  # create new environment
parent.env(new_env)  # get calling environment of new environment
assign("new_var1", 3, envir=new_env)  # assign Value to Name
new_env$new_var2 <- 11  # create object in new environment
ls(new_env)  # get objects in new environment
ls(environment())  # get objects in current environment
new_env$new_var1  # environments are subset like lists
new_env[['new_var1']]  # environments are subset like lists
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Search Path}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} evaluates variables using the search path, a series of environments:
      \begin{itemize}
        \item global environment,
        \item package environments,
        \item base environment,
      \end{itemize}
      The function \texttt{search()} returns the search path for \texttt{R} objects,
      \vskip1ex
      The function \texttt{attach()} attaches objects to the search path,
      \vskip1ex
      Using \texttt{attach()} allows referencing object components by their names alone, rather than as components of objects,
      \vskip1ex
      The function \texttt{detach()} detaches objects from the search path,
      \begin{block}{\color{red}{Rule of Thumb}}
        Be very careful with using \texttt{attach()},
        \vskip1ex
        Make sure to \texttt{detach()} objects once they're not needed,
      \end{block}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
search()  # get search path for R objects
my_list <- list(flowers=c('rose', 'daisy', 'tulip'),  # create a list
                        trees=c('pine', 'oak', 'maple'))
my_list$trees
attach(my_list)
trees
search()  # get search path for R objects
detach(my_list)
head(trees)  # "trees" is part of the datasets base package
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Referencing Object Components \texttt{with()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{with()} function evaluates an expression in an environment constructed from the data,
      \vskip1ex
      \texttt{with()} allows referencing object components by their names alone,
      \vskip1ex
      It's often better to use \texttt{with()} instead of \texttt{attach()},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
head(trees)  # "trees" is part of the datasets base package
colnames(trees)
mean(trees$Girth)
with(trees, mean(Girth))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When a function is called, a new \emph{evaluation} environment is created,
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables,
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined (the global environment for functions defined in the workspace),
      \vskip1ex
      Functions defined in packages with namespaces have the package namespace as their enclosure,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
ls(environment())  # get all variables in environment
func_env <- function() {  # explore function environments
  loc_var <- 1  # define a local variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t', 
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lexical Function Scope}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{free} variable is a variable that's not included in the \emph{evaluation} environment,
      \vskip1ex
      Scoping rules determine how \emph{free} variables are evaluated,
      \vskip1ex
      By default \texttt{R} uses \emph{lexical} (\emph{static}) scoping, which means that variables are first evaluated in the \emph{evaluation} environment, then in the \emph{enclosing} environment in which the function was \emph{defined}, and so on,
      \vskip1ex
      \emph{Dynamic} scoping means that variables are evaluated in the environment from which the function was \emph{called},
      \vskip1ex
      The standard assignment operator "\texttt{<-}" modifies variables in the \emph{evaluation} environment,
      \vskip1ex
      The special assignment operator "\texttt{<<-}" modifies variables in the \emph{enclosing} environment,

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
probe_scope <- function() {  # explore function scope
  loc_var <- 2*glob_var  # define a local variable
  new_globvar <<- 11  # define a global variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('this is a local loc_var:\t', loc_var, '\n')
  cat('objects in enclosing environment:\n', 
      ls(parent.env(environment())), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local glob_var
  cat('this is the local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # global variable is unaffected
new_globvar  # new_globvar is preserved
loc_var  # local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Super-assignment Operator "\texttt{<<-}"}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The super-assignment operator "\texttt{<<-}" modifies or creates variables in the \emph{enclosing} environment in which the function was \emph{defined} (\emph{lexical} scoping),
      \vskip1ex
      If the function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment and the "\texttt{<<-}" operator operates on variables in the \emph{global} environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
probe_scope <- function() {  # explore function scope
  cat('this is the global glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local 'glob_var' variable
  glob_var <<- 2  # re-define the global variable
  cat('this is a local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # the global variable
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.4emas First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Functions in \texttt{R} are \emph{first class objects}, which means they can be treated like any other \texttt{R} object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher-order} functions are \texttt{R} functions that either take a function as input or return a function as output,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# create functional that accepts a function as input argument
func_tional <- function(func_arg) {
# calculates statistic on random numbers
  set.seed(1)
  func_arg(runif(1e4))  # apply the function name
}  # end func_tional
func_tional(mean)
func_tional(sd)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functionals}


%%%%%%%%%%%%%%%
\subsection{Functionals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Functionals} are functions that accept a function as its input argument,
      \vskip1ex
      The function \texttt{match.fun()} produces a function specified by its name,
      \vskip1ex
      \texttt{match.fun()} produces an error condition if it fails to find a function with the specified name,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
func_tional <- function(func_arg, arg_var) {
# functional accepts function name and one additional argument
  func_arg <- match.fun(func_arg)  # produce function from name
  func_arg(arg_var)  # apply input function
}  # end func_tional

func_tional(sqrt, 4)

# if argument is a list, then we need to call "do.call", to pass them one by one
# Passing a function as a list: first element is function name, remaining elements are arguments
func_tional <- function(list_arg) {
  func_arg <- match.fun(list_arg[[1]])  # produce function from name
  do.call(func_arg, list(as.numeric(list_arg[-1])))
}  # end func_tional

arg_list <- list("mean", 1, 2, 3, 4)
func_tional(arg_list)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The '\texttt{...}' argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
func_tional <- function(func_arg, ...) {
# functional accepts function and additional '...' arguments
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional

func_tional(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functions,
      \vskip1ex
      The function \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix,
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns},
      \vskip1ex
      The function \texttt{apply()} can replace '\texttt{for}' loops,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
str(apply)  # get list of arguments
mat_rix <- matrix(6:1, nrow=2, ncol=3)  # create a matrix
mat_rix
# sum the rows and columns
row_sums <- apply(mat_rix, 1, sum)
col_sums <- apply(mat_rix, 2, sum)
mat_rix <- cbind(c(sum(row_sums), row_sums), 
                  rbind(col_sums, mat_rix))
dimnames(mat_rix) <- list(c("col_sums", "row1", "row2"), 
                           c("row_sums", "col1", "col2", "col3"))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
      <<>>=
str(apply)  # get list of arguments
mat_rix <- matrix(sample(12), nrow=3, ncol=4)  # create a matrix
mat_rix
apply(mat_rix, 2, sort)  # sort matrix columns
apply(mat_rix, 2, sort, decreasing=TRUE)  # sort decreasing order
      @
    \column{0.5\textwidth}
        <<>>=
mat_rix[2, 2] <- NA  # introduce NA value
mat_rix
# calculate median of columns
apply(mat_rix, 2, median)
# calculate median of columns with na.rm=TRUE
apply(mat_rix, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} allows defining functions without assigning a name to them,
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name,
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
# simple anonymous function
(function(x) (x + 3)) (10)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Anonymous} functions are most often passed as arguments to \emph{functionals},
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments,
    \column{0.7\textwidth}
      \vspace{-2em}
        <<>>=
# functional accepts function and additional '...' arguments
func_tional <- function(func_arg, ...) {
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(sum, 2, 3, 4)
func_tional(mean, 1:10)
func_tional((func_arg=function(x) (x + 3)), 5)
# anonymous function can be a default value
func_tional <- function(..., 
                        func_arg=function(x, y, z) {x+y+z}) {
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(2, 3, 4)  # use default func_arg
func_tional(func_arg=sum, 2, 3, 4)  # func_arg bound by name
func_tional(func_arg=sum, 2, 3, 4, 5)
func_tional(2, 3, 4, 5)
# pass anonymous function to func_arg
func_tional(func_arg=function(x, y, z) {x*y*z}, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{apply()} function combined with \emph{anonymous} functions can be used to loop over function parameters,
      \vskip1ex
  The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
dax_rets <- 100*diff(log(EuStockMarkets[, 1]))  # DAX percent returns
library("moments")  # load library"moments"
str(moment)  # get list of arguments

moment(x=dax_rets, order=3)  # apply moment function

moment_orders <- as.matrix(1:4)  # 4x1 matrix of moment orders

# anonymous function allows looping over function parameters
apply(X=moment_orders, MARGIN=1, 
      FUN=function(moment_order) {
          moment(x=dax_rets, order=moment_order)
        }  # end anonymous function
      )  # end apply

# another way of passing parameters into moment() function
apply(X=moment_orders, MARGIN=1, FUN=moment, x=dax_rets)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{sapply()} function is a specialized version of the \texttt{apply()} function,
      \vskip1ex
      \texttt{sapply()} applies a function to a list or a vector of objects and returns a vector,
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interprets it as a list, and applies the function to each element (column) of the data frame,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sapply(6:10, sqrt)  # sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # sapply on list

# calculate means of iris data frame columns
sapply(iris, mean)  # returns NA for Species

# create a matrix
mat_rix <- matrix(sample(100), ncol=4)
# calculate column means using apply
apply(mat_rix, 2, mean)

# calculate column means using sapply, with anonymous function
sapply(1:ncol(mat_rix), 
       function(col_index) {  # anonymous function
         mean(mat_rix[, col_index])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{lapply()} function is a specialized version of the \texttt{apply()} function,
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list,
      \vskip1ex
      The function \texttt{unlist()} flattens a list into a vector that contains the atomic elements of the list,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sapply(iris[, -5], mean)  # vector of means of numeric columns
lapply(iris[, -5], mean)  # calculate means of numeric columns
# calculate means of numeric columns using anonymous function
unlist(lapply(iris, 
              function(col_umn) {
                if (is.numeric(col_umn)) mean(col_umn)
              }  # end anonymous function
              )  # end sapply
       )  # end unlist
unlist(sapply(iris, function(col_umn) {if (is.numeric(col_umn)) mean(col_umn)}))
      @
  \end{columns}
\end{block}

\end{frame}




%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em (due Dec. 8th)}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{Required}
  Create a function called "\texttt{re\_move}", which takes two arguments:
  \begin{itemize}[]
    \item "\texttt{re\_move}" removes the first argument from the second argument, and returns the result,
    \item if the first argument isn't among the elements of the second argument, then "\texttt{re\_move}" just returns the second argument unchanged,
    \item the first argument can be a numeric or string, the second argument must be a vector,
    \item you can use functions "match", "which", or the operator "\%in\%", but you don't have to,
    \item call the function "\texttt{re\_move}" as follows, to make sure it works properly:
    \item \texttt{re\_move(3, 1:5)}
    \item \texttt{re\_move(6, 1:5)}
    \item \texttt{re\_move("bye", c("hello", "there"))}
  \end{itemize}
  Create a "zoo" time series object called "\texttt{dax\_series}":
  \begin{itemize}[]
    \item extract (subset) the DAX index from the EuStockMarkets dataset, and coerce it into a single "zoo" time series object called "\texttt{dax\_series}",
    \item the index of "\texttt{dax\_series}" will have dates in "year-fraction" format, 
    \item convert the "\texttt{dax\_series}" index dates into "POSIXct" objects using functions from the package "lubridate",
  \end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname \hskip0.4em (cont.)}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{Required}
  Create a "zoo" time series called "\texttt{zoo\_series}", with exactly the same index as "\texttt{dax\_series}",
  \begin{itemize}[]
    \item the values of "\texttt{zoo\_series}" should be random prices generated using "cumsum" and "rnorm",
    \item merge "\texttt{zoo\_series}" with "\texttt{dax\_series}" into a single "zoo" time series called "\texttt{zoo\_series}", with two columns,
    \item rename the columns of "\texttt{zoo\_series}" to "random prices" and "DAX",
    \item plot "\texttt{zoo\_series}" in two panels,
    \item save "\texttt{zoo\_series}" to a comma-delimited CSV file called "\texttt{zoo\_series.csv}", using "\texttt{write.zoo}",
    \item save "\texttt{zoo\_series}" to a binary file called "\texttt{zoo\_series.Rdata}", using "\texttt{save}",
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 7, 12: \fullcite{website:rintro}
    \item Read chapters 10, 11, 12: \citetitle{matlofftexbook}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
