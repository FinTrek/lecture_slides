% FRE6871_Lecture_4

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture \#4]{FRE6871 R in Finance}
\subtitle{Lecture \#4, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@poly.edu}
\date{September 29, 2014}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Time Series Objects}


%%%%%%%%%%%%%%%
\subsection{\texttt{RQuantLib} Calendar Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The package \texttt{RQuantLib} contains a large library of functions for pricing fixed-income instruments and options, and for risk management calculations,
      \vskip1ex
      The package \texttt{RQuantLib} contains calendar functions for determining holidays and business days in many different jurisdictions,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=3:30>>=
rm(list=ls())
library(zoo)  # load zoo
library(RQuantLib)  # load RQuantLib

# create daily date series of class 'Date'
date_index <- Sys.Date() + -5:2
date_index

# create logical vector of business days
bus.days <- isBusinessDay(  # RQuantLib calendar
  calendar="UnitedStates/GovernmentBond", date_index)

# create daily series of business days
bus_index <- date_index[bus.days]
bus_index
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{EuStockMarkets}
\begin{frame}[fragile,t]{\subsecname \hskip0.5em Quantile-Quantile Plot}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \texttt{Q-Q} plot is a plot of points from two probability distributions with the same quantiles,
      \vskip1ex
      The function \texttt{qqnorm()} produces a normal Q-Q plot,
      \vskip1ex
      The function \texttt{qqline()} fits a line to the normal quantiles,
      \vskip1ex
      The \texttt{DAX} Q-Q plot shows that the \texttt{DAX} return distribution has fat tails,
        <<eustx_qq,echo=2:30,fig.show='hide'>>=
par(oma=c(1, 1, 1, 1), mgp=c(2, 1, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate percentage returns
ts_rets <- diff(log(EuStockMarkets[, 1]))
# create normal Q-Q plot
qqnorm(ts_rets, ylim=c(-0.04, 0.04), 
       xlab='Normal Quantiles', main='')
# fit a line to the normal quantiles
qqline(ts_rets, col='red', lwd=2)
plot_title <- paste(colnames(EuStockMarkets)[1], 
                  'Q-Q Plot')
title(main=plot_title, line=-1)  # add title
shapiro.test(ts_rets)  # Shapiro-Wilk test
      @

    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_qq}
      \vskip2ex
      The \emph{p}-value of the \emph{Shapiro-Wilk} test is very small, which shows that the \texttt{DAX} returns are not normal,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} is designed for managing \emph{time series} and ordered objects,
      <<zoo_ts,echo=7:30,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily dates
date_index <- as.Date("2010-06-15") + 1:1000
# create zoo time series
zoo_series <- zoo(cumsum(rnorm(1000)), 
                 order.by=date_index)
class(zoo_series)  # class 'zoo'
tail(zoo_series, 4)  # get last few elements
write.zoo(zoo_series, file="zoo_series.txt")
rm(zoo_series)  # remove zoo object
zoo_series <- read.zoo("zoo_series.txt")  # read it back
tail(zoo_series, 4)  # get last few elements
# call plot.zoo
plot(zoo_series, xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_ts}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operations on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{coredata()} extracts the data contained in \texttt{zoo} object, and returns a vector or matrix,
      \vskip1ex
      The function \texttt{index()} extracts the time index of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{start()} and \texttt{end()} return the time index values of the first and last elements of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{cumsum()}, \texttt{cummax()}, and \texttt{cummin()} return cumulative sums, minima and maxima of a \texttt{zoo} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=3:30>>=
rm(list=ls())
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:3
zoo_series <- zoo(rnorm(length(date_index)), 
               order.by=date_index)
zoo_series
index(zoo_series)  # extract time index
coredata(zoo_series)  # extract coredata
zoo_series[start(zoo_series)]  # first element
zoo_series[end(zoo_series)]  # last element
coredata(zoo_series) <- rep(1, 4)  # replace coredata
cumsum(zoo_series)  # cumulative sum
cummax(cumsum(zoo_series))
cummin(cumsum(zoo_series))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lag()} and \texttt{diff()} Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lag()} returns a lagged version of a time series, shifting the time index back by a given number of observations,
      \vskip1ex
      The function \texttt{diff()} returns the difference between a time series and its lagged version, 
      \vskip1ex
      For \texttt{zoo} objects, both these functions omit any \texttt{NA} values they may have produced,
    \column{0.6\textwidth}
      <<echo=2:30>>=
library(zoo)  # load package zoo
coredata(zoo_series) <- 1:4  # replace coredata
zoo_series
diff(zoo_series)  # diff with one day lag
lag(zoo_series, 2)  # two day lag
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Sequential Joining \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be joined sequentially using \texttt{rbind},
      <<zoo_join_seq,echo=7:30,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily date series of class 'Date'
date_index1 <- Sys.Date() + 0:365
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
                 order.by=date_index1)
# create another zoo time series
date_index2 <- Sys.Date() + 365:730
zoo_series2 <- zoo(rnorm(length(date_index2)), 
                 order.by=date_index2)
# rbind the two time series
zoo_series3 <- rbind(zoo_series1,  # ts1 supersedes ts2
                 zoo_series2[index(zoo_series2) > 
                           end(zoo_series1)])
plot(cumsum(zoo_series3), xlab="", ylab="")
# add vertical line at stitch point
abline(v=index(tail(zoo_series1, 1)), col="red", lty="dashed")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_join_seq}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Merging \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{zoo} time series can be combined concurrently by joining their columns using \texttt{merge()},
      \vskip1ex
      If \texttt{all=TRUE}, then \texttt{merge()} uses the union of their dates, otherwise it uses their intersection,
      \vskip1ex
      The \texttt{merge()} operation can produce \texttt{NA} values,
      \vskip1ex
      \texttt{merge()} is similar to \texttt{cbind()},
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
# create daily date series of class 'Date'
date_index1 <- Sys.Date() + -3:1
# create zoo time series
zoo_series1 <- zoo(rnorm(length(date_index1)), 
               order.by=date_index1)
# create another zoo time series
date_index2 <- Sys.Date() + -1:3
zoo_series2 <- zoo(rnorm(length(date_index2)), 
               order.by=date_index2)
merge(zoo_series1, zoo_series2)  # union of dates
merge(zoo_series1, zoo_series2, all=FALSE)  # intersection of dates
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Managing \texttt{NA} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Operations on time series can produce \texttt{NA} values,
      \vskip1ex
      There are two dedicated functions for managing \texttt{NA} values in time series: 
      \begin{itemize}[]
        \item \texttt{na.omit()} removes observations containing \texttt{NA} values,
        \item \texttt{na.locf()} carries the last non-\texttt{NA} observation forward,
      \end{itemize}
    \column{0.6\textwidth}
      <<echo=3:30>>=
rm(list=ls())
library(zoo)  # load package zoo
# create zoo time series
zoo_series <- zoo(rnorm(4), order.by=(Sys.Date() + 0:3))
zoo_series[3] <- NA
zoo_series

na.locf(zoo_series)  # replace NA's using locf

na.omit(zoo_series)  # remove NA's using omit
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Aggregating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{aggregate()} performs temporal aggregations of \texttt{zoo} objects,
      <<zoo_agg,echo=8:30,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create zoo time series
date_index <- Sys.Date() + 0:365
zoo_series <- zoo(rnorm(length(date_index)), 
                 order.by=date_index)
# create monthly dates
dates_agg <- as.Date(as.yearmon(index(zoo_series)))
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using locf
zoo_agg <- na.locf(zoo_agg)
# extract aggregated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and aggregated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Aggregated Prices", 
       leg=c("orig prices", "agg prices"), lwd=2, 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_agg}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpolating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has two functions for replacing \texttt{NA} values using interpolation:
      \begin{itemize}[]
        \item \texttt{na.approx()} performs linear interpolation,
        \item \texttt{na.spline()} performs spline interpolation,
      \end{itemize}
      \vspace{-1em}
      <<zoo_interpol,echo=6:30,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_agg <- aggregate(zoo_series, by=dates_agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo_agg <- merge(zoo_series, zoo_agg)
# replace NA's using linear interpolation
zoo_agg <- na.approx(zoo_agg)
# extract interpolated zoo
zoo_agg <- zoo_agg[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Interpolated Prices", 
       leg=c("orig prices", "interpol prices"), lwd=2, 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_interpol}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Rolling Functions on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has several functions for rolling calculations:
      \begin{itemize}[]
        \item \texttt{rollapply()} applying function to rolling margins,
        \item \texttt{rollmean()} calculate rolling means,
        \item \texttt{rollmedian()} calculate rolling median,
        \item \texttt{rollmax()} calculate rolling max,
      \end{itemize}
      \vspace{-1em}
      <<zoo_roll,echo=6:30,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo_mean <- rollapply(zoo_series, width=11, FUN=mean)
# merge with original zoo - union of dates
zoo_mean <- merge(zoo_series, zoo_mean)
# replace NA's using na.locf
zoo_mean <- na.locf(zoo_mean, fromLast=TRUE)
# extract mean zoo
zoo_mean <- zoo_mean[index(zoo_series), 2]
# plot original and interpolated zoo
plot(cumsum(zoo_series), xlab="", ylab="")
lines(cumsum(zoo_mean), lwd=2, col="red")
# add legend
legend("topright", inset=0.05, cex=0.8, title="Mean Prices", 
       leg=c("orig prices", "mean prices"), lwd=2, 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_roll}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Input and Output}


%%%%%%%%%%%%%%%
\subsection{Saving \texttt{R} Output to a File}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{sink()} diverts \texttt{R} \emph{text} output (excluding \emph{graphics}) to a file, or ends the diversion,
      \vskip1ex
      Remember to call \texttt{sink()} to end the diversion!
      \vskip1ex
      The function \texttt{pdf()} diverts \emph{graphics} output to a pdf file (text output isn't diverted), in vector graphics format,
      \vskip1ex
      The functions \texttt{png()}, \texttt{jpeg()}, \texttt{bmp()}, and \texttt{tiff()} divert \emph{graphics} output to graphics files (text output isn't diverted), in pixel graphics format,
      \vskip1ex
      The function \texttt{dev.off()} ends the diversion,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
setwd("C:/Develop/data")
{
sink("sinkdata.txt")# redirect text output to file

cat("Redirect text output from R\n")
print(runif(10))
cat("\nEnd data\nbye\n")

sink()  # turn redirect off

pdf("Rgraph.pdf", width=7, height=4)  # redirect graphics to pdf file

cat("Redirect data from R into pdf file\n")
my_var <- seq(-2*pi, 2*pi, len=100)
plot(x=my_var, y=sin(my_var), main="Sine wave", 
   xlab="", ylab="", type='l', lwd=2, col="red")
cat("\nEnd data\nbye\n")

dev.off()  # turn pdf output off

png("Rgraph.png")  # redirect output to png file

cat("Redirect graphics from R into png file\n")
plot(x=my_var, y=sin(my_var), main="Sine wave", 
 xlab="", ylab="", type='l', lwd=2, col="red")
cat("\nEnd data\nbye\n")

dev.off()  # turn png output off
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Writing Text Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The function \texttt{cat()} concatenates strings and writes them to standard output or to files,
      \vskip1ex
      \texttt{cat()} interprets its argument character string and its escape sequences (\texttt{'\textbackslash{}'}), but doesn't return a value,
      \vskip1ex
      The function \texttt{print()} doesn't interpret its argument, and simply prints it to standard output and returns it invisibly,
      \vskip1ex
      Typing the name of an object in \texttt{R} implicitly calls \texttt{print()} on that object,
      \vskip1ex
      The function \texttt{save()} writes objects to a binary file,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
setwd("C:/Develop/data")
cat("Enter\ttab")  # cat() interprets backslash escape sequences
print("Enter\ttab")

my_text <- print("hello")
my_text  # print() returns its argument

# create string
my_text <- "Title: My Text\nSome numbers: 1,2,3,...\nRprofile files contain code executed at R startup,\n"

cat(my_text, file="mytext.txt")  # write to text file

cat("Title: My Text",  # write several lines to text file
    "Some numbers: 1,2,3,...",
    "Rprofile files contain code executed at R startup,", 
    file="mytext.txt", sep="\n")

save(my_text, file="mytext.Rdata")  # write to binary file
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading Text from Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The function \texttt{scan()} reads text or data from a file and returns it as a vector or a list,
      \vskip1ex
      The function \texttt{readLines()} reads lines of text from a file and returns it as a vector,
      \vskip1ex
      The function \texttt{file.show()} reads text or data from a file and displays in editor,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
setwd("C:/Develop/data")
# read text from file
scan(file="mytext.txt", what=character(), sep="\n")

readLines(con="mytext.txt")  # read text from file

# read text from file and display in editor:
# file.show("mytext.txt")
# file.show("mytext.txt", pager="")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from files,
      \vskip1ex
      The functions \texttt{read.csv()} and \texttt{write.csv()} are wrappers for \texttt{read.table()} and \texttt{write.table()}, and read and write data frames from CSV format files,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
write.csv(df.florist, file='florist.csv')  # write to file
df.bad <- read.csv(file='badflorist.csv')  # read from file
df.bad  # v.price has bad data point
class(df.bad$v.price)  # numeric coerced to factor by bad data
df.bad$v.price <- as.numeric(  # explicitly coerce to numeric
                            as.character(df.bad$v.price))
df.bad$v.price[2] <- 0.5  # fix value
mean(df.bad$v.price)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Copying Data Frames Between the \texttt{clipboard} and \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames stored in the \texttt{clipboard} can be copied into \texttt{R} using the function \texttt{read.table()},
      \vskip1ex
      Data frames in \texttt{R} can be copied into the \texttt{clipboard} using the function \texttt{write.table()},
      \vskip1ex
      This allows convenient copying of data frames between \texttt{Excel} and \texttt{R},
      \vskip1ex
      Data frames can also be manipulated directly in the \texttt{R} spreadsheet-style data editor,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=4:30>>=
my_data <- data.frame(small=c(3, 5), medium=c(9, 11), large=c(15, 13))
setwd("C:/Develop/data")
my_data <- read.table("mydata.txt", header=TRUE)
my_data <- read.table("clipboard", header=TRUE)

write.table(x=my_data, file="clipboard", sep="\t")

# wrapper function for copying data frame from clipboard into R
# by default, data is tab delimited, with a header
read_clip <- function(file="clipboard", sep="\t", 
                      header=TRUE, ...) {
  read.table(file=file, sep=sep, header=header, ...)
}  # end read_clip

my_data <- read_clip()

# wrapper function for copying data frame from R into clipboard
# by default, data is tab delimited, with a header
write.clip <- function(data, row.names=FALSE, 
                       col.names=TRUE, ...) {
  write.table(x=data, file="clipboard", sep="\t", 
              row.names=row.names, col.names=col.names, ...)
}  # end write.clip

write.clip(data=my_data)

# launch spreadsheet-style data editor
# my_data <- edit(my_data)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} allow reading and writing matrices from CSV format files,
      \vskip1ex
      Using the \texttt{*.csv()} functions is very inefficient for large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
mat_var <- matrix(1:6, nrow=2, ncol=3, dimnames=list(c("row1", "row2"), c("col1", "col2", "col3")))  # create a matrix
mat_var
write.csv(mat_var, file='matrix.csv')  # write to file
mat_in <- read.csv(file='matrix.csv')  # read from file
mat_in  # this is a data frame!
class(mat_in)  # this is a data frame!
name.rows <- as.character(mat_in[, 1])  # get rownames
mat_in <- as.matrix(mat_in[, -1])  # coerce to matrix
rownames(mat_in) <- name.rows  # restore rownames
mat_in
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      There are many other ways of reading and writing matrices from files, with tradeoffs between simplicity, data size, and speed,
      \vskip1ex
      Reading and writing matrices without rownames can be simplified,
      \vskip1ex
      The function \texttt{write.matrix()} is part of library \texttt{MASS},
      \vskip1ex
      The advantage of using the function \texttt{scan()} is its speed, but it doesn't handle rownames,\\
      Although a test with 300x100 matrix showed almost same system.time(),
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
mat_var <- matrix(1:6, nrow=2, ncol=3,  # create a matrix without rownames
                dimnames=list(NULL, c("col1", "col2", "col3")))
mat_var  # matrix without rownames
library('MASS')  # load library 'MASS'
write.matrix(mat_var, file='matrix.csv',  # write to CSV file by row - it's very SLOW!!!
                               sep=',')
system.time(mat_in <- scan(file='matrix.csv',  # skip first line with colnames
                          sep=',', skip=1, what=numeric()))
mat_in  # this is a vector!
mat_in <- matrix(mat_in, nrow=2, byrow=TRUE)  # coerce by row to matrix
#        dim(mat_in) <- c(2, 3)  # coerce by column to matrix!
col_names <- readLines(con='matrix.csv', n=1)  # read colnames
col_names  # this is a string!
col_names <- strsplit(col_names, s=',')[[1]]  # convert to char vector
colnames(mat_in) <- col_names  # restore colnames
mat_in
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{Function Argument Lazy Evaluation}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions delay evaluation of their arguments until they're needed by their \texttt{R} code,
      \vskip1ex
      This is called \emph{lazy} evaluation,
      \vskip1ex
      If the function body doesn't evaluate an argument, then the function won't throw an error, even if the argument is missing,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
MyFunc <- function(my_var1, my_var2) {  # define function MyFunc
  2*my_var1  # just multiply first argument
}  # end MyFunc
MyFunc(3, 2)  # match arguments by position
MyFunc(3)  # second argument was never evaluated!
MyFunc <- function(my_var1, my_var2) {  # define function MyFunc
  cat(my_var1, '\n')  # write to output
  cat(my_var2)  # write to output
}  # end MyFunc
MyFunc(3, 2)  # match arguments by position
MyFunc(3)  # first argument written to output
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The '...' Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The '...' argument represents additional unknown arguments, that may be passed on to another nested function,
      \vskip1ex
      The '...' argument is also used when the number of arguments isn't known in advance,
      \vskip1ex
      Any arguments that appear after '...' in the argument list cannot be partially matched,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
MySum <- function(my_var1=2, my_var2=1, ...) {  # define function MySum
# default values can be specified in the argument list
  my_var1 + 2*my_var2 + sum(...)
# the function returns the last evaluated statement
}  # end MySum
MySum(3, 2)  # match arguments by position
MySum(3, 2, 5, 8)  # extra arguments
MySum()  # use default value of arguments
str(paste)  # function 'paste' can take many arguments
paste('a', 'b', sep = ':')  # match arguments by name
paste('a', 'b', se = ':')  # partial name matching fails!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive\hskip0.5em\secname\hskip0.5em with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Recursive} functions can also accept the '\texttt{...}' argument, 
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
SumDots <- function(my_var, ...) {  # define recursive function
# returns the sum of its argument list
  if (length(list(...)) == 0) {
    return(my_var)  # just one argument left
  } else {
    my_var + SumDots(...)  # sum remaining arguments
  }
}  # end SumDots
SumDots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When a function is called, a new \emph{evaluation} environment is created,
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables,
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined (the global environment for functions defined in the workspace),
      \vskip1ex
      Functions defined in packages with namespaces have the package namespace as their enclosure,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
ls(environment())  # get all variables in environment
func_env <- function() {  # function for exploring environments
  loc_var <- 1  # define a local variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t', 
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lexical Function Scope}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{free} variable is a variable that's not included in the \emph{evaluation} environment,
      \vskip1ex
      Scoping rules determine how \emph{free} variables are evaluated,
      \vskip1ex
      By default \texttt{R} uses \emph{lexical} (\emph{static}) scoping, which means that variables are first evaluated in the \emph{evaluation} environment, then in the \emph{enclosing} environment in which the function was \emph{defined}, and so on,
      \vskip1ex
      \emph{Dynamic} scoping means that variables are evaluated in the environment from which the function was \emph{called},
      \vskip1ex
      The standard assignment operator "\texttt{<-}" modifies variables in the \emph{evaluation} environment,
      \vskip1ex
      The special assignment operator "\texttt{<<-}" modifies variables in the \emph{enclosing} environment,

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
func_scope <- function() {  # function for exploring scope
  loc_var <- 2*glob_var  # define a local variable
  new_globvar <<- 11  # define a global variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('this is a local loc_var:\t', loc_var, '\n')
  cat('objects in enclosing environment:\n', 
      ls(parent.env(environment())), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local glob_var
  cat('this is the local glob_var:\t', glob_var, '\n')
}  # end func_scope
func_scope()
glob_var  # global variable is unaffected
new_globvar  # new_globvar is preserved
loc_var  # local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Super-assignment Operator "\texttt{<<-}"}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The super-assignment operator "\texttt{<<-}" modifies or creates variables in the \emph{enclosing} environment in which the function was \emph{defined} (\emph{lexical} scoping),
      \vskip1ex
      If the function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment and the "\texttt{<<-}" operator operates on variables in the \emph{global} environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
func_scope <- function() {  # function for exploring scope
  cat('this is the global glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local 'glob_var' variable
  glob_var <<- 2  # re-define the global variable
  cat('this is a local glob_var:\t', glob_var, '\n')
}  # end func_scope
func_scope()
glob_var  # the global variable
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{\secname}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}[]
    \item Create an $R$ script for calculating the first four moments of all four time series in the EuStockMarkets data (DAX, SMI, CAC, FTSE),
    \item Your script should produce a 4x4 matrix containing all 16 moments, with row and column names,
    \item You can choose to use '\texttt{for}' loops and/or  \texttt{apply()} functions,
    \item Your script should use iteration, instead of manually repeating the same calculation for each index,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 7, 12: \fullcite{website:rintro}
    \item Read chapters 10, 11, 12: \citetitle{matlofftexbook}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
