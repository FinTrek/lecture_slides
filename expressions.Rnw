% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Control Statements and Operators]{Control Statements and Operators}
\subtitle{FRE6871 R in Finance, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@poly.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has the following logical operators:
      \begin{itemize}
        \item '\texttt{<}' less than,
        \item '\texttt{<=}' less than or equal to,
        \item '\texttt{>}' greater than,
        \item '\texttt{>=}' greater than or equal to,
        \item '\texttt{==}' exactly equal to,
        \item '\texttt{!=}' not equal to,
        \item '\texttt{!x}' Not \texttt{x},
        \item '\texttt{x \& y}' \texttt{x} AND \texttt{y},
        \item '\texttt{x | y}' \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
vec_var1 <- c(2, 4, 6)
vec_var1 < 5
(vec_var1 < 5) & (vec_var1 > 3)
vec_var1[(vec_var1 < 5) & (vec_var1 > 3)]
vec_var2 <- c(-10, 0, 10)
vec_var1 < vec_var2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} also has two long form logical operators:
      \begin{itemize}
        \item '\texttt{x \&\& y}' \texttt{x} AND \texttt{y},
        \item '\texttt{x || y}' \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first elements of their vector arguments,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use '\texttt{\&\&}' and '\texttt{||}' in if-clauses,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
echo_true = function() {cat("echo_true\t"); TRUE}
echo_false = function() {cat("echo_false\t"); FALSE}
echo_true() | echo_false()
echo_true() || echo_false()  # echo_false() isn't evaluated at all!
vec_var <- c(2, 4, 6)
# works (does nothing) using '&&'
if (is.matrix(vec_var) && (vec_var[2, 3] > 0)) {
  vec_var[2, 3] <- 1
}
# no short-circuit so fails (throws an error)
if (is.matrix(vec_var) & (vec_var[2, 3] > 0)) {
  vec_var[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Comparing Objects With \texttt{identical()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{identical()} tests if two objects are exactly equal, and always returns a logical \texttt{TRUE} or \texttt{FALSE} (never \texttt{NA} or logical \texttt{vectors}),
      \vskip1ex
      For atomic arguments \texttt{identical()} often gives the same result as the '\texttt{==}' operator, but it's not synonymous with it in general,
      \vskip1ex
      The '\texttt{==}' operator applies the \emph{recycling rule} to vector arguments and returns logical \texttt{vectors}, but \texttt{identical()} doesn't and returns single logical values,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
num_var <- 2
num_var==2
identical(num_var, 2)

identical(num_var, NULL) 
num_var==NULL

vec_var <- c(2, 4, 6)
vec_var==2
identical(vec_var, 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{which()} accepts a logical \texttt{vector}, and returns a \texttt{vector} of indices corresponding to the \texttt{TRUE} elements,
      \vskip1ex
      \texttt{match()} accepts two arguments, and returns the index of the first value in its second argument, that matches its first argument,
      \vskip1ex
      The binary operator \texttt{\%in\%} returns a logical \texttt{vector} with \texttt{TRUE} values corresponding to elements that have matches,
      \vskip1ex
      \texttt{any()} returns \texttt{TRUE} if at least one element of a logical vector is \texttt{TRUE}, otherwise \texttt{FALSE},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
some_values <- sample(1:10)
some_values
which(some_values==5)
which(some_values>5)
which.max(some_values)
which.min(some_values)
match(5, some_values)
match(-5, some_values)
5 %in% some_values
-5 %in% some_values
c(5, -5) %in% some_values
some_values <- rnorm(10) + 1
some_values
if(any(some_values < 0))
  cat("vector contains negative values\n")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The standard assignment operator in \texttt{R} is \texttt{"<-"},
      \vskip1ex
      Both \texttt{"<-"} and \texttt{"="} are valid assignment operators in \texttt{R},
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} (\texttt{"<-"} has higher precedence than \texttt{"="}),
      \vskip1ex
      The \texttt{"="} operator is used for named arguments in function calls,
      \vskip1ex
      When variables are assigned within an argument list using the \texttt{"="} operator, their \emph{scope} is limited to the function,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
num_var1 <- 3  # "<-" and "=" are valid assignment operators
num_var1
num_var1 = 3
num_var1
median(x = 1:10)  # "=" assignment within argument list
x  # x doesn't exist outside the function
median(x <- 1:10)  # "<-" assignment within argument list
x  # x exists outside the function
      @
  \end{columns}
\end{block}
\pause

\begin{block}{\color{red}{Rule of Thumb}}
  Use \texttt{"<-"} in \texttt{R} scripts and inside functions,
  \vskip1ex
  Use \texttt{"="} only in function calls.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{assign()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{assign()} function assigns a value to a variable name (character string) in a specified \texttt{environment},
      \vskip1ex
      \texttt{assign()} can be used to either assign values to existing variables, or to create new variables,
      \vskip1ex
      \texttt{assign()} allows creating new variables from column names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
new_var <- 1  # create new variable
new_var
assign(x="new_var", value=2)  # assign value to existing variable
new_var
rm(new_var)  # remove new_var
assign(x="new_var", value=3)  # create new variable from name
new_var
# create new variable in new environment
new_env <- new.env()  # create new environment
assign("new_var", 3, envir=new_env)  # assign Value to Name
ls(new_env)  # list objects in "new_env"
new_env$new_var
rm(list=ls())  # delete all objects
# create individual vectors from column names of EuStockMarkets
for (col_name in colnames(EuStockMarkets)) {
  # assign column values to column names
  assign(col_name, EuStockMarkets[, col_name])
}  # end for
ls()
head(CAC)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Creating and Evaluating Symbols and Expressions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{as.symbol()} converts a character string into a \texttt{symbol},
      \vskip1ex
      \texttt{expressions} are objects that represent \texttt{R} formulas and commands,
      \vskip1ex
      \texttt{parse()} converts a character string into an \texttt{expression},
      \vskip1ex
      \texttt{eval()} evaluates a \texttt{symbol} or \texttt{expression} in a specified \texttt{environment},
      \vskip1ex
      \texttt{R} interprets character strings that are not in quotes ("") as \texttt{symbols} or \texttt{expressions},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
rm(list=ls())  # delete all objects
as.symbol("some_string")  # convert string to symbol
class(as.symbol("some_string"))  # name is synonymous with symbol
symbol_name <- 2  # symbols are created during assignments
eval(symbol_name)  # evaluate symbol (same as typing it)
eval(as.symbol("symbol_name"))  # convert string to symbol and evaluate it

# convert string to expression
ex_pression <- parse(text="symbol_new <- symbol_name")
ex_pression
class(ex_pression)
ls()
eval(ex_pression)  # evaluate expression
ls()  # expression evaluation created new object
symbol_new
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Manipulating and Converting Symbols and Expressions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{quote()} accepts \texttt{expressions} or \texttt{symbols}, and returns them without evaluating them,
      \vskip1ex
      \texttt{quote()} doesn't convert character strings into \texttt{symbols},
      \vskip1ex
      The \texttt{substitute()} function substitutes variables that are part of \texttt{expressions}, with their values, and returns an \texttt{expression},
      \vskip1ex
      \texttt{substitute()} accepts named \texttt{lists} as \texttt{environments} in which variables are evaluated,
      \vskip1ex
      \texttt{substitute()} is often used inside \texttt{functions} to substitute formal arguments with names of actual arguments,
      \vskip1ex
      \texttt{deparse()} converts \texttt{expressions} or \texttt{symbols} into character strings,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
quote(symbol_name + symbol_new)  # return expression without evaluating it
# substitute variables in an expression
ex_pression <- substitute(symbol_name + symbol_new, 
                      env=list(symbol_name=1, symbol_new=2))
ex_pression
eval(ex_pression)  # evaluate expression
make_expression <- function(in_var) {
  substitute(symbol_name + in_var)
}  # end make_expression
make_expression(1)
my_var <- 2
make_expression(my_var)
deparse(substitute(symbol_name + symbol_new, 
                  env=list(symbol_new=2)))
make_named <- function(in_var) {
  names(in_var) <- deparse(substitute(in_var))
  in_var
}  # end make_named
make_named(my_var)
my_var <- make_named(my_var)
my_var
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{'\texttt{if}' statements}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has the familiar '\texttt{if() \{...\} else \{...\}}' statement to control execution flow depending on logical conditions,
      \vskip1ex
      The logical conditions must be either a logical or numeric type, otherwise an error is thrown,
      \vskip1ex
      The '\texttt{else}' statement can also be omitted,
      \vskip1ex
      '\texttt{if}' statements can be nested using multiple '\texttt{else if}' statements,
    \column{0.6\textwidth}
        <<echo=2:30>>=
rm(list=ls())
num_var1 <- 1

if (num_var1) {  # numeric zero is FALSE, all other numbers are TRUE
  num_var2 <- 4
} else if (num_var1 == 0) {  # 'else if' together on same line
  num_var2 <- 0
} else {  # 'else' together with curly braces
  num_var2 <- -4
}  # end if

num_var2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function \texttt{ifelse()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{ifelse()} performs vectorized \texttt{if-else} statements on vectors,
      \vskip1ex
      \texttt{ifelse()} is much faster than performing an element-wise loop in \texttt{R},
        <<func_ifelse,echo=2:30,fig.show='hide'>>=
rm(list=ls())
# create two numeric vectors
vec_var1 <- sin(0.25*pi*1:10)
vec_var2 <- cos(0.25*pi*1:10)
# create third vector using 'ifelse'
vec_var3 <- ifelse(vec_var1 > vec_var2, 
                  vec_var1, vec_var2)
# cbind all three together
vec_var4 <- cbind(vec_var1, vec_var2, vec_var3)

# set plotting parameters
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), 
    cex.lab=0.8, cex.axis=0.8, cex.main=0.8, 
    cex.sub=0.5)
# plot matrix
matplot(vec_var4, type="l", lty="solid", 
        col=c("green", "blue", "red"), 
        lwd=c(2, 2, 2), xlab="", ylab="")
# add legend
legend(x="bottomright", legend=colnames(vec_var4), 
       title="", inset=0.05, cex=0.8, lwd=2, 
       lty=c(1, 1, 1), col=c("green", "blue", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/func_ifelse-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using '\texttt{for}' and '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The '\texttt{for() \{...\}}' statement iterates over elements of a vector or list,
      \vskip1ex
      \texttt{R} also has a '\texttt{while() \{...\}}' loop,
      \vskip1ex
      '\texttt{while}' loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE},
      \vskip1ex
      But '\texttt{while}' loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.6\textwidth}
        <<echo=2:30>>=
rm(list=ls())
color_list <- list("red", "white", "blue")
for (some_color in color_list) {  # loop over list
  print(some_color)
}
for (in_dex in 1:3) {  # loop over vector
  print(color_list[[in_dex]])
}

in_dex <- 1  # 'while' loops need initialization
while (in_dex < 4) {  # while loop
  print(color_list[[in_dex]])
  in_dex <- in_dex + 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using '\texttt{for}' Loop}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 1, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
    \column{0.6\textwidth}
        <<echo=(-1)>>=
rm(list=ls())
# fib_seq <- numeric()  # zero length numeric vector
# pre-allocate vector instead of "growing" it
fib_seq <- numeric(10)
fib_seq[1] <- 0  # initialize
fib_seq[2] <- 1  # initialize

for (i in 3:10) {  # perform recurrence loop
  fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2]
}  # end for

fib_seq
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulation Using '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      '\texttt{while}' loops are often used in simulations, when the number of required loops is unknown in advance,
      \vskip1ex
      Below is an example of a simulation of random prices hitting a barrier level,
        <<simu_while,echo=3:30,fig.show='hide'>>=
par(oma=c(1, 1, 1, 1), mgp=c(2, 1, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # for reproducibility
simu_max <- 1000  # max simulation trials
simu_prices <- 0*1:simu_max  # initialize prices
barrier_level <- 20  # barrier level
simu_prices[1] <- 0  # first simulated price
in_dex <- 2  # initialize simulation index
while ((in_dex <= simu_max) && 
         (simu_prices[in_dex - 1] < barrier_level)) {
  simu_prices[in_dex] <- # simulate next price
    simu_prices[in_dex - 1] + rnorm(1)
  in_dex <- in_dex + 1  # advance in_dex
}  # end while
if (in_dex <= simu_max) {  # fill zero prices
  simu_prices[in_dex:simu_max] <- simu_prices[in_dex - 1]
}
# create daily time series starting 2011
ts_var <- ts(data=simu_prices, frequency=365, start=c(2011, 1))
plot(ts_var, type="l", col="black",  # create plot
     lty="solid", xlab="", ylab="")
abline(h=barrier_level, lwd=2, col="red")  # add horizontal line
title(main="Random Prices", line=0)  # add title
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/simu_while-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulation Using Vectorized Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      '\texttt{while}' loops are relatively inefficient (slow), so a better alternative is to use vectorized functions,
        <<simu_vector,echo=3:30,fig.show='hide'>>=
par(oma=c(1, 1, 1, 1), mgp=c(2, 1, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # for reproducibility
simu_max <- 1000  # max simulation trials
barrier_level <- 20  # barrier level
# simulated prices
simu_prices <- cumsum(rnorm(simu_max))
# in_dex is "1" after prices cross barrier_level
in_dex <- cummax(simu_prices > barrier_level)
# find index when prices cross barrier_level
which_index <- which(diff(in_dex)==1)
# fill prices after crossing barrier_level
if (length(which_index)>0) {
  simu_prices[as.logical(in_dex)] <- 
    simu_prices[which_index + 1]
}  # end if
# create daily time series starting 2011
ts_var <- ts(data=simu_prices, frequency=365, start=c(2011, 1))
plot(ts_var, type="l", col="black",  # create plot
     lty="solid", xlab="", ylab="")
abline(h=barrier_level, lwd=2, col="red")  # add horizontal line
title(main="Random Prices", line=0)  # add title
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/simu_vector-1}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{apply()} Instead of '\texttt{for}' and '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      '\texttt{for}' and '\texttt{while}' loops are relatively inefficient and too slow for large computations,
      \vskip1ex
      \texttt{apply()} loops can be more efficient than '\texttt{for}' and '\texttt{while}' loops, although in most cases their speed is comparable,
      \vskip1ex
      More importantly, the \texttt{apply()} syntax is more readable and concise, and fits the functional paradigm of \texttt{R},  and is therefore preferred,
      \vskip1ex
      The function \texttt{system.time()} returns the CPU time used to evaluate a given expression,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
big_matrix <- matrix(rnorm(1000000), ncol=10)
# allocate memory
row_sums <- numeric(nrow(big_matrix))

system.time(
  for(i in 1:nrow(big_matrix)) {
    row_sums[i] <- sum(big_matrix[i,])
  }  # end for
)  # end system.time

system.time(row_sums <- apply(big_matrix, 1, sum))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectorized Functions for Matrix Computations}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Even '\texttt{apply()}' loops are not the most efficient way to calculate statistics on rows and columns of very large matrices,
      \vskip1ex
      \texttt{R} has very efficient functions for calculating sums and means of rows and columns:
      \begin{itemize}
        \item \texttt{rowSums()}
        \item \texttt{colSums()}
        \item \texttt{rowMeans()}
        \item \texttt{colMeans()}
      \end{itemize}
      Vectorized functions accept \texttt{vectors} as arguments, and call compiled \texttt{C} code for very fast calculations,
      \vskip1ex
      Vectorized functions are therefore much faster than \texttt{for()} loops and \texttt{apply()} functions,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
system.time(row_sums <- apply(big_matrix, 1, sum))

str(rowSums)  # get list of arguments

# calculate row sums
system.time(row_sums <- rowSums(big_matrix))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Manipulating Data Frames}


%%%%%%%%%%%%%%%
\subsection{Splitting Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{split()} divides an object into a list of objects, according to a factor (attribute),
      \vskip1ex
      The list's \texttt{names} attribute is made equal to the factor levels,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
unique(iris$Species)  # Species takes on three distinct values
# split into separate data frames by hand
set_osa <- iris[iris$Species=="setosa", ]
versi_color <- iris[iris$Species=="versicolor", ]
virgin_ica <- iris[iris$Species=="virginica", ]
dim(set_osa)
head(set_osa, 2)
# split iris into list based on Species
split_iris <- split(iris, iris$Species)
str(split_iris, max.level=1)
names(split_iris)
dim(split_iris$setosa)
head(split_iris$setosa, 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{split-apply-combine} Procedure}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{split-apply-combine} procedure consists of:
      \begin{itemize}
        \item dividing an object into a list, according to a factor (attribute),
        \item applying a function to each list element,
        \item combining the results,
      \end{itemize}
      The \texttt{split-apply-combine} procedure is similar to \texttt{pivot tables} in Excel,
      \vskip1ex
      The \texttt{split-apply-combine} procedure, by Hadley Wickham:\\
      \url{http://www.jstatsoft.org/v40/i01/paper}
      \vskip1ex
    \column{0.6\textwidth}
      \hskip1em\includegraphics[width=0.5\paperwidth,valign=t]{splitapply.png}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Example \texttt{split-apply-combine} Procedure}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{split-apply-combine} procedure can be performed through successive applications of functions \texttt{split()}, \texttt{apply()}, and \texttt{unlist()},
      \vskip1ex
      \texttt{tapply()} applies a function to sub-vectors aggregated using a factor, and performs the whole \texttt{split-apply-combine} procedure in a single function call, 
      \vskip1ex
      The \texttt{by()} function is a wrapper for \texttt{tapply()},
      \vskip1ex
      The \texttt{with()} function evaluates an expression in an environment constructed from the data,
      \vskip1ex
      The \texttt{aggregate()} function applies a function to aggregations of an object,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
unique(mtcars$cyl)  # cyl has three unique values
# split the mtcars data frame based on number of cylinders
split_cars <- split(mtcars, mtcars$cyl)
str(split_cars, max.level=1)
names(split_cars)
# get mean mpg for each cylinder group
unlist(lapply(split_cars, function(x) mean(x$mpg)))
# Which is identical to the tapply function
tapply(mtcars$mpg, mtcars$cyl, mean)
# using "with" environment
with(mtcars, tapply(mpg, cyl, mean))
# can also use the functions by() and aggregate()
with(mtcars, by(mpg, cyl, mean))
aggregate(formula=(mpg ~ cyl), data=mtcars, FUN=mean)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Example \texttt{split-apply-combine} Returning Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Sometimes the \texttt{split-apply-combine} procedure returns a list of vectors,
      \vskip1ex
      Lists of vectors can be flattened into matrices using the function \texttt{do.call()},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
data_cars <- sapply(split_cars,  # get several mpg stats for each cylinder group
              function(x) {
                c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
              }  # end anonymous function
              )  # end sapply
data_cars  # sapply produces a matrix
data_cars <- lapply(split_cars,  # now same using lapply
              function(x) {
                c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
              }  # end anonymous function
              )  # end sapply
is.list(data_cars)  # lapply produces a list
do.call(cbind, data_cars)  # do.call flattens list into a matrix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{split-apply-combine} Procedure ChickWeight (draft)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      taken from: basic good examples
http://rollingyours.wordpress.com/2013/02/14/welcome/
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
data(ChickWeight)
# ?ChickWeight

# get grouping variables
sapply(ChickWeight, function(x) length(unique(x)))

# get mean weight of the chickens
tapply(ChickWeight$weight, ChickWeight$Diet, mean)

# access individual groups
# create list of my.splits corresponding to individual Diet values
my.splits = split(ChickWeight, ChickWeight$Diet)
length(my.splits)
names(my.splits)
head(my.splits[[1]])

# apply is passing each element to a function - performs for loop "under the hood"
# get all the chicks from each group that weigh less that 40 grams
my.results.lapply = lapply(my.splits, subset, weight <= 40)
# longer way with anonymous function:
my.results.lapply = lapply(my.splits, function(x) subset(x, weight <= 40) )

# fold back into a data frame
my.df = do.call(rbind, my.results.lapply)
my.df

# a different way:
sorted.chickens = ChickWeight[order(ChickWeight$Diet), ]
(sorted.chickens = subset(sorted.chickens, weight <= 40))

# same with for-loop:
my.results.for = list() 
for (ii in 1:length(my.splits)) {
     my.results.for[[ii]] = subset(my.splits[[ii]], weight <= 40)
}
names(my.results.for) = names(my.splits)
all.equal(my.results.lapply, my.results.for) # Should be equal to my.results.lapply

# or in one line:
lapply(split(ChickWeight, ChickWeight$Diet), subset, weight <= 40)
# or
(do.call(rbind, lapply(split(ChickWeight, ChickWeight$Diet), subset, weight <= 40)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Compare \texttt{for()} Loops With \texttt{split-apply-combine} Procedure (draft)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      from: Wickham Split Apply Combine for Data Analysis
      \vskip1ex
      The \texttt{split-apply-combine} procedure allows for analyzing data frames, by spliting an analysis into smaller steps, and then combining them together,
      \vskip1ex
      in data preparation, for performing group-wise ranking, standardization, or normalization,
      \vskip1ex
      creating summaries (aggregations) of data by groups,
      \vskip1ex
      During modeling, for fitting separate models to individual panels of data,
      \vskip1ex
      The \texttt{split-apply-combine} procedure is similar to the \texttt{map-reduce} procedure for processing large data,
      \vskip1ex
      also similar to \texttt{pivot tables} in Excel,
      \vskip1ex
      The \texttt{split()}, \texttt{apply()} and \texttt{combine} Procedure
      \vskip1ex
      The \texttt{lapply()} and \texttt{sapply()} functions are specialized versions of the \texttt{apply()} function,
      \vskip1ex
      The \texttt{lapply()} function applies a function to a list of objects and returns a list,
      \vskip1ex
      The \texttt{sapply()} function applies a function to a list or vector of objects and returns a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
library(plyr)
one <- ozone[1, 1, ]
month <- ordered(rep(1:12, length = 72))
model <- rlm(one ~ month - 1)
deseas <- resid(model)
deseasf <- function(value) rlm(value ~ month - 1)

# For loops
models <- as.list(rep(NA, 24 * 24))
dim(models) <- c(24, 24)
deseas <- array(NA, c(24, 24, 72))
dimnames(deseas) <- dimnames(ozone)
for (i in seq_len(24)) {
for(j in seq_len(24)) {
mod <- deseasf(ozone[i, j, ])
models[[i, j]] <- mod
deseas[i, j, ] <- resid(mod)
}
}

# apply functions
models <- apply(ozone, 1:2, deseasf)
resids_list <- lapply(models, resid)
resids <- unlist(resids_list)
dim(resids) <- c(72, 24, 24)
deseas <- aperm(resids, c(2, 3, 1))
dimnames(deseas) <- dimnames(ozone)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Examples of \texttt{split-apply-combine} Procedure (draft)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      from: 
      http://4dpiecharts.com/2011/12/16/a-quick-primer-on-split-apply-combine-problems/
      \vskip1ex
      we have a data frame with one column containing the values to calculate a statistic for and another column containing the group to which that value belongs
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
# InsectSprays dataset
head(InsectSprays)

# split the count column by the spray column.
count_by_spray <- with(InsectSprays, split(count, spray))

# next apply the statistic to each element of the list. Lets use the mean here.
mean_by_spray <- lapply(count_by_spray, mean)

# finally combine the list as a vector
unlist(mean_by_spray)

# or in one line
sapply(count_by_spray, mean)

# can also use the functions tapply(), aggregate() and by():
with(InsectSprays, tapply(count, spray, mean))
with(InsectSprays, by(count, spray, mean))
aggregate(count ~ spray, InsectSprays, mean)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Debugging and Exception Handling}


%%%%%%%%%%%%%%%
\subsection{Validating Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} provides several ways to handle missing or unexpected argument values, 
      \vskip1ex
      A popular method of catching missing actual arguments is to assign \texttt{NULL} default values to formal arguments, and then to call function \texttt{is.null()} on them,
      \vskip1ex
      Another method is to call the function \texttt{missing()} on the arguments,
      \vskip1ex
      Object \texttt{type} validation functions such as \texttt{is.numeric()} should be called before executing any further operations,
      \vskip1ex
      When the function \texttt{return()} is called inside a function body, it returns its argument and terminates futher function execution,
      \vskip1ex
      \texttt{cat()} statements in the function provide information about the state of its variables,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# function "double_it" returns the double of its argument
double_it <- function(in_var=NULL) {
# check if argument is valid and return double
  if (is.null(in_var)) {
    return("double_it: in_var is missing")
  } else if (is.numeric(in_var)) {
    2*in_var
  } else {
    cat("double_it: in_var is not numeric")
  }
}  # end double_it
double_it(3)
double_it("a")
double_it()

double_it <- function(in_var) {
# check if argument is valid and return double
  if (missing(in_var)) {
    return("double_it: in_var is missing")
  } else if (is.numeric(in_var)) {
    2*in_var
  } else {
    cat("double_it: in_var is not numeric")
  }
}  # end double_it
double_it(3)
double_it("a")
double_it()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Assertions Inside Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      If assertions about variables inside functions are \texttt{FALSE}, then \texttt{stop()} can be called to halt its execution,
      \vskip1ex
      The function \texttt{stop()} halts function execution, produces an \emph{error} condition, and returns its message to the error handler,
      \vskip1ex
      Calling \texttt{stop()} allows easy debuging by calling the function \texttt{traceback()} or rerunning execution under \texttt{debug()},
      \vskip1ex
      The function \texttt{traceback()} prints the call stack that produced the \emph{error} condition,
      \vskip1ex
      Therefore calling \texttt{stop()} is preferable to calling \texttt{return()}, or temporarily inserting \texttt{cat()} statements into the code,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# function "double_it" returns the double of its argument
double_it <- function(in_var=NULL) {
# check if argument is valid and return double
  if (missing(in_var)) {
    stop("double_it: in_var is missing")
  } else if (!is.numeric(in_var)) {
    stop("double_it: in_var is not numeric")
  } else {
    2*in_var
  }
}  # end double_it
double_it(3)
double_it("a")
double_it()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Assertions Using \texttt{stopifnot()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{stopifnot()} stops function execution and produces an \emph{error} condition if its argument is \texttt{FALSE},
      \vskip1ex
      \texttt{stopifnot()} is a convenience wrapper for \texttt{stop()}, and eliminates the need to use \texttt{if()} statements,
      \vskip1ex
      \texttt{stopifnot()} is often used to check the validity of function arguments,
      \vskip1ex
      \texttt{stopifnot()} can be inserted anywhere in the function body in order to check assertions about its variables,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# function "double_it" returns the double of its argument
double_it <- function(in_var=NULL) {
# check if argument is valid and return double
  stopifnot(!is.null(in_var) && is.numeric(in_var))
  2*in_var
}  # end double_it
double_it(3)
double_it("a")
double_it()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Validating Function Arguments and Debugging}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} provides robust validation and debugging tools through \texttt{type} validation functions, and functions \texttt{missing()}, \texttt{stop()}, and \texttt{stopifnot()},
      \vskip1ex
      A simple way to produce a message from within a function is to call the \texttt{cat()} function,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# function "sum_two" returns the sum of its two arguments
sum_two <- function(in_var1, in_var2) {  # even more robust
# check if at least one argument is not missing
  stopifnot(!missing(in_var1) || !missing(in_var2))
# check if arguments are valid and return sum
  if (is.numeric(in_var1) && is.numeric(in_var2)) {
    in_var1 + in_var2  # both valid
  } else if (is.numeric(in_var1)) {
    cat("in_var2 is not numeric")
    in_var1  # in_var1 is valid
  } else if (is.numeric(in_var2)) {
    cat("in_var1 is not numeric")
    in_var2  # in_var2 is valid
  } else {
    stop("none of the arguments are numeric")
  }
}  # end sum_two
sum_two(1, 2)
sum_two(5, 'a')
sum_two('a', 5)
sum_two('a', 'b')
sum_two()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exception Conditions: Errors and Warnings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{Conditions} are \texttt{R} objects containing information about errors, warnings etc., produced while evaluating expressions,
      \vskip1ex
      The function \texttt{stop()} halts function execution, produces an \emph{error} condition, and returns its message to the error handler,
      \vskip1ex
      The function \texttt{warning()} produces an \emph{warning} condition, and returns its message to the error handler,
      \vskip1ex
      The handling of \emph{warning} conditions depends on the value of \texttt{options("warn")}:
      \begin{itemize}
        \item \emph{negative} then warnings are ignored,
        \item \emph{zero} then warnings are stored and printed after the top-level function has completed,
        \item \emph{one} then warnings are printed as they occur,
        \item \emph{two} or larger then warnings are turned into errors,
      \end{itemize}
      The function \texttt{suppressWarnings()} evaluates its expressions and ignores all warnings,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# ?options
getOption("warn")
getOption("error")
catch_missing <- function(in_var) {
# returns its argument
  if (missing(in_var)) {
    warning("catch_missing: in_var was missing")
  } else {
    in_var
  }
}  # end catch_missing
catch_missing(5)
options(warn=-1)
catch_missing()
options(warn=0)
catch_missing()
options(warn=1)
catch_missing()
options(warn=3)
catch_missing()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Handling Exception Conditions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{tryCatch()} can be used as a wrapper around functions or expressions, to handle conditions produced when they are evaluated,
      \vskip1ex
      If no \texttt{condition} is produced then \texttt{tryCatch()} just returns the value of the expression,
      \vskip1ex
      If a \texttt{condition} is produced then \texttt{tryCatch()} invokes error and warning \emph{handlers} and executes other expressions to provide information about the \texttt{condition}, 
      \vskip1ex
      If a \emph{handler} is provided to \texttt{tryCatch()} then the error is captured by the \emph{handler}, instead of being broadcast,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
str(tryCatch)  # get arguments of tryCatch()
tryCatch(  # without error handler
  {  # evaluate expressions
    num_var <- 101  # assign
    stop('my error')  # throw error
  }, 
  finally=print(paste("num_var=", num_var))
)  # end tryCatch

tryCatch(  # with error handler
  {  # evaluate expressions
    num_var <- 101  # assign
    stop('my error')  # throw error
  }, 
  error=function(error_cond)  # handler captures error condition
    print(paste("error handler: ", error_cond)),
  finally=print(paste("num_var=", num_var))
)  # end tryCatch
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exception Handling in Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If an \texttt{error} occurs in an \texttt{apply()} loop, then the loop exits without returning any result,
      \vskip1ex
      The function \texttt{tryCatch()} captures errors, allowing loops to continue after the error \texttt{condition},
      <<echo=2:30>>=
rm(list=ls())
# apply loop without tryCatch
apply(as.matrix(1:5), 1, function(num_var) {  # anonymous function
    stopifnot(num_var != 3)  # check for error
    cat("(cat) num_var =", num_var, "\n")  # broadcast
    paste("(return) num_var =", num_var)  # return value
  }  # end anonymous function
)  # end apply
      @
      Without \texttt{tryCatch()}, the \texttt{apply()} loop exits without returning any result,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=1:30>>=
# apply loop with tryCatch
apply(as.matrix(1:5), 1, function(num_var) {  # anonymous function
    tryCatch(  # with error handler
      {  # body
        stopifnot(num_var != 3)  # check for error
        cat("(cat) num_var =", num_var, "\t")  # broadcast
        paste("(return) num_var =", num_var)  # return value
      },
      error=function(error_cond)  # handler captures error condition
        paste("handler: ", error_cond),
      finally=print(paste("(finally) num_var =", num_var))
    )  # end tryCatch
  }  # end anonymous function
)  # end apply
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
