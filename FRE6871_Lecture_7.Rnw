% FRE6871_Lecture_7
% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, eval=FALSE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
\usepackage{listings}
\usepackage{xcolor}
\definecolor{cmd_background}{rgb}{0.2, 0.2, 0.0}
\definecolor{vba_background}{rgb}{0.0, 0.0, 0.9}
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture\#7]{FRE6871 \texttt{R} in Finance}
\subtitle{Lecture\#7, Spring 2018}

\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@poly.edu}
\date{March 24, 2018}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Environments in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{\secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Environments consist of a \emph{frame} (a set of symbol-value pairs) and an \emph{enclosure} (a pointer to an enclosing environment),
      \vskip1ex
      There are three system environments:
      \begin{itemize}
        \item \texttt{globalenv()} the user's workspace,
        \item \texttt{baseenv()} the environment of the base package,
        \item \texttt{emptyenv()} the only environment without an enclosure,
      \end{itemize}
      Environments form a tree structure of successive enclosures, with the empty environment at its root,
      \vskip1ex
      Packages have their own environments,
      \vskip1ex
      The enclosure of the base package is the empty environment,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
# get base environment
baseenv()
# get global environment
globalenv()
# get current environment
environment()
# get environment class
class(environment())
# define variable in current environment
glob_var <- 1
# get objects in current environment
ls(environment())
# create new environment
new_env <- new.env()
# get calling environment of new environment
parent.env(new_env)
# assign Value to Name
assign("new_var1", 3, envir=new_env)
# create object in new environment
new_env$new_var2 <- 11
# get objects in new environment
ls(new_env)
# get objects in current environment
ls(environment())
# environments are subset like lists
new_env$new_var1
# environments are subset like lists
new_env[["new_var1"]]
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Search Path}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} evaluates variables using the search path, a series of environments:
      \begin{itemize}
        \item global environment,
        \item package environments,
        \item base environment,
      \end{itemize}
      The function \texttt{search()} returns the search path for \texttt{R} objects,
      \vskip1ex
      The function \texttt{attach()} attaches objects to the search path,
      \vskip1ex
      Using \texttt{attach()} allows referencing object components by their names alone, rather than as components of objects,
      \vskip1ex
      The function \texttt{detach()} detaches objects from the search path,
      \vskip1ex
      The function \texttt{find()} finds where objects are located on the search path,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<eval=TRUE>>=
search()  # get search path for R objects
my_list <- 
  list(flowers=c("rose", "daisy", "tulip"), 
       trees=c("pine", "oak", "maple"))
my_list$trees
attach(my_list)
trees
search()  # get search path for R objects
detach(my_list)
head(trees)  # "trees" is in datasets base package
      @
      \begin{block}{\color{red}{Rule of Thumb}}
        Be very careful with using \texttt{attach()},
        \vskip1ex
        Make sure to \texttt{detach()} objects once they're not needed,
      \end{block}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Extracting Time Series from Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Time series can be extracted from an \emph{environment} by coercing it into a \texttt{list}, and then subsetting and merging it into an \emph{xts} using the function \texttt{do.call()},
      \vskip1ex
      A list of \emph{xts} can be flattened into a single \emph{xts} using the function \texttt{do.call()},
      \vskip1ex
      The function \texttt{do.call()} executes a function call using a function name and a list of arguments,
      \vskip1ex
      \texttt{do.call()} passes the list elements individually, instead of passing the whole list as one argument,
      \vskip1ex
      The extractor (accessor) functions \texttt{Ad()}, \texttt{Vo()}, etc., extract columns from \emph{OHLC} data,
      \vskip1ex
      The function \texttt{eapply()} is similar to \texttt{lapply()}, and applies a function to objects in an \emph{environment}, and returns a list,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
library(HighFreq)  # load package HighFreq
# ETF symbols
sym_bols <- c("VTI", "VEU", "IEF", "VNQ")
# extract and merge all data, subset by sym_bols
price_s <- do.call(merge, 
  as.list(rutils::env_etf)[sym_bols])
# extract and merge adjusted prices, subset by sym_bols
price_s <- do.call(merge, 
  lapply(as.list(rutils::env_etf)[sym_bols], Ad))
# same, but works only for OHLC series
price_s <- do.call(merge, 
  eapply(rutils::env_etf, Ad)[sym_bols])
# drop ".Adjusted" from colnames
colnames(price_s) <- 
  sapply(colnames(price_s), 
    function(col_name) 
      strsplit(col_name, split="[.]")[[1]])[1, ]
tail(price_s[, 1:2], 3)
# which objects in global environment are class xts?
unlist(eapply(globalenv(), is.xts))

# save xts to csv file
write.zoo(price_s, 
     file='etf_series.csv', sep=",")
# copy price_s into env_etf and save to .RData file
assign("price_s", price_s, envir=env_etf)
save(env_etf, file='etf_data.RData')
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Referencing Object Components Using \texttt{with()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{with()} evaluates an expression in an environment constructed from the data, 
      \vskip1ex
      \texttt{with()} allows referencing object components by their names alone,
      \vskip1ex
      It's often better to use \texttt{with()} instead of \texttt{attach()},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<eval=TRUE>>=
# "trees" is in datasets base package
head(trees, 3)
colnames(trees)
mean(Girth)
mean(trees$Girth)
with(trees, 
     c(mean(Girth), mean(Height), mean(Volume)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{assign()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{assign()} function assigns a value to an object in a specified \emph{environment}, by referencing it using a character string (name),
      \vskip1ex
      \texttt{assign()} can be used to either assign values to existing variables, or to create new variables,
      \vskip1ex
      \texttt{assign()} looks for the object name in the specified \emph{environment}, and assigns a value to it,
      \vskip1ex
      If \texttt{assign()} can't find the object name, then it creates it,
      \vskip1ex
      \texttt{assign()} expects a character string as its argument,
      \vskip1ex
      If a object name is passsed to \texttt{assign()}, then it evaluates that object to get the string it contains,
      \vskip1ex
      If the object doesn't contain a string, then \texttt{assign()} produces an error,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
my_var <- 1  # create new object
assign(x="my_var", value=2)  # assign value to existing object
my_var
rm(my_var)  # remove my_var
assign(x="my_var", value=3)  # create new object from name
my_var
# create new object in new environment
new_env <- new.env()  # create new environment
assign("my_var", 3, envir=new_env)  # assign value to name
ls(new_env)  # list objects in "new_env"
new_env$my_var
rm(list=ls())  # delete all objects
sym_bol <- "my_var"  # define symbol containing string "my_var"
assign(sym_bol, 1)  # assign value to "my_var"
ls()
my_var
assign("sym_bol", "new_var")
assign(sym_bol, 1)  # assign value to "new_var"
ls()
sym_bol <- 10
assign(sym_bol, 1)  # can't assign to non-string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Applying \texttt{assign()} to Lists of Names}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{assign()} allows creating new objects from lists or vectors of names (character strings), such as column names,
      \vskip1ex
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
rm(list=ls())  # delete all objects
# create individual vectors from column names of EuStockMarkets
for (col_name in colnames(EuStockMarkets)) {
# assign column values to column names
  assign(col_name, EuStockMarkets[, col_name])
}  # end for
ls()
head(DAX)
head(EuStockMarkets[, "DAX"])
identical(DAX, EuStockMarkets[, "DAX"])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Retrieving Objects Using \texttt{get()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{get()} accepts a character string and returns the value of the corresponding object in a specified \emph{environment},
      \vskip1ex
      \texttt{get()} retrieves objects that are referenced using character strings, instead of their names,
      \vskip1ex
      The functions \texttt{get()} and \texttt{assign()} allow retrieving and assigning values to objects that are referenced using character strings,
      \vskip1ex
      The function \texttt{mget()} accepts a vector of strings and returns a list of the corresponding objects,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# create new environment
test_env <- new.env()
# pass string as name to create new object
assign("my_var1", 2, envir=test_env)
# create new object using $ string referencing
test_env$my_var2 <- 1
# list objects in new environment
ls(test_env)
# reference an object by name
test_env$my_var1
# reference an object by string name using get
get("my_var1", envir=test_env)
# retrieve and assign value to object
assign("my_var1",
       2*get("my_var1", envir=test_env),
       envir=test_env)
get("my_var1", envir=test_env)
# return all objects in an environment
mget(ls(test_env), envir=test_env)
# delete environment
rm(test_env)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{\texttt{R} Packages}


%%%%%%%%%%%%%%%
\subsection{\secname}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{Types of \subsecname}
  \texttt{R} can run libraries of functions called packages,
  \vskip1ex
  \texttt{R} packages can can also  contain data,
  \vskip1ex
  Most packages need to be \emph{loaded} into \texttt{R} before they can be used,
  \vskip1ex
  \texttt{R} includes a number of \texttt{base} packages that are already installed and loaded,
  \vskip1ex
  There's also a special package called the \texttt{base} package, which is responsible for all the basic \texttt{R} functionality,
  \vskip1ex
  \texttt{datasets} is a \texttt{base} package containing various datasets, for example \texttt{EuStockMarkets},
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \protect\emph{base} Packages}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} includes a number of packages that are pre-installed (often called \emph{base} packages),\\
      Some \emph{base} packages:
      \begin{itemize}
        \item \emph{base} - basic \texttt{R} functionality,
        \item \emph{stats} - statistical functions and random number generation,
        \item \emph{graphics} - basic graphics,
        \item \emph{utils} - utility functions,
        \item \emph{datasets} - popular datasets,
        \item \emph{parallel} - support for parallel computation,
      \end{itemize}
    \column{0.5\textwidth}
      Very popular packages:
      \begin{itemize}
        \item \emph{MASS} - functions and datasets for "Modern Applied Statistics with S",
        \item \emph{ggplot2} - grammar of graphics plots,
        \item \emph{shiny} - interactive web graphics from R,
        \item \emph{slidify} - HTML5 slide shows from R,
        \item \emph{devtools} - create R packages,
        \item \emph{roxygen2} - document R packages,
        \item \emph{Rcpp} - integrate C++ code with R,
        \item \emph{RcppArmadillo} - interface to Armadillo linear algebra library,
        \item \emph{forecast} - linear models and forecasting,
        \item \emph{tseries} - time series analysis and computational finance,
        \item \emph{zoo} - time series and ordered objects,
        \item \emph{xts} - advanced time series objects,
        \item \emph{quantmod} - quantitative financial modeling framework,
        \item \emph{caTools} - moving window statistics for graphics and time series objects,
      \end{itemize}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{CRAN} Package Views}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{columns}[T]
  \column{0.4\textwidth}
    \begin{block}{}
      \emph{CRAN} view for package \emph{AER}:\\
      \hskip1em\url{http://cran.r-project.org/web/packages/AER/}\\
    \end{block}
    \begin{block}{}
      Note:
      \begin{itemize}
        \item Authors,
        \item Version number,
        \item Reference manual,
        \item Vignettes,
        \item Dependencies on other packages.
      \end{itemize}
    \end{block}
    \begin{block}{}
      The package source code can be downloaded by clicking on the \href{package source}{package source} link,
    \end{block}
  \column{0.6\textwidth}
    \includegraphics[height=1.0\textwidth]{image/CRAN_Package.png}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{CRAN} Task Views}
\begin{frame}[fragile,t]{\subsecname}

\begin{columns}[T]
  \column{0.4\textwidth}
    \begin{block}{}
      \emph{CRAN} Finance Task View\\
      \hskip1em\url{http://cran.r-project.org//}\\
    \end{block}
    \begin{block}{}
      Note:
      \begin{itemize}
        \item Maintainer,
        \item Topics,
        \item List of packages.
      \end{itemize}
    \end{block}
  \column{0.6\textwidth}
    \vspace{-1em}
    \includegraphics[height=1.0\textwidth]{image/CRAN_Views.png}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installing Packages}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most packages need to be \emph{installed} before they can be loaded and used,
      \vskip1ex
      Some packages like \emph{MASS} are installed with base \texttt{R} (but not loaded),
      \vskip1ex
      \emph{Installing} a package means downloading and saving its files to a local computer directory (hard disk), so they can be \emph{loaded} by the \texttt{R} system,
      \vskip1ex
      The function \texttt{install.packages()} installs packages from the \texttt{R} command line,
      \vskip1ex
      Most widely used packages are available on the \emph{CRAN} repository:\\
      \hskip1em\url{http://cran.r-project.org/web/packages/}
      \vskip1ex
      Or on \emph{R-Forge} or \emph{GitHub}:\\
      \hskip1em\url{https://r-forge.r-project.org/}\\
      \hskip1em\url{https://github.com/}
      \vskip1ex
      Packages can also be installed in \emph{RStudio} from the menu (go to \alert{Tools} and then \alert{Install packages}),\\
      \vskip1ex
      Packages residing on GitHub can be installed using the devtools packages,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
getOption("repos")  # get default package source
.libPaths()  # get package save directory
      @
      \vspace{-2em}
      <<eval=FALSE>>=
install.packages("AER")  # install "AER" from CRAN
# install "PerformanceAnalytics" from R-Forge
install.packages(
  pkgs="PerformanceAnalytics",  # name
  lib="C:/Users/Jerzy/Downloads",  # directory
  repos="http://R-Forge.R-project.org")  # source
      @
      \vspace{-2em}
      <<eval=FALSE>>=
# install devtools from CRAN
install.packages("devtools")
# load devtools
library(devtools)
# install package "babynames" from GitHub
install_github(repo="hadley/babynames")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installing Packages From Source}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Sometimes packages aren't available in compiled form, so it's necessary to install them from their source code,
      \vskip1ex
      To install a package from source, the user needs to first install compilers and development tools:\\
      \hskip1em For Windows install \texttt{Rtools}:\\
\url{https://cran.r-project.org/bin/windows/Rtools/}\\
      \hskip1em For Mac OSX install \texttt{XCode} developer tools:\\
\url{https://developer.apple.com/xcode/downloads/}
      \vskip1ex
      The function \texttt{install.packages()} with argument \texttt{type="source"} installs a package from source,
      \vskip1ex
      The function \texttt{download.packages()} downloads the package's installation files (compressed tar format) to a local directory,
      \vskip1ex
      The function \texttt{install.packages()} can then be used to install the package from the downloaded files,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE, eval=FALSE>>=
# install package "PortfolioAnalytics" from source
install.packages("PortfolioAnalytics",
  type="source",
  repos="http://r-forge.r-project.org")
# download files for package "PortfolioAnalytics"
download.packages(pkgs = "PortfolioAnalytics",
  destdir = ".",  # download to cwd
  type = "source",
  repos="http://r-forge.r-project.org")
# install "PortfolioAnalytics" from local tar source
install.packages(
  "C:/Users/Jerzy/Downloads/PortfolioAnalytics_0.9.3598.tar.gz",
  repos=NULL, type="source")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Installed Packages}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{defaultPackages} contains a list of packages loaded on startup by default,
      \vskip1ex
      The function \texttt{installed.packages()} returns a matrix of all packages installed on the system,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
getOption("defaultPackages")
pack_info <- installed.packages()  # matrix of packages
# get a few package names and their versions
pack_info[sample(x=1:100, 5), c("Package", "Version")]
t(pack_info["xts", ])  # get info for package "xts"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package Files and Directories}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Package installation files are organized into multiple directories, including some of the following:
      \begin{itemize}
        \item \texttt{\textasciitilde{}/R} containing \texttt{R} source code files,
        \item \texttt{\textasciitilde{}/src} containing \texttt{C++} and \texttt{Fortran} source code files,
        \item \texttt{\textasciitilde{}/data} containing datasets,
        \item \texttt{\textasciitilde{}/man} containing documentation files,
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE, eval=TRUE>>=
# list directories in "PortfolioAnalytics" sub-directory
gsub(
  "C:/Users/Jerzy/Documents/R/win-library/3.1",
  "~",
  list.dirs(
    file.path(
      .libPaths()[1],
      "PortfolioAnalytics")))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Loading Packages}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most packages need to be \emph{loaded} before they can be used in an \texttt{R} session,
      \vskip1ex
      Loading a package means attaching the package \emph{namespace} to the \emph{search path}, which allows \texttt{R} to call the package functions and data,
      \vskip1ex
      The functions \texttt{library()} and \texttt{require()} load packages, but in slightly different ways,
      \vskip1ex
      \texttt{library()} produces an \emph{error} (halts execution) if the package can't be loaded,
      \vskip1ex
      \texttt{require()} returns \texttt{TRUE} if the package is loaded successfully, and \texttt{FALSE} otherwise,
      \vskip1ex
      Therefore \texttt{library()} is usually used in script files that might be sourced, while \texttt{require()} is used inside functions,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# load package, produce error if can't be loaded
library(MASS)
# load package, return TRUE if loaded successfully
require(MASS)
# load quietly
library(MASS, quietly=TRUE)
# load without any messages
suppressMessages(library(MASS))
# remove package from search path
detach(MASS)
# install package if it can't be loaded successfully
if (!require("xts")) install.packages("xts")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Referencing Package Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      After a package is \emph{loaded}, the package functions and data can be accessed by name,
      \vskip1ex
      Package objects can also be accessed without \emph{loading} the package, by using the double-colon \texttt{"::"} reference operator,
      \vskip1ex
      For example, \texttt{TTR::VWAP()} references the function \texttt{VWAP()} from the package \emph{TTR},
      \vskip1ex
      This way users don't have to load the package \emph{TTR} (with \texttt{library(TTR)}) to use functions from the package \emph{TTR},
      \vskip1ex
      Using the \texttt{"::"} operator displays the source of objects, and makes \texttt{R} code easier to analyze, 
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
# calculate VTI volume-weighted average price
v_wap <- TTR::VWAP(
  price=quantmod::Ad(rutils::env_etf$VTI), 
  volume=quantmod::Vo(rutils::env_etf$VTI), n=10)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Packages}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \emph{Ecdat} contains data sets for econometric analysis,
      \vskip1ex
      The data frame \texttt{Garch} contains daily currency prices,
      \vskip1ex
      The function \texttt{data()} loads external data or lists data sets in a package,
      \vskip1ex
      Some packages provide \emph{lazy loading} of their data sets, which means they automatically load their data sets when they're needed (when they are called by some operation),
      \vskip1ex
      The package's data isn't loaded into \texttt{R} memory when the package is \emph{loaded}, so it's not listed using \texttt{ls()}, but the package data is available without calling the function \texttt{data()},
      \vskip1ex
      The function \texttt{data()} isn't required to load data sets that are set up for \emph{lazy loading},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
library()  # list all packages installed on the system
search()  # list all loaded packages on search path

# get documentation for package "Ecdat"
packageDescription("Ecdat")  # get short description
help(package="Ecdat")  # load help page
library(Ecdat)  # load package "Ecdat"
data(package="Ecdat")  # list all datasets in "Ecdat"
ls("package:Ecdat")  # list all objects in "Ecdat"
browseVignettes("Ecdat")  # view package vignette
detach("package:Ecdat")  # remove Ecdat from search path
      @
      \vspace{-1em}
      <<>>=
library(Ecdat)  # load econometric data sets
class(Garch)  # Garch is a data frame from "Ecdat"
dim(Garch)  # daily currency prices
head(Garch[, -2])  # col 'dm' is Deutsch Mark
detach("package:Ecdat")  # remove Ecdat from search path
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package Namespaces}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Package \emph{namespaces}:
      \begin{itemize}
        \item Provide a mechanism for calling objects from a package,
        \item Hide functions and data internal to the package,
        \item Prevent naming conflicts between user and package names,
      \end{itemize}
      When a package is loaded using \texttt{library()} or \texttt{require()}, its \emph{namespace} is attached to the search path,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
search()  # get search path for R objects
library(MASS)  # load package "MASS"
head(ls("package:MASS"))  # list some objects in "MASS"
detach("package:MASS")  # remove "MASS" from search path
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package Namespaces and the Search Path}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Packages may be loaded without their \emph{namespace} being attached to the search path,
      \vskip1ex
      When packages are loaded, then packages they depend on are also loaded, but their \emph{namespaces} aren't necessarily attached to the search path,
      \vskip1ex
      The function \texttt{loadedNamespaces()} lists all loaded \emph{namespaces}, including those that aren't on the search path,
      \vskip1ex
      The function \texttt{search()} returns the current search path for \texttt{R} objects,
      \vskip1ex
      \texttt{search()} returns many package \emph{namespaces}, but not all the loaded \emph{namespaces},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
loadedNamespaces()  # get names of loaded namespaces

search()  # get search path for R objects
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Not Attached Namespaces}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{sessionInfo()} returns information about the current \texttt{R} session, including packages that are loaded, but \emph{not attached} to the search path,
      \vskip1ex
      \texttt{sessionInfo()} lists those packages as "loaded via a \emph{namespace} (and not attached)"
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# get session info,
# including packages not attached to the search path
sessionInfo()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Non-Visible Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Non-visible objects (variables or functions) are either:
      \begin{itemize}
        \item objects from \emph{not attached} \emph{namespaces},
        \item objects \emph{not exported} outside a package,
      \end{itemize}
      Objects from packages that aren't attached can be accessed using the double-colon \texttt{"::"} reference operator,
      \vskip1ex
      Objects that are \emph{not exported} outside a package can be accessed using the triple-colon \texttt{":::"} reference operator,
      \vskip1ex
      Colon operators automatically load the associated package,
      \vskip1ex
      Non-visible objects in namespaces often use the \texttt{".*"} name syntax,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
plot.xts  # package xts isn't loaded and attached
head(xts::plot.xts, 3)
methods("cbind")  # get all methods for function "cbind"
stats::cbind.ts  # cbind isn't exported from package stats
stats:::cbind.ts  # view the non-visible function
getAnywhere("cbind.ts")
library(MASS)  # load package 'MASS'
select  # code of primitive function from package 'MASS'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Namespaces and Non-Visible Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{getAnywhere()} displays information about \texttt{R} objects, including non-visible objects,
      \vskip1ex
      Objects referenced \emph{within} packages have different search paths than other objects:\\
      Their search path starts in the package \emph{namespace}, then the global environment and then finally the regular search path,
      \vskip1ex
      This way references to objects from \texttt{within} a package are resolved to the package, and they're not masked by objects of the same name in other environments,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
getAnywhere("cbind.ts")
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Input and Output}


%%%%%%%%%%%%%%%
\subsection{Writing Text Strings}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{cat()} concatenates strings and writes them to standard output or to files,
      \vskip1ex
      \texttt{cat()} interprets its argument character string and its escape sequences (\texttt{"\textbackslash{}"}), but doesn't return a value,
      \vskip1ex
      The function \texttt{print()} doesn't interpret its argument, and simply prints it to standard output and invisibly returns it,
      \vskip1ex
      Typing the name of an object in \texttt{R} implicitly calls \texttt{print()} on that object,
      \vskip1ex
      The function \texttt{save()} writes objects to a binary file,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
setwd("C:/Develop/R/lecture_slides/data")
cat("Enter\ttab")  # cat() interprets backslash escape sequences
print("Enter\ttab")

my_text <- print("hello")
my_text  # print() returns its argument

# create string
my_text <- "Title: My Text\nSome numbers: 1,2,3,...\nRprofile files contain code executed at R startup,\n"

cat(my_text, file="mytext.txt")  # write to text file

cat("Title: My Text",  # write several lines to text file
    "Some numbers: 1,2,3,...",
    "Rprofile files contain code executed at R startup,", 
    file="mytext.txt", sep="\n")

save(my_text, file="mytext.RData")  # write to binary file
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Displaying Numeric Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{print()} displays numeric data objects, with the number of digits given by the global option \texttt{"digits"}, 
      \vskip1ex
      The function \texttt{sprintf()} returns strings formatted from text strings and numeric data, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=TRUE>>=
print(pi)
print(pi, digits=10)
getOption("digits")
foo <- 12
bar <- "months"
sprintf("There are %i %s in the year", foo, bar)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading Text from Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{scan()} reads text or data from a file and returns it as a vector or a list,
      \vskip1ex
      The function \texttt{readLines()} reads lines of text from a connection (file or console), and returns them as a vector of \texttt{character} strings,
      \vskip1ex
      The function \texttt{readline()} reads a single line from the console, and returns it as a \texttt{character} string,
      \vskip1ex
      The function \texttt{file.show()} reads text or data from a file and displays in editor,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
setwd("C:/Develop/R/lecture_slides/data")
# read text from file
scan(file="mytext.txt", what=character(), sep="\n")

# read lines from file
readLines(con="mytext.txt")

# read text from console
in_put <- readline("Enter a number: ")
class(in_put)
# coerce to numeric
in_put <- as.numeric(in_put)

# read text from file and display in editor:
# file.show("mytext.txt")
# file.show("mytext.txt", pager="")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data Frames from \protect\emph{Text} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from text files,
      \vskip1ex
      \texttt{write.table()} coerces objects to data frames before it writes them,
      \vskip1ex
      \texttt{read.table()} returns a data frame, and coerces non-numeric values to \texttt{factors} (unless the \texttt{stringsAsFactors=FALSE} option is set),
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} can be used to read and write matrices from text files, but they have to be coerced back to matrices,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:4))>>=
setwd("C:/Develop/R/lecture_slides/data")
data_frame <- data.frame(type=c("rose", "daisy", "tulip"), color=c("red", "white", "yellow"), price=c(1.5, 0.5, 1.0), row.names=c("flower1", "flower2", "flower3"))  # end data.frame
mat_rix <- matrix(sample(1:12), ncol=3, dimnames=list(NULL, c("col1", "col2", "col3")))
rownames(mat_rix) <- paste("row", 1:NROW(mat_rix), sep="")
# write data frame to text file, and then read it back
write.table(data_frame, file="florist.txt")
data_read <- read.table(file="florist.txt")
data_read  # a data frame

# write matrix to text file, and then read it back
write.table(mat_rix, file="matrix.txt")
mat_read <- read.table(file="matrix.txt")
mat_read  # write.table() coerced matrix to data frame
class(mat_read)
# coerce from data frame back to matrix
mat_read <- as.matrix(mat_read)
class(mat_read)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Copying Data Frames Between the \protect\emph{clipboard} and \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Data frames stored in the \emph{clipboard} can be copied into \texttt{R} using the function \texttt{read.table()},
      \vskip1ex
      Data frames in \texttt{R} can be copied into the \emph{clipboard} using the function \texttt{write.table()},
      \vskip1ex
      This allows convenient copying of data frames between \texttt{R} and \emph{Excel},
      \vskip1ex
      Data frames can also be manipulated directly in the \texttt{R} spreadsheet-style data editor,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=(-(1:3)),eval=FALSE>>=
setwd("C:/Develop/R/lecture_slides/data")
data_frame <- data.frame(small=c(3, 5), medium=c(9, 11), large=c(15, 13))
data_frame <- read.table("mydata.txt", header=TRUE)
data_frame <- read.table("clipboard", header=TRUE)

write.table(x=data_frame, file="clipboard", sep="\t")

# wrapper function for copying data frame from clipboard into R
# by default, data is tab delimited, with a header
read_clip <- function(file="clipboard", sep="\t", 
                      header=TRUE, ...) {
  read.table(file=file, sep=sep, header=header, ...)
}  # end read_clip

data_frame <- read_clip()

# wrapper function for copying data frame from R into clipboard
# by default, data is tab delimited, with a header
write_clip <- function(data, row.names=FALSE, 
                       col.names=TRUE, ...) {
  write.table(x=data, file="clipboard", sep="\t", 
              row.names=row.names, col.names=col.names, ...)
}  # end write_clip

write_clip(data=data_frame)

# launch spreadsheet-style data editor
data_frame <- edit(data_frame)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data Frames From \protect\emph{csv} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The easiest way to share data between \texttt{R} and \emph{Excel} is through writing and reading \emph{csv()} files, 
      \vskip1ex
      The functions \texttt{read.csv()} and \texttt{write.csv()} read and write data frames from \emph{csv} format files,
      \vskip1ex
      The functions \texttt{read.csv()} and \texttt{write.csv()} read and write data frames from \emph{csv} format files,
      \vskip1ex
      These functions are wrappers for \texttt{read.table()} and \texttt{write.table()},
      \vskip1ex
      \texttt{read.csv()} coerces non-numeric values to \texttt{factors}, unless the \texttt{stringsAsFactors=FALSE} option is set,
      \vskip1ex
      \texttt{read.csv()} reads row names as an extra column, unless the \texttt{row.names=1} argument is used,
      \vskip1ex
      The argument \texttt{"row.names"} accepts either the number or the name of the column containing the row names,
      \vskip1ex
      The \texttt{*.csv()} functions are very inefficient for large data sets,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
setwd("C:/Develop/R/lecture_slides/data")
# write data frame to CSV file, and then read it back
write.csv(data_frame, file="florist.csv")
data_read <- read.csv(file="florist.csv", 
                       stringsAsFactors=FALSE)
data_read  # the row names are read in as extra column
# restore row names
rownames(data_read) <- data_read[, 1]
data_read <- data_read[, -1]  # remove extra column
data_read
# read data frame, with row names from first column
data_read <- read.csv(file="florist.csv", row.names=1)
data_read
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data Frames From \protect\emph{csv} Files (cont.)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} can read and write data frames from \emph{csv} format files \emph{without using row names},
      \vskip1ex
      Row names can be omitted from the output file by calling \texttt{write.csv()} with the argument \texttt{row.names=FALSE}, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
setwd("C:/Develop/R/lecture_slides/data")
# write data frame to CSV file, without row names
write.csv(data_frame, row.names=FALSE, file="florist.csv")
data_read <- read.csv(file="florist.csv")
data_read  # a data frame without row names
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices From \protect\emph{csv} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} can read and write matrices from \emph{csv} format files,
      \vskip1ex
      If row names can be omitted in the output file, then \texttt{write.csv()} can be called with argument \texttt{row.names=FALSE}, 
      \vskip1ex
      If the input file doesn't contain row names, then \texttt{read.csv()} can be called without the \texttt{"row.names"} argument,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
setwd("C:/Develop/R/lecture_slides/data")
# write matrix to csv file, and then read it back
write.csv(mat_rix, file="matrix.csv")
mat_read <- read.csv(file="matrix.csv", row.names=1)
mat_read  # read.csv() reads matrix as data frame
class(mat_read)
mat_read <- as.matrix(mat_read)  # coerce to matrix
identical(mat_rix, mat_read)
write.csv(mat_rix, row.names=FALSE, 
          file="matrix_ex_rows.csv")
mat_read <- read.csv(file="matrix_ex_rows.csv")
mat_read <- as.matrix(mat_read)
mat_read  # a matrix without row names
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices (cont.)}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      There are several ways of reading and writing matrices from \emph{csv} files, with tradeoffs between simplicity, data size, and speed,
      \vskip1ex
      The function \texttt{write.matrix()} writes a matrix to a text file, without its row names,
      \vskip1ex
      \texttt{write.matrix()} is part of package \emph{MASS},
      \vskip1ex
      The advantage of function \texttt{scan()} is its speed, but it doesn't handle row names easily,
      \vskip1ex
      Removing row names simplifies the reading and writing of matrices,
      \vskip1ex
      The function \texttt{readLines} reads whole lines and returns them as single strings,
      \vskip1ex
      The function \texttt{system.time()} calculates the execution time (in seconds) used to evaluate a given expression,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1))>>=
setwd("C:/Develop/R/lecture_slides/data")
library(MASS)  # load package "MASS"
# write to CSV file by row - it's very SLOW!!!
write.matrix(mat_rix, file="matrix.csv", sep=",")
system.time(  # scan reads faster - skip first line with colnames
  mat_read <- scan(file="matrix.csv", sep=",", 
                  skip=1, what=numeric()))
col_names <- readLines(con="matrix.csv", n=1)  # read colnames
col_names  # this is a string!
col_names <- strsplit(col_names, s=",")[[1]]  # convert to char vector
mat_read  # mat_read is a vector, not matrix!
# coerce by row to matrix
mat_read <- matrix(mat_read, ncol=length(col_names), 
                  byrow=TRUE)
colnames(mat_read) <- col_names  # restore colnames
mat_read
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading Matrices Containing Bad Data}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Very often data that is read from external sources contains elements with bad data,
      \vskip1ex
      An example of bad data are \texttt{character} strings in \texttt{numeric} data,
      \vskip1ex
      Columns of numeric data that contain strings are coerced to \texttt{character} or \texttt{factor}, when they're read by \texttt{read.csv()},
      \vskip1ex
      \texttt{as.numeric()} coerces strings that don't represent numbers into \texttt{NA} values,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
setwd("C:/Develop/R/lecture_slides/data")
# read data from a csv file, including row names
mat_rix <- read.csv(file="matrix_bad.csv", row.names=1,
                     stringsAsFactors=FALSE)
mat_rix
class(mat_rix)
# columns with bad data are character or factor
sapply(mat_rix, class)
row_names <- row.names(mat_rix)  # copy row names
# sapply loop over columns and coerce to numeric
mat_rix <- sapply(mat_rix, as.numeric)
row.names(mat_rix) <- row_names  # restore row names
# replace NAs with zero
mat_rix[is.na(mat_rix)] <- 0
# matrix without NAs
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing \protect\emph{zoo} Series From \protect\emph{Text} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \emph{zoo} contains functions \texttt{read.zoo()} and \texttt{write.zoo()} for reading and writing \emph{zoo} objects from \emph{text} and \emph{csv} files,
      \vskip1ex
      \texttt{read.zoo()} and \texttt{write.zoo()} are wrappers for \texttt{read.table()} and \texttt{write.table()},
      \vskip1ex
      By default these functions read and write data in \emph{space}-delimited format, but they can also read and write data to \emph{comma}-delimited \emph{csv} files by passing the parameter \texttt{sep=","}, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:4))>>=
setwd("C:/Develop/R/lecture_slides/data")
rm(list=ls())
set.seed(1121)  # reset random number generator
library(zoo)  # load package zoo
# create zoo with Date index
in_dex <- seq(from=as.Date("2013-06-15"), 
                  by="day", length.out=100)
zoo_series <- zoo(cumsum(rnorm(NROW(in_dex))), 
                  order.by=in_dex)
tail(zoo_series, 3)
# write zoo to text file, and then read it back
write.zoo(zoo_series, file="zoo_series.txt")
zoo_series <- read.zoo("zoo_series.txt")  # read it back
tail(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing \protect\emph{zoo} Series With \protect\emph{Date-time} Index}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      If the index of a \emph{zoo} series is a \emph{date-time}, then \texttt{write.zoo()} writes the date and time fields as separate columns with a \emph{space} between them, 
      \vskip1ex
      To properly read separate date and time columns from \emph{text} files, \texttt{read.zoo()} must be passed arguments \texttt{"index.column=list(1,2)"} and \texttt{"tz"},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:4))>>=
setwd("C:/Develop/R/lecture_slides/data")
rm(list=ls())
set.seed(1121)  # reset random number generator
library(zoo)  # load package zoo
# create zoo with POSIXct date-time index
in_dex <- seq(from=as.POSIXct("2013-06-15"), 
                  by="hour", length.out=1000)
zoo_series <- zoo(cumsum(rnorm(length(in_dex))), 
                  order.by=in_dex)
tail(zoo_series, 3)
# write zoo to text file, and then read it back
write.zoo(zoo_series, file="zoo_series.txt")
zoo_series <- read.zoo("zoo_series.txt")  # read it back
# time field was read as a separate column
tail(zoo_series, 3)
# read and specify that second column is time field
zoo_series <- read.zoo(file="zoo_series.txt", 
                       index.column=list(1,2), 
                       tz="America/New_York")
tail(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing \protect\emph{zoo} Series From \protect\emph{csv} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Single column \emph{zoo} time series usually don't have a dimension attribute, and they don't have a column name, unlike multi-column \emph{zoo} time series, and this can cause hard to detect bugs,
      \vskip1ex
      It's best to always pass the argument \texttt{"col.names=TRUE"} to the function \texttt{write.zoo()}, to make sure it writes a column name for a single column \emph{zoo}  time series,
      \vskip1ex
      Reading a \emph{csv} file containing a single column of data using the function \texttt{read.zoo()} produces a \emph{zoo}  time series with a \texttt{NULL} dimension, unless the argument \texttt{"drop=FALSE"} is passed to \texttt{read.zoo()},
      \vskip1ex
      Very often \emph{csv} files contain custom \emph{date-time} formats, which need to be passed as parameters into \texttt{read.zoo()} for proper formatting,
      \vskip1ex
      The \texttt{"FUN"} argument of \texttt{read.zoo()} accepts a function for coercing columns of the input data into a \emph{date-time} object suitable for the \emph{zoo} index,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:2))>>=
setwd("C:/Develop/R/lecture_slides/data")
library(zoo)  # load package zoo
# write zoo to CSV file, and then read it back
write.zoo(zoo_series, file="zoo_series.csv", 
          sep=",", col.names=TRUE)
zoo_series <- read.zoo(file="zoo_series.csv", 
                  header=TRUE, sep=",", 
                  drop=FALSE, 
                  FUN=as.POSIXct, tz="America/New_York")
tail(zoo_series, 3)
# read zoo from CSV file, with custom date-time format
zoo_frame <- read.table(file="zoo_series2.csv", 
                        sep=",")
tail(zoo_frame, 3)  # date-time format mm/dd/yyyy hh:mm
zoo_series <- read.zoo(file="zoo_series2.csv", 
                  header=TRUE, sep=",", 
                  drop=FALSE, 
                  FUN=as.POSIXct, 
                  tz="America/New_York",
                  format="%m/%d/%Y %H:%M")
tail(zoo_series, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Passing Arguments to the \texttt{save()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{save()} writes objects to a binary file,
      \vskip1ex
      Object names can be passed into \texttt{save()} either through the \texttt{"..."} argument, or the \texttt{"list"} argument,
      \vskip1ex
      Objects passed through the \texttt{"..."} argument are not evaluated, so they must be either object names or character strings,
      \vskip1ex
      Object names aren't surrounded by quotes \texttt{""}, while character strings that represent object names are surrounded by quotes \texttt{""},
      \vskip1ex
      Objects passed through the \texttt{"list"} argument are evaluated, so they may be variables containing character strings,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())  # remove all objects
var1 <- 1; var2 <- 2
ls()  # list all objects
ls()[1]  # list first object
args(save)  # list arguments of save function
# save "var1" to a binary file using string argument
save("var1", file="my_data.RData")
# save "var1" to a binary file using object name
save(var1, file="my_data.RData")
# save multiple objects
save(var1, var2, file="my_data.RData")
# save first object in list by passing to "..." argument
# ls()[1] is not evaluated
save(ls()[1], file="my_data.RData")
# save first object in list by passing to "list" argument
save(list=ls()[1], file="my_data.RData")
# save whole list by passing it to the "list" argument
save(list=ls(), file="my_data.RData")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Lists of Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{load()} reads data from \texttt{*.RData} files, and \emph{invisibly} returns a vector of names of objects created in the workspace,
      \vskip1ex
      The vector of names can be used to manipulate the objects in loops, or to pass them to functions,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
rm(list=ls())  # remove all objects
# load objects from file
load_ed <- load(file="my_data.RData")
load_ed  # vector of loaded objects
ls()  # list objects
# assign new values to objects in  global environment
sapply(load_ed, function(sym_bol) {
  assign(sym_bol, runif(1), envir=globalenv())
})  # end sapply
ls()  # list objects
# assign new values to objects using for loop
for (sym_bol in load_ed) {
  assign(sym_bol, runif(1))
}  # end for
ls()  # list objects
# save vector of objects
save(list=load_ed, file="my_data.RData")
# remove only loaded objects
rm(list=load_ed)
# remove the object "load_ed"
rm(load_ed)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Saving Output of \texttt{R} to a File}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{sink()} diverts \texttt{R} \emph{text} output (excluding graphics) to a file, or ends the diversion,
      \vskip1ex
      Remember to call \texttt{sink()} to end the diversion!
      \vskip1ex
      The function \texttt{pdf()} diverts graphics output to a \emph{pdf} file (text output isn't diverted), in vector graphics format,
      \vskip1ex
      The functions \texttt{png()}, \texttt{jpeg()}, \texttt{bmp()}, and \texttt{tiff()} divert graphics output to graphics files (text output isn't diverted), 
      \vskip1ex
      The function \texttt{dev.off()} ends the diversion,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
sink("sinkdata.txt")# redirect text output to file

cat("Redirect text output from R\n")
print(runif(10))
cat("\nEnd data\nbye\n")

sink()  # turn redirect off

pdf("Rgraph.pdf", width=7, height=4)  # redirect graphics to pdf file

cat("Redirect data from R into pdf file\n")
my_var <- seq(-2*pi, 2*pi, len=100)
plot(x=my_var, y=sin(my_var), main="Sine wave", 
   xlab="", ylab="", type="l", lwd=2, col="red")
cat("\nEnd data\nbye\n")

dev.off()  # turn pdf output off

png("r_plot.png")  # redirect graphics output to png file

cat("Redirect graphics from R into png file\n")
plot(x=my_var, y=sin(my_var), main="Sine wave", 
 xlab="", ylab="", type="l", lwd=2, col="red")
cat("\nEnd data\nbye\n")

dev.off()  # turn png output off
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package \protect\emph{googlesheets} for Interacting with \protect\emph{Google Sheets}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package 
      \href{https://cran.r-project.org/web/packages/googlesheets/index.html}{\emph{googlesheets}} 
      allows interacting with \emph{Google Sheets} from \texttt{R}, 
      \vskip1ex
      If you already have a \emph{Google} account, then your personal \emph{Google Sheets} can be found at:\\
      \hskip1em\url{https://docs.google.com/spreadsheets/}
      \vskip1ex
      The function \texttt{gs\_ls()} lists the files in \emph{Google Sheets}, 
      \vskip1ex
      The function \texttt{gs\_title()} registers a \emph{Google} sheet, and returns a \texttt{googlesheet} object, 
      \vskip1ex
      A \texttt{googlesheet} object contains information (metadata) about a \emph{Google} sheet, such as its name and key, but not the sheet data itself, 
      \vskip1ex
      The function \texttt{gs\_browse()} opens a \emph{Google} sheet in an internet browser, 
      \vskip1ex
      You can find online a document about 
      \href{https://cran.r-project.org/web/packages/googlesheets/vignettes/basic-usage.html}{using \emph{googlesheets}}, 
      \vskip1ex
      You can find online a document about 
      \href{https://cran.r-project.org/web/packages/googlesheets/vignettes/managing-auth-tokens.html}{managing authentication tokens}, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
# install latest version of googlesheets
devtools::install_github("jennybc/googlesheets")
# load package googlesheets
library(googlesheets)
library(dplyr)
# authenticate authorize R to view and manage your files
gs_auth(new_user=TRUE)
# list the files in Google Sheets
googlesheets::gs_ls()
# register a sheet
google_sheet <- gs_title("my_data")
# view sheet summary
google_sheet
# list tab names in sheet
tab_s <- gs_ws_ls(google_sheet)
# set curl options
library(httr)
httr::set_config(config(ssl_verifypeer=0L))
# read data from sheet
gs_read(google_sheet)
# read data from single tab of sheet
gs_read(google_sheet, ws=tab_s[1])
gs_read_csv(google_sheet, ws=tab_s[1])
# or using dplyr pipes
google_sheet %>% gs_read(ws=tab_s[1])
# download data from sheet into file
gs_download(google_sheet, ws=tab_s[1], 
            to="C:/Develop/R/lecture_slides/data/google_sheet.csv")
# open sheet in internet browser
gs_browse(google_sheet)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading Data from \protect\emph{Google Sheets}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \emph{googlesheets} allows interacting with \emph{Google Sheets} from \texttt{R}, 
      \vskip1ex
      If you already have a \emph{Google} account, then your personal \emph{Google Sheets} can be found at:\\
      \hskip1em\url{https://docs.google.com/spreadsheets/}
      \vskip1ex
      The function \texttt{gs\_ls()} lists the files in \emph{Google Sheets}, 
      \vskip1ex
      The function \texttt{gs\_title()} registers a \emph{Google} sheet, and returns a \texttt{googlesheet} object, 
      \vskip1ex
      A \texttt{googlesheet} object contains information (metadata) about a \emph{Google} sheet, such as its name and key, but not the sheet data itself, 
      \vskip1ex
      The function \texttt{gs\_read()} downloads data from a \emph{Google} sheet and returns a data frame, 
      \vskip1ex
      The function \texttt{gs\_download()} downloads data from a \emph{Google} sheet into a file, 
      \vskip1ex
      The function \texttt{gs\_browse()} opens a \emph{Google} sheet in an internet browser, 
      \vskip1ex
    \column{0.5\textwidth}
      \vspace{-1em}
      <<eval=FALSE>>=
# install latest version of googlesheets
devtools::install_github("jennybc/googlesheets")
# load package googlesheets
library(googlesheets)
library(dplyr)
# authenticate authorize R to view and manage your files
gs_auth(new_user=TRUE)
# list the files in Google Sheets
googlesheets::gs_ls()
# register a sheet
google_sheet <- gs_title("my_data")
# view sheet summary
google_sheet
# list tab names in sheet
tab_s <- gs_ws_ls(google_sheet)
# set curl options
library(httr)
httr::set_config(config(ssl_verifypeer=0L))
# read data from sheet
gs_read(google_sheet)
# read data from single tab of sheet
gs_read(google_sheet, ws=tab_s[1])
gs_read_csv(google_sheet, ws=tab_s[1])
# or using dplyr pipes
google_sheet %>% gs_read(ws=tab_s[1])
# download data from sheet into file
gs_download(google_sheet, ws=tab_s[1], 
            to="C:/Develop/R/lecture_slides/data/google_sheet.csv")
# open sheet in internet browser
gs_browse(google_sheet)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Running \texttt{R} Scripts and Batch Processes}


%%%%%%%%%%%%%%%
\subsection{Sourcing \texttt{R} Script Files in an \texttt{R} Session}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{R} commands can be saved into a file, and then executed from an interactive \texttt{R} session using the function \texttt{source()}, 
      \vskip1ex
      The function \texttt{source()} executes \texttt{R} commands contained in a file, or in a \emph{URL},
      \vskip1ex
      The function \texttt{file.path()} is similar to \texttt{paste()}, but it also automatically uses the correct file separator for the computer platform,
      \vskip1ex
      The function \texttt{readline()} reads a single line from the console, and returns it as a \texttt{character} string,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
script_dir <- "C:/Develop/R/scripts"
# execute script file and print the commands
source(file.path(script_dir, "script.R"), 
       echo=TRUE)

####################################
### script.R file contains R script to demonstrate sourcing from script files

# print information about this process
print(paste0("print: This test script was run at: ", format(Sys.time())))
cat("cat: This test script was run at:", format(Sys.time()), "\n")

# display first 6 rows of cars data frame
head(cars)

# define a function
fun_c <- function(x) x+1

# read a line from console
readline("Press Return to continue")

# plot sine function in x11 window
x11()
curve(expr=sin, type="l", xlim=c(-2*pi, 2*pi),
      xlab="", ylab="", lwd=2, col="orange",
      main="Sine function")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Running \texttt{R} Processes From the Command Window}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      An interactive \texttt{R} process can be run from the command window, by simply typing the commands \texttt{R} or \texttt{Rterm} (provided that your \emph{PATH} variable contains the directory of the \texttt{R} executable file), 
      \vskip1ex
      The command \texttt{R} combined with the option \texttt{-e} can also execute \texttt{R} commands supplied on the command line, 
      \vskip1ex
      For example the command: 
        \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
R --vanilla -e head(cars) > out.txt
        \end{lstlisting}
      executes a single \texttt{R} command, and saves the output to a file,
      \vskip1ex
      The option \texttt{vanilla} instructs \texttt{R} to produce minimal output,
      \vskip1ex
      The manual \emph{Introduction to R} provides more information about running \texttt{R} processes from the command window:\\
      \hskip1em\url{https://cran.r-project.org/doc/manuals/R-intro.html#Invoking-R-from-the-command-line}
    \column{0.5\textwidth}
      \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
# start an interactive R process
> R

# get help about running R process
> R --help

# execute single R command and save output to file
# vanilla option to produce minimal output
> R --vanilla -e head(cars) > out.txt
      \end{lstlisting}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing \texttt{R} Scripts as Batch Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{batch} process is the execution of a set of commands in a script file, without manual intervention (non-interactive mode),
      \vskip1ex
      There are two ways of running an \texttt{R} script file: 
      \begin{itemize}
        \item in \emph{interactive} mode from within an \texttt{R} session using the function \texttt{source()}, 
        \item in non-interactive \emph{batch} mode from a command window, 
      \end{itemize}
      \texttt{R} \emph{batch} processes can be executed using the commands \texttt{R}, \texttt{R CMD BATCH}, and \texttt{Rscript}, 
      \vskip1ex
      For example the command: 
        \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
Rscript script.R > out.txt
        \end{lstlisting}
      executes a \emph{batch} process on a script file containing a plot command and \texttt{readline()} for user input, and saves the output to a file,
      \vskip1ex
      The command \texttt{Rscript} can also execute \texttt{R} commands supplied on the command line, for example:
        \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
Rscript -e "head(cars)" > out.txt
        \end{lstlisting}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
# get help about running R scripts and batch processes
?BATCH
?Rscript
      @
      \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
# execute script file and save output to file
# vanilla option to produce minimal output
> cd C:/Develop/R/scripts
> R --vanilla < script.R > out.txt

# execute script file and save output to file
# slave option to produce minimal output
> R CMD BATCH --slave script.R out.txt

# execute script file and save output to file
> Rscript script.R > out.txt

# execute single R command from Windows
> Rscript -e "head(cars)" > out.txt

# execute several R commands and save output to file
> Rscript -e "source('script.R'); fun_c(2)" > out.txt
      \end{lstlisting}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing \texttt{R} Scripts Using \texttt{Rscript}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{commandArgs()} returns a vector of strings containing the arguments supplied to the \texttt{R} process when called from the command line, 
      \vskip1ex
      The \texttt{Rscript} command is designed for fast execution of \texttt{R} scripts, and can also accept arguments to the \texttt{R} script supplied on the command line, for example:
        \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
Rscript --vanilla script_args.R  4 5 6
        \end{lstlisting}
      \vskip1ex
      The \texttt{Rscript} command can also accept arguments supplied to \texttt{R} scripts on the command line, for example:
        \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
Rscript -e "2*as.numeric(commandArgs(TRUE))" 3

Rscript -e "sum(as.numeric(commandArgs(TRUE)))" 4 5 6
        \end{lstlisting}
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
### script_args.R contains R script that accepts arguments
# print information about this process
cat("cat: This script was run at:", format(Sys.time()), "\n")
# read arguments supplied on the command line
arg_s <- commandArgs(TRUE)
# print the arguments
cat(paste0("arguments supplied on command line: ", paste(arg_s, collapse=", "), "\n"))
# return sum of arguments
sum(as.numeric(arg_s))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Plotting to a File From an \texttt{R} Script}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      A \emph{batch} \texttt{R} process usually fails to produce a plot, because the \texttt{x11} plot window closes as soon as the \texttt{R} process terminates, 
      \vskip1ex
      The function \texttt{readline()} doesn't work in batch mode either, because it doesn't wait for user input, 
      \vskip1ex
      But a \emph{batch} \texttt{R} process can plot to a file by diverting its graphics output to a  graphics file,
      \vskip1ex
      The functions \texttt{png()}, \texttt{jpeg()}, \texttt{bmp()}, and \texttt{tiff()} divert graphics output to graphics files (text output isn't diverted), 
      \vskip1ex
      The function \texttt{dev.off()} ends the diversion,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
### plot_to_file.R
### R script to demonstrate plotting to file

# redirect graphics output to png file
plot_dir <- "C:/Develop/data"
png(file.path(plot_dir, "r_plot.png"))

# plot sine function
curve(expr=sin, type="l", xlim=c(-2*pi, 2*pi),
      xlab="", ylab="", lwd=2, col="orange",
      main="Sine function")

# turn png output off
dev.off()
      @
      \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
# execute script file and save output to file
> Rscript plot_to_file.R > out.txt
      \end{lstlisting}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interactive Plots in Batch \texttt{R} Processes}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Interactive plots don't work in batch \texttt{R} processes, because the attached \texttt{x11} plot window closes as soon as an \texttt{R} process terminates,
      \vskip1ex
      One way to get around this is by pausing the \texttt{R} process using a \texttt{while()} loop, to wait until all the \texttt{x11} plot windows are closed,
      \vskip1ex
      The function \texttt{dev.list()} returns the number and names of active graphics devices,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE,eval=FALSE>>=
### plot_interactive.R
### R script to demonstrate interactive plotting

# plot sine function in x11 window
x11()
curve(expr=sin, type="l", xlim=c(-2*pi, 2*pi),
      xlab="", ylab="", lwd=2, col="orange",
      main="Sine function")

# wait until x11 window is closed
while (!is.null(dev.list())) Sys.sleep(1)
      @
      \begin{lstlisting}[language=sh,basicstyle=\scriptsize\ttfamily\color{yellow},backgroundcolor=\color{cmd_background},showstringspaces=FALSE]
# execute script file and save output to file
> Rscript plot_interactive.R > out.txt
      \end{lstlisting}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Combining \texttt{R} with \protect\emph{Excel}}


%%%%%%%%%%%%%%%
\subsection{Performing Calculations in \protect\emph{Excel} Using \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Excel} can run \texttt{R} using either \emph{VBA} scripts, or through a \emph{COM} interface (available on \emph{Windows} only),
      \vskip1ex
      \texttt{R} can perform calculations and export its output to \emph{Excel} files, or it can modify \emph{Excel} files (requires packages using \emph{Java} or \emph{Perl} code), 
      \vskip1ex
      Calculations in \texttt{R} and \emph{Excel} can be combined in several different ways: 
      \begin{itemize}
        \item Data from \emph{Excel} can be exchanged with \texttt{R} via \emph{csv} files (simplest and best method), 
        \item \emph{Excel} can execute \texttt{R} commands using \emph{VBA} scripts, and then import the \texttt{R} output from \emph{csv} files,
        \item An \emph{Excel} add-in can execute \texttt{R} commands as \emph{Excel} functions (relies on \emph{COM} protocol, so works only for \emph{Windows}): add-ins 
        \emph{\href{http://bert-toolkit.com/}{BERT}}, 
        \emph{\href{http://sunsite.univie.ac.at/rcom/}{RExcel}}, 
        \item \texttt{R} can modify \emph{Excel} files and run \emph{Excel} functions (requires packages using \emph{Java} or \emph{Perl} code): packages 
        \emph{\href{https://cran.r-project.org/web/packages/xlsx/index.html}{xlsx}}, 
        \emph{\href{https://cran.r-project.org/web/packages/XLConnect/index.html}{XLConnect}}, 
        \emph{\href{https://cran.r-project.org/web/packages/excel.link/index.html}{excel.link}}, 
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
### perform calculations in R, 
### and export to CSV files
setwd("C:/Develop/R/lecture_slides/data")
# read data frame, with row names from first column
data_read <- read.csv(file="florist.csv", 
                      row.names=1)
# subset data frame
data_read <- 
  data_read[data_read[, "type"]=="daisy", ]
# write data frame to CSV file, with row names
write.csv(data_read, file="daisies.csv")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Running \texttt{R} Code from \protect\emph{Excel}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      There are several ways of performing calculations in \texttt{R} and exporting the outputs to \emph{Excel}:
      \begin{itemize}
        \item Export data from \emph{Excel} via \emph{csv} files to \texttt{R}, perform the calculations in \texttt{R}, and import the outputs back to \emph{Excel} via \emph{csv} files (simplest and best method),
        \item Run \texttt{R} from \emph{Excel} using \emph{VBA} scripts, and exchange data via \emph{csv} files, 
        \item Run \texttt{R} from \emph{Excel} using an \emph{Excel} add-in, and execute \texttt{R} commands as \emph{Excel} functions (relies on the \emph{COM} protocol, so works only for \emph{Windows}),
      \end{itemize}
    \column{0.5\textwidth}
      \vspace{-1em}
        <<echo=TRUE,eval=FALSE>>=
### perform calculations in R, 
### and export to CSV files
setwd("C:/Develop/R/lecture_slides/data")
# read data frame, with row names from first column
data_read <- read.csv(file="florist.csv", 
                      row.names=1)
# subset data frame
data_read <- 
  data_read[data_read[, "type"]=="daisy", ]
# write data frame to CSV file, with row names
write.csv(data_read, file="daisies.csv")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Running \texttt{R} Code Using \protect\emph{VBA} Scripts}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      An \texttt{R} session can be launched from \emph{Excel} using a \emph{VBA} script (macro),
      \vskip1ex
      The \emph{VBA} function \texttt{shell()} executes a program by running an executable \emph{exe} file (with extension \emph{exe}),
      \vskip1ex
      A \emph{VBA} script can also run an \texttt{R} \emph{batch} process,
      \vskip1ex
      The \texttt{R} \emph{batch} process can write to \emph{csv} files, which can then be imported into \emph{Excel},
    \column{0.6\textwidth}
      \renewcommand{\ttdefault}{pcr}
      \begin{lstlisting}[language=VBScript,basicstyle=\tiny\ttfamily\bfseries\color{yellow},backgroundcolor=\color{vba_background},showstringspaces=FALSE]
' VBA macro to run R process
Sub run_r()
 Call shell("R", vbNormalFocus)
End Sub
      \end{lstlisting}
      \begin{lstlisting}[language=VBScript,basicstyle=\tiny\ttfamily\bfseries\bfseries\color{yellow},backgroundcolor=\color{vba_background},showstringspaces=FALSE]
' VBA macro to run interactive R process
Sub run_rinteractive()
 Dim script_dir As String: script_dir = "C:\Develop\R\scripts\"
 Dim script_file As String: script_file = "plot_interactive.R"
 Dim log_file As String: log_file = "C:\Develop\R\scripts\log.txt"
 Call shell("R --vanilla < " & script_dir & script_file & ">" & log_file, vbNormalFocus)
End Sub
      \end{lstlisting}
      \begin{lstlisting}[language=VBScript,basicstyle=\tiny\ttfamily\bfseries\bfseries\color{yellow},backgroundcolor=\color{vba_background},showstringspaces=FALSE]
' VBA macro to run batch R process
Sub run_rbatch()
 Dim script_dir As String: script_dir = "C:\Develop\R\scripts\"
 Dim script_file As String: script_file = "plot_to_file.R"
 Dim log_file As String: log_file = "C:\Develop\R\scripts\log.txt"
 Call shell("R --vanilla < " & script_dir & script_file & ">" & log_file, vbNormalFocus)
End Sub
      \end{lstlisting}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\protect\emph{BERT} Excel Add-in for Running \texttt{R} Code}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{BERT} is an \emph{Excel} add-in which allows executing \texttt{R} commands as \emph{Excel} functions:\\
      \hskip1em\url{http://bert-toolkit.com/}\\
      \hskip1em\url{http://bert-toolkit.com/bert-quick-start}\\
      \hskip1em\url{https://github.com/sdllc/Basic-Excel-R-Toolkit/wiki}\\
      \hskip1em\url{https://github.com/sdllc/Basic-Excel-R-Toolkit}
      \vskip1ex
      \emph{BERT} launches its own \texttt{R} process from \emph{Excel},
      \vskip1ex
      \emph{BERT} can create its own menu in the \emph{Excel} add-ins tab:\\
      After installing \emph{BERT}, click on upper-left \emph{Office Button}, click \emph{Excel} options, on the bottom of the window choose (Manage: \emph{COM} Add-ins) Go, add the \emph{COM} add-in BERTRibbon2x86.dll, 
      \vskip1ex
      \emph{BERT} relies on the \emph{COM} protocol, so it works only for \emph{Windows},
    \column{0.5\textwidth}
      \renewcommand{\ttdefault}{pcr}
      \begin{lstlisting}[language=VBScript,basicstyle=\tiny\ttfamily\bfseries\color{yellow},backgroundcolor=\color{vba_background},showstringspaces=FALSE]
' calculate sum of Excel cells using R
R.Add(B1:D1)

' remove NAs over Excel cell range using R function
R.na_omit(F2:H4)

' calculate eigenValues of Excel matrix using R function
R.EigenValues(A1:H8)
      \end{lstlisting}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Object-Oriented Programming in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{The \texttt{S3} Object-Oriented Programming System in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{S3} is the standard object oriented (OO) programming system in \texttt{R},
      \vskip1ex
      The \texttt{S3} system is based on \emph{generic} functions and the \texttt{R} \emph{class} system,
      \vskip1ex
      \emph{Generic} functions are functions that execute different \emph{methods} depending on the class of the object on which the \emph{generic} function is called,
      \vskip1ex
      \emph{Methods} are functions that are specific to a \emph{generic} function and a class of objects,
      \vskip1ex
      \emph{Methods} follow the naming convention \texttt{generic\_function.classname()},
      \vskip1ex
      The actual function that is executed (called a \emph{method}) is determined by the class of the object on which the \emph{generic} function is called,
      \vskip1ex
      For example, when the function \texttt{merge()} is called on a \texttt{zoo} object, then \texttt{R} executes the \emph{method} \texttt{merge.zoo()},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
library(zoo)  # load package zoo
# show the generic function "merge"
merge
# show the "merge" method dispatched to "zoo" objects
merge.zoo
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generic Functions and Their Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{generic} function \texttt{merge()} has many \emph{methods} with names \texttt{merge.*()},
      \vskip1ex
      The function \texttt{methods()} lists all the \emph{methods} of a generic function, or all the \emph{methods} for a \emph{class} of objects,
      \vskip1ex
      The \texttt{merge()} method dispatched to \texttt{zoo} objects is called \texttt{merge.zoo()},
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
library(zoo)  # load package zoo
# get all methods for generic function merge()
methods(generic.function="merge")
# get generic function methods applied to "zoo" objects
methods(class="zoo")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Method Dispatch Using \texttt{UseMethod()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{UseMethod()} can be used to implement \emph{generic} functions,
      \vskip1ex
      \texttt{UseMethod()} accepts at least two arguments: the name of a \emph{generic} function, and the arguments passed to the \emph{generic} function,
      \vskip1ex
      \texttt{UseMethod()} calls (\emph{dispatches}) a particular \emph{method} associated with the \emph{generic} function, depending on the \emph{class} of the arguments passed to the \emph{generic} function,
      \vskip1ex
      The arguments passed to the \emph{generic} function are by default passed to \texttt{UseMethod()}, and then along to the \emph{method} itself,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# define a generic function
gen_sum <- function (a, b, ...) {
  UseMethod("gen_sum")
}  # end gen_sum

# define method for "numeric" class
gen_sum.numeric <- function (a, b, ...) {
  sum(a, b)
}  # end gen_sum.character

# define method for "character" class
gen_sum.character <- function (a, b, ...) {
  paste(a, "plus", b)
}  # end gen_sum.character

# apply gen_sum to "numeric" objects
gen_sum(1, 2)
# apply gen_sum to "character" objects
gen_sum("a", "b")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Method Dispatch by Internal Generic Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \emph{Method} dispatch by \emph{internal generic} functions is performed inside compiled \texttt{C} code, instead of \texttt{R} code using the function \texttt{UseMethod()},
      \vskip1ex
      \emph{Internal} functions are implemented using the function \texttt{.Internal()},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# 'cbind' is an internal generic function
cbind
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operator Overloading}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Operator \emph{overloading} refers to defining new \emph{methods} for an existing \emph{generic} function,
      \vskip1ex
      The \texttt{"+"} operator may be overloaded by defining a new \emph{method} for \texttt{"character"} objects,
      \vskip1ex
      But for the \emph{overloading} of the \texttt{"+"} operator to work, the objects must have an explicit \texttt{"character"} class \emph{attribute} assigned to them,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# define "+" method for "character" class
"+.character" <- function (a, b, ...) {
  paste(a, "plus", b)
}  # end +.character
methods("+")  # view methods for "+" operator
# define variables with "character" class
char1 <- "a"
char2 <- "b"
class(char1)
char1 + char2  # add two "character" objects - doesn't work
attributes(char1)  # doesn't have explicit "character" class - only implicit
char1 <- structure("a", class="character")
char2 <- structure("b", class="character")
attributes(char1)  # now has explicit "character" class
# add two "character" objects
char1 + char2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Overloading the \texttt{print()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{generic} functions \texttt{print()}, \texttt{plot()} and \texttt{summary()} are very often \emph{overloaded} for newly defined classes,
      \vskip1ex
      Since \texttt{print()} is a \emph{generic} function, \texttt{R} \emph{dispatches} the \emph{method} associated with the \emph{class} of that variable,
      \vskip1ex
      When a variable is called by its name, then \texttt{R} invokes the \texttt{print()} function on that variable,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# define object of class "string"
obj_string <- "how are you today?"
class(obj_string) <- "string"
obj_string
# overload "print" method for string objects
print.string <- function (str_ing) {
  print(
    paste(strsplit(str_ing, split=" ")[[1]],
          collapse=" + "))
}  # end print.string
# methods("print")  # view new methods for "print" function
print(obj_string)
obj_string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operator Overwriting}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Operator \emph{overwriting} refers to redefining an existing function,
      \vskip1ex
      The functions \texttt{.Internal()} and \texttt{.Primitive()} call functions that are part of the internal code of \texttt{R},
      \vskip1ex
      Operator \emph{overwriting} should be used with care, since it may cause unintended consequences,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# overwrite "+" operator
"+" = function(a, b) {
  if (is.character(a) && is.character(b)) {
    paste(a, "plus", b)
  } else {
    .Primitive("+") (a, b)
  }
}
methods("+")  # view methods for "+" operator
# add two "numeric" objects
1 + 2
# add two "character" objects
"a" + "b"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operator Overwriting Using \texttt{UseMethod()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Existing functions can be \emph{overwritten} with \emph{generic} functions using \texttt{UseMethod()},
      \vskip1ex
      Operator \emph{overwriting} should be used with care, since it may cause unintended consequences,
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
# overwrite "+" operator with a generic function
"+" <- function (a, b, ...) {
  UseMethod("+")
}  # end gen_sum
# define method for "numeric" class
"+.numeric" <- function (a, b, ...) {
  sum(a, b)
}  # end gen_sum.character
# define method for "character" class
"+.character" <- function (a, b, ...) {
  paste(a, "plus", b)
}  # end gen_sum.character
methods("+")  # view methods for "+" operator
# add two "numeric" objects
1 + 2
# add two "character" objects
"a" + "b"
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Generic Function Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Most \emph{methods} can be viewed by simply calling their full name, unless they're non-visible,
      \vskip1ex
      Non-visible \emph{methods} can be viewed using the triple-colon operator \texttt{":::"},
      \vskip1ex
      Non-visible \emph{methods} can also be viewed by calling the function \texttt{getAnywhere()},
    \column{0.5\textwidth}
      \vspace{-1em}
        <<>>=
cbind.ts  # can't view non-visible method
stats::cbind.ts  # can't view non-visible method
stats:::cbind.ts  # display non-visible method
getAnywhere(cbind.ts)  # display non-visible method
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{\secname}
\begin{frame}[t]{\subsecname}
\vspace{-1em}
\begin{block}{No homework!}
  \hskip10.0em\includegraphics[scale=0.1]{image/smile.png}
\end{block}

\end{frame}


\end{document}
