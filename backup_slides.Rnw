% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Backup Slides Deleted from Other Files]{Backup Slides Deleted from Other Files}
\subtitle{FRE6871 R in Finance, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@poly.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Backup Slides Deleted from Other Files}


%%%%%%%%%%%%%%%
\subsection{Barplots in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{barplot()} creates bar plots of discrete data, such as frequency distributions,
      \vskip1ex
      The \emph{Poisson} distribution gives the probability of the number of events occurring in intervals of space or time (for example the amount of mail received each day),
      \vskip1ex
        The \emph{Poisson} distribution has one parameter $\lambda$ that determines the average number of events per interval,
      \vskip1ex
      The function \texttt{rpois()} produces random numbers from the Poisson distribution,
      \vskip1ex
      The function \texttt{table()} calculates the frequency distribution of categorical data,
        <<poisbarplot,fig.show='hide'>>=
poisson_var <- rpois(100, 4)  # produce 100 Poisson random numbers
pois_table <- table(poisson_var)  # calculate contingency table
pois_table <- pois_table/sum(pois_table)  # calculate frequency table
pois_table
names(pois_table)  # get names of table

# open Windows graphics device
x11(width=11, height=7, title="function plot")

# create histogram of Poisson variables
library(MASS)
truehist(poisson_var, nbins="FD", col="blue", xlab="No. of events", ylab="Frequency of events", main="Poisson histogram")
# add Poisson density
x_var <- 0:max(poisson_var)
lines(x=x_var, y=dpois(x_var, lambda=4), lwd=4, col="red")
# add legend
legend(x="topright", legend="Poisson density",
       title="", inset=0.05, cex=1.0, bg="white",
       lwd=4, lty=1, col="red")

graphics.off()  # close all graphics devices
      @

    \column{0.5\textwidth}
    \vspace{-2em}
    \includegraphics[width=0.5\paperwidth,valign=t]{figure/poisbarplot}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Poisson Probability Distribution}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Poisson} distribution gives the probability of the number of events in intervals of space or time (for example the amount of mail received each day),
      \vskip1ex
      The Poisson probability function is given by:
      \begin{displaymath}
        P(k; \lambda) = \frac{{\lambda^k}{\cdot}{e^{-\lambda}}}{k!}
      \end{displaymath}
      The parameter $\lambda$ determines the average number of events per interval,
        <<poiss_dist,echo=2:30,fig.show='hide'>>=
rm(list=ls())
poisson_func <- function(x, lambda) 
                    {exp(-lambda)*lambda^x/factorial(x)}
poisson_events <- 0:11  # Poisson events
poisson_dist <- dpois(poisson_events, lambda=4)  # Poisson probabilities
names(poisson_dist) <- as.character(poisson_events)
poisson_dist
x11(width=11, height=7, title="function plot")
barplot(poisson_dist, ylab="Frequency of events", xlab="No. of events", main="Poisson distribution")
curve(expr=poisson_func(x, lambda=4), add=TRUE, xlim=c(0, 11), ylab="", lwd=2, col="red")
legend(x="topright", legend="Poisson density", title="", 
       inset=0.1, cex=1.0, bg="white", lwd=4, lty=1, col="red")
graphics.off()  # close all graphics devices
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/poiss_dist}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames are objects containing tabular data,
      \vskip1ex
      Data frames are 2-D objects (like matrices), but the columns can be of different classes,
      \vskip1ex
      Data frames can also be thought of as lists in which all the elements are vectors of the same length,\\
      Each list element is a column of elements of the same class,
      \vskip1ex
      Data frames share properties of both lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(type,  # create a data frame
                         color, price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
dim(df.florist)  # get dimension attribute
colnames(df.florist)  # get the colnames attribute
rownames(df.florist)  # get the rownames attribute
class(df.florist)  # get object class
class(df.florist$type)  # get column class
class(df.florist$price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30>>=
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(type,  # create a data frame
                         color, price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
df.florist[2, ]  # get second row
df.florist[2, 3]  # get second row and third column
df.florist[[3]]  # get third column
df.florist$color[3]  # get third row from column 'color'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{str()} compactly displays the structure of an \texttt{R} object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an \texttt{R} object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30>>=
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(type,  # create a data frame
                         color, price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
str(df.florist)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data from \texttt{Text} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from text files,
      \vskip1ex
      \texttt{write.table()} coerces objects to data frames before it writes them,
      \vskip1ex
      \texttt{read.table()} returns a data frame, and reads non-numeric values as \texttt{factors} (not \texttt{character}),
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} can be used read and write matrices from text files, but they have to be coerced back to matrices,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=3:30>>=
data_frame <- data.frame(
              type=c('rose', 'daisy', 'tulip'), 
              color=c('red', 'white', 'yellow'), 
              price=c(1.5, 0.5, 1.0), 
              row.names=c('flower1', 'flower2', 'flower3')
              )  # end data_frame
mat_var <- matrix(1:6, nrow=2, ncol=3, dimnames=list(c("row1", "row2"), c("col1", "col2", "col3")))
# write data frame to text file, and then read it back
write.table(data_frame, file='florist.txt')
data_frame <- read.table(file='florist.txt')
data_frame  # a data frame

mat_var  # a matrix
class(mat_var)
# write matrix to text file, and then read it back
write.table(mat_var, file='matrix.txt')
mat_var <- read.table(file='matrix.txt')
mat_var  # write.table() coerced matrix to data frame
class(mat_var)
# coerce from data frame back to matrix
mat_var <- as.matrix(mat_var)
class(mat_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Copying Data Frames Between the \texttt{clipboard} and \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames stored in the \texttt{clipboard} can be copied into \texttt{R} using the function \texttt{read.table()},
      \vskip1ex
      Data frames in \texttt{R} can be copied into the \texttt{clipboard} using the function \texttt{write.table()},
      \vskip1ex
      This allows convenient copying of data frames between \texttt{Excel} and \texttt{R},
      \vskip1ex
      Data frames can also be manipulated directly in the \texttt{R} spreadsheet-style data editor,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=4:30>>=
data_frame <- data.frame(small=c(3, 5), medium=c(9, 11), large=c(15, 13))
setwd("C:/Develop/data")
data_frame <- read.table("mydata.txt", header=TRUE)
data_frame <- read.table("clipboard", header=TRUE)

write.table(x=data_frame, file="clipboard", sep="\t")

# wrapper function for copying data frame from clipboard into R
# by default, data is tab delimited, with a header
read_clip <- function(file="clipboard", sep="\t", 
                      header=TRUE, ...) {
  read.table(file=file, sep=sep, header=header, ...)
}  # end read_clip

data_frame <- read_clip()

# wrapper function for copying data frame from R into clipboard
# by default, data is tab delimited, with a header
write.clip <- function(data, row.names=FALSE, 
                       col.names=TRUE, ...) {
  write.table(x=data, file="clipboard", sep="\t", 
              row.names=row.names, col.names=col.names, ...)
}  # end write.clip

write.clip(data=data_frame)

# launch spreadsheet-style data editor
# data_frame <- edit(data_frame)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Data from \texttt{.CSV} Files}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} are wrappers for \texttt{read.table()} and \texttt{write.table()}, and read and write data frames from \texttt{.CSV} format files,
      \vskip1ex
      The \texttt{*.csv()} functions is very inefficient for large data sets,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=3:30>>=
data_frame <- data.frame(
              type=c('rose', 'daisy', 'tulip'), 
              color=c('red', 'white', 'yellow'), 
              price=c(1.5, 0.5, 1.0), 
              row.names=c('flower1', 'flower2', 'flower3')
              )  # end data_frame
mat_var <- matrix(1:6, nrow=2, ncol=3, dimnames=list(c("row1", "row2"), c("col1", "col2", "col3")))
# write data frame to CSV file, and then read it back
write.csv(data_frame, file='florist.csv')
data_frame <- read.csv(file='florist.csv')
data_frame  # the rownames are read in as extra column
# restore rownames
rownames(data_frame) <- as.character(data_frame[, 1])
data_frame <- data_frame[, -1]  # remove extra column

# write matrix to csv file, and then read it back
write.csv(mat_var, file='matrix.csv')
mat_var <- read.csv(file='matrix.csv')
mat_var  # write.csv() coerced matrix to data frame
class(mat_var)
# restore rownames
rownames(mat_var) <- as.character(mat_var[, 1])
mat_var <- mat_var[, -1]  # remove extra column
# coerce from data frame back to matrix
mat_var <- as.matrix(mat_var)
class(mat_var)
mat_var  # a matrix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} allow reading and writing matrices from CSV format files,
      \vskip1ex
      Using the \texttt{*.csv()} functions is very inefficient for large data sets,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
mat_var <- matrix(1:6, nrow=2, ncol=3, dimnames=list(c("row1", "row2"), c("col1", "col2", "col3")))
mat_var  # a matrix
# introduce bad data element
mat_var["row2", "col2"] <- "."
# write data frame to CSV file, and then read it back
write.csv(mat_var, file='matrix.csv')
mat_var <- read.csv(file='matrix.csv')

# restore rownames
rownames(mat_var) <- as.character(mat_var[, 1])
mat_var <- mat_var[, -1]  # remove extra column
# coerce from data frame back to matrix
mat_var <- as.matrix(mat_var)
class(mat_var)
mat_var  # a matrix

class(mat_var[, "col2"])  # numeric coerced to factor by bad data
mat_var$price <- as.numeric(  # explicitly coerce to numeric
                            as.character(mat_var$price))
mat_var$price[2] <- 0.5  # fix value
mean(mat_var$price)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      There are many other ways of reading and writing matrices from files, with tradeoffs between simplicity, data size, and speed,
      \vskip1ex
      Reading and writing matrices without rownames can be simplified,
      \vskip1ex
      The function \texttt{write.matrix()} is part of library \texttt{MASS},
      \vskip1ex
      The advantage of using the function \texttt{scan()} is its speed, but it doesn't handle rownames,\\
      Although a test with 300x100 matrix showed almost same system.time(),
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
mat_var <- matrix(1:6, nrow=2, ncol=3,  # create a matrix without rownames
                dimnames=list(NULL, c("col1", "col2", "col3")))
mat_var  # matrix without rownames
library('MASS')  # load library 'MASS'
write.matrix(mat_var, file='matrix.csv',  # write to CSV file by row - it's very SLOW!!!
                               sep=',')
system.time(mat_in <- scan(file='matrix.csv',  # skip first line with colnames
                          sep=',', skip=1, what=numeric()))
mat_in  # this is a vector!
mat_in <- matrix(mat_in, nrow=2, byrow=TRUE)  # coerce by row to matrix
#        dim(mat_in) <- c(2, 3)  # coerce by column to matrix!
col_names <- readLines(con='matrix.csv', n=1)  # read colnames
col_names  # this is a string!
col_names <- strsplit(col_names, s=',')[[1]]  # convert to char vector
colnames(mat_in) <- col_names  # restore colnames
mat_in
      @
  \end{columns}
\end{block}

\end{frame}


\end{document}
