% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Functions]{Functions}
\subtitle{FRE6871 R in Finance, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@nyu.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Environments in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{\secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Environments consist of a \emph{frame} (a set of symbol-value pairs) and an \emph{enclosure} (a pointer to an enclosing environment),
      \vskip1ex
      There are three system environments:
      \begin{itemize}
        \item \texttt{globalenv()} the user's workspace,
        \item \texttt{baseenv()} the environment of the base package,
        \item \texttt{emptyenv()} the only environment without an enclosure,
      \end{itemize}
      Environments form a tree structure of successive enclosures, with the empty environment at its root,
      \vskip1ex
      Packages have their own environments,
      \vskip1ex
      The enclosure of the base package is the empty environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
baseenv()  # get base environment
globalenv()  # get global environment
environment()  # get current environment
class(environment())  # get environment class
glob_var <- 1  # define variable in current environment
ls(environment())  # get objects in current environment

env.new <- new.env()  # create new environment
parent.env(env.new)  # get calling environment of new environment
assign("new_var1", 3, envir=env.new)  # assign Value to Name
env.new$new_var2 <- 11  # create object in new environment
ls(env.new)  # get objects in new environment
ls(environment())  # get objects in current environment
env.new$new_var1  # environments are subset like lists
env.new[['new_var1']]  # environments are subset like lists
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{R} Search Path}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} evaluates variables using the search path, a series of environments:
      \begin{itemize}
        \item global environment,
        \item package environments,
        \item base environment,
      \end{itemize}
      The function \texttt{search()} returns the search path for dereferencing \texttt{R} objects,
      \vskip1ex
      The function \texttt{attach()} attaches objects to the search path,
      \vskip1ex
      This allows referencing variables by their names alone, rather than as components of objects,
      \vskip1ex
      The function \texttt{detach()} detaches objects from the search path,
      \begin{block}{\color{red}{Rule of Thumb}}
        Be very careful with using \texttt{attach()},
        \vskip1ex
        Make sure to \texttt{detach()} objects once they're not needed,
      \end{block}

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
search()  # get search path for R objects
loadedNamespaces()
my_list <- list('flowers'=c('rose', 'daisy', 'tulip'),  # create a list
                        'trees'=c('pine', 'oak', 'maple'))
my_list$trees
attach(my_list)
trees
search()  # get search path for R objects
detach(my_list)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions have three components: 
      \begin{itemize}
        \item a list of formal arguments,
        \item a body containing \texttt{R} code,
        \item an environment,
      \end{itemize}
      An \texttt{R} function plus its environment is referred to as a function closure,
      \vskip1ex
      Formal arguments can be matched to actual arguments by position or by name,
      \vskip1ex
      Formal arguments can have default values so that when actual arguments are missing then their default values are used,
      \vskip1ex
      The function body doesn't require a return statement, since by default \texttt{R} functions return the last evaluated statement,

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
explore_func <- function(arg_var1=2, arg_var2=1) {  # define function explore_func
# default values can be specified in the argument list
  arg_var1 + 2*arg_var2
# the function returns the last evaluated statement
}  # end explore_func
explore_func(arg_var1=3, arg_var2=2)  # match arguments by name
explore_func(3, 2)  # match arguments by position
explore_func()  # use default values of arguments
# define function that uses enclosure environment
explore_func <- function(arg_var1=2, arg_var2=1) {
# default values can be specified in the argument list
  arg_var1 + 2*arg_var2 + glob_var
# the function returns the last evaluated statement
}  # end explore_func
explore_func(3, 2)  # glob_var doesn't exist yet!
glob_var <- 10
explore_func(3, 2)  # now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive Function for Calculating Fibonacci Sequence}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Recursive} functions call themselves in their own body, 
      \vskip1ex
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 1, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
fibo_nacci <- function(seq_length) {
  if (seq_length > 2) {
    fib.seq <- fibo_nacci(seq_length-1)  # recursion
    c(fib.seq, sum(tail(fib.seq, 2)))  # return this
  } else {
    c(1, 1)  # initialize and return
  }
}  # end fibo_nacci
fibo_nacci(10)
tail(fibo_nacci(10), 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function for Calculating Moments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} provides an easy way for users to write functions,
      \vskip1ex
      Function arguments can be matched by position or by name,
      \vskip1ex
      If the function arguments are missing then the default value is used,
      \vskip1ex
      Functions return the value of the last expression that is evaluated,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
rets_series <- diff(log(EuStockMarkets[, 1]))  # DAX returns

# define function calc_skew to calculate the skew
calc_skew <- function(time_series=rnorm(1000)) {  # default is normal
# Calculates the skew of a time series of returns.
  length_series <- length(time_series)  # number of observations
  mean_series <- mean(time_series)
  sd_series <- sd(time_series)
# the last statement is what is returned
  length_series*sum(((time_series - mean_series)/sd_series)^3)/
  ((length_series-1)*(length_series-2))
}  # end calc_skew

# calculate skewness of DAX returns
calc_skew(time_series=rets_series)  # match arguments by name
calc_skew(rets_series)  # match arguments by position
calc_skew()  # use default value of arguments
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      If a function name is called alone then \texttt{R} displays the function code (but it must be on the search path),
      \vskip1ex
      The function \texttt{getAnywhere()} displays \texttt{R} objects, including functions,
      \vskip1ex
      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
calc_skew  # show the function code

getAnywhere(calc_skew)  # display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Argument Lazy Evaluation}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions delay evaluation of their arguments until they're needed by their \texttt{R} code,
      \vskip1ex
      This is called \emph{lazy} evaluation,
      \vskip1ex
      If the function body doesn't evaluate an argument, then the function won't throw an error, even if the argument is missing,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
lazy_func <- function(arg_var1, arg_var2) {  # define function lazy_func
  2*arg_var1  # just multiply first argument
}  # end lazy_func
lazy_func(3, 2)  # match arguments by position
lazy_func(3)  # second argument was never evaluated!
lazy_func <- function(arg_var1, arg_var2) {  # define function lazy_func
  cat(arg_var1, '\n')  # write to output
  cat(arg_var2)  # write to output
}  # end lazy_func
lazy_func(3, 2)  # match arguments by position
lazy_func(3)  # first argument written to output
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The '...' Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The '...' argument represents additional unknown arguments, that may be passed on to another nested function,
      \vskip1ex
      The '...' argument is also used when the number of arguments isn't known in advance,
      \vskip1ex
      Any arguments that appear after '...' in the argument list cannot be partially matched,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
match_dots <- function(arg_var1=2, arg_var2=1, ...) {  # define function match_dots
# default values can be specified in the argument list
  arg_var1 + 2*arg_var2 + sum(...)
# the function returns the last evaluated statement
}  # end match_dots
match_dots(3, 2)  # match arguments by position
match_dots(3, 2, 5, 8)  # extra arguments
match_dots()  # use default value of arguments
str(paste)  # function 'paste' can take many arguments
paste('a', 'b', sep = ':')  # match arguments by name
paste('a', 'b', se = ':')  # partial name matching fails!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive\hskip0.5em\secname\hskip0.5em with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Recursive} functions can also accept the '\texttt{...}' argument, 
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
sum_dots <- function(arg_var, ...) {  # define recursive function
# returns the sum of its argument list
  if (length(list(...)) == 0) {
    return(arg_var)  # just one argument left
  } else {
    arg_var + sum_dots(...)  # sum remaining arguments
  }
}  # end sum_dots
sum_dots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When a function is called, a new \emph{evaluation} environment is created,
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables,
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined (the global environment for functions defined in the workspace),
      \vskip1ex
      Functions defined in packages with namespaces have the package namespace as their enclosure,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
ls(environment())  # get all variables in environment
func_env <- function() {  # explore function environments
  loc_var <- 1  # define a local variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t', 
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lexical Function Scope}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{free} variable is a variable that's not included in the \emph{evaluation} environment,
      \vskip1ex
      Scoping rules determine how \emph{free} variables are evaluated,
      \vskip1ex
      By default \texttt{R} uses \emph{lexical} (\emph{static}) scoping, which means that variables are first evaluated in the \emph{evaluation} environment, then in the \emph{enclosing} environment in which the function was \emph{defined}, and so on,
      \vskip1ex
      \emph{Dynamic} scoping means that variables are evaluated in the environment from which the function was \emph{called},
      \vskip1ex
      The standard assignment operator "\texttt{<-}" modifies variables in the \emph{evaluation} environment,
      \vskip1ex
      The special assignment operator "\texttt{<<-}" modifies variables in the \emph{enclosing} environment,

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
probe_scope <- function() {  # explore function scope
  loc_var <- 2*glob_var  # define a local variable
  new_globvar <<- 11  # define a global variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('this is a local loc_var:\t', loc_var, '\n')
  cat('objects in enclosing environment:\n', 
      ls(parent.env(environment())), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local glob_var
  cat('this is the local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # global variable is unaffected
new_globvar  # new_globvar is preserved
loc_var  # local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Super-assignment Operator "\texttt{<<-}"}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The super-assignment operator "\texttt{<<-}" modifies or creates variables in the \emph{enclosing} environment in which the function was \emph{defined} (\emph{lexical} scoping),
      \vskip1ex
      If the function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment and the "\texttt{<<-}" operator operates on variables in the \emph{global} environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
probe_scope <- function() {  # explore function scope
  cat('this is the global glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local 'glob_var' variable
  glob_var <<- 2  # re-define the global variable
  cat('this is a local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # the global variable
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em as First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Functions in \texttt{R} are \emph{first class objects}, which means they can be treated like any other \texttt{R} object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher-order} functions are \texttt{R} functions that either take a function as input or return a function as output,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# create functional that accepts a function as input argument
func_tional <- function(func_arg) {
# calculates statistic on random numbers
  set.seed(1)
  func_arg(runif(1e4))  # apply the function name
}  # end func_tional
func_tional(mean)
func_tional(sd)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Functionals} are functions that accept a function as its input argument,
      \vskip1ex
      The '\texttt{...}' argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
func_tional <- function(func_arg, ...) {
# functional accepts function and additional '...' arguments
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()}\hskip0.5em\secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functions,
      \vskip1ex
      The function \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix,
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns},
      \vskip1ex
      The function \texttt{apply()} can replace '\texttt{for}' loops,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
str(apply)  # get list of arguments
mat_rix <- matrix(6:1, nrow=2, ncol=3)  # create a matrix
mat_rix
# sum the rows and columns
row_sums <- apply(mat_rix, 1, sum)
col_sums <- apply(mat_rix, 2, sum)
mat_rix <- cbind(c(sum(row_sums), row_sums), 
                  rbind(col_sums, mat_rix))
dimnames(mat_rix) <- list(c("col_sums", "row1", "row2"), 
                           c("row_sums", "col1", "col2", "col3"))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
      <<>>=
str(apply)  # get list of arguments
mat_rix <- matrix(sample(12), nrow=3, ncol=4)  # create a matrix
mat_rix
apply(mat_rix, 2, sort)  # sort matrix columns
apply(mat_rix, 2, sort, decreasing=TRUE)  # sort decreasing order
      @
    \column{0.5\textwidth}
        <<>>=
mat_rix[2, 2] <- NA  # introduce NA value
mat_rix
# calculate median of columns
apply(mat_rix, 2, median)
# calculate median of columns with na.rm=TRUE
apply(mat_rix, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} allows defining functions without assigning a name to them,
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name,
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
# simple anonymous function
(function(x) (x + 3)) (10)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Anonymous} functions are most often passed as arguments to \emph{functionals},
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments,
    \column{0.7\textwidth}
      \vspace{-2em}
        <<>>=
# functional accepts function and additional '...' arguments
func_tional <- function(func_arg, ...) {
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(sum, 2, 3, 4)
func_tional(mean, 1:10)
func_tional((func_arg=function(x) (x + 3)), 5)
# anonymous function can be a default value
func_tional <- function(..., 
                        func_arg=function(x, y, z) {x+y+z}) {
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(2, 3, 4)  # use default func_arg
func_tional(func_arg=sum, 2, 3, 4)  # func_arg matched by name
func_tional(func_arg=sum, 2, 3, 4, 5)
func_tional(2, 3, 4, 5)
# pass anonymous function to func_arg
func_tional(func_arg=function(x, y, z) {x*y*z}, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{apply()} function combined with \emph{anonymous} functions can be used to loop over function parameters,
      \vskip1ex
  The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
rets_series <- 100*diff(log(EuStockMarkets[, 1]))  # DAX percent returns
library("moments")  # load library"moments"
str(moment)  # get list of arguments

moment(x=rets_series, order=3)  # apply moment function

moment_orders <- as.matrix(1:4)  # 4x1 matrix of moment orders

# anonymous function allows looping over function parameters
apply(X=moment_orders, MARGIN=1, 
      FUN=function(moment_order) {
          moment(x=rets_series, order=moment_order)
        }  # end anonymous function
      )  # end apply

# another way of passing parameters into moment() function
apply(X=moment_orders, MARGIN=1, FUN=moment, x=rets_series)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{sapply()} function is a specialized version of the \texttt{apply()} function,
      \vskip1ex
      \texttt{sapply()} applies a function to a list or a vector of objects and returns a vector,
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interprets it as a list, and applies the function to each element (column) of the data frame,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sapply(6:10, sqrt)  # sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # sapply on list

# calculate means of iris data frame columns
sapply(iris, mean)  # returns NA for Species

# create a matrix
mat_rix <- matrix(sample(100), ncol=4)
# calculate column means using apply
apply(mat_rix, 2, mean)

# calculate column means using sapply, with anonymous function
sapply(1:ncol(mat_rix), 
       function(col_index) {  # anonymous function
         mean(mat_rix[, col_index])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{lapply()} function is a specialized version of the \texttt{apply()} function,
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list,
      \vskip1ex
      The function \texttt{unlist()} converts a list into a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sapply(iris[, -5], mean)  # vector of means of numeric columns
lapply(iris[, -5], mean)  # calculate means of numeric columns
# calculate means of numeric columns using anonymous function
unlist(lapply(iris, 
              function(col_umn) {
                if (is.numeric(col_umn)) mean(col_umn)
              }  # end anonymous function
              )  # end sapply
       )  # end unlist
unlist(sapply(iris, function(col_umn) {if (is.numeric(col_umn)) mean(col_umn)}))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em That Return \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions can also return a function as their value,
      \vskip1ex
      Functions returned by a function are called \emph{closures},
      \vskip1ex
      Functions that return closures can be used as \emph{function factories},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a power function factory
make_func <- function(arg_param) {  # wrapper function
  function(arg_var) {  # anonymous closure
    arg_var^arg_param
  }
}  # end make_func

square_func <- make_func(2)  # define square function
square_func(4)
cube_func <- make_func(3)  # define cube function
cube_func(2)
cube_root_func <- make_func(1/3)  # define cube root function
cube_root_func(8)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{mutable state} is an object that is preserved between function calls,
      \vskip1ex
      Functions that return closures can also be used for creating \emph{mutable states},
      \vskip1ex
      A function \emph{evaluation} environment is only temporary and disappears after the function returns its value,
      \vskip1ex
      But a \emph{closure} assigned to a name maintains access to the environment in which it was created,
      \vskip1ex
      Therefore the \emph{closure} maintains access to its parent function's arguments and locally defined variables,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
make_counter <- function() {
# counter function with mutable state
  counter <- 0  # initialize counter
  cat('counter = ', counter)
  function() {  # return anonymous advance function
    counter <<- counter + 1  # advance counter
    cat('counter = ', counter)
  }  # end advance function
}  # end make_counter

advance_counter <- make_counter()  # create new counter
advance_counter()  # advance counter
advance_counter()  # advance counter
advance_counter_two <- make_counter()  # create another counter
advance_counter_two()  # advance counter two
advance_counter()  # advance counter one
advance_counter_two()  # advance counter two
advance_counter()  # advance counter one
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Generating Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \emph{Mutable states} can be used to implement pseudo-random number generators,
        <<>>=
# Returns the pseudo-random generating function random_generator
# the formal argument 'seed' persists in the evaluation environment of seed_random
seed_random <- function(seed) {  # seed must be an integer
  random_number <- as.numeric(paste0('0.', seed))  # initialize
# random_generator returns a vector of pseudo-random numbers of length length_rand
  random_generator <- function(length_rand=1) {  # assign function name for recursion
# Returns a vector of pseudo-random numbers of length length_rand
    random_number <<- 4*random_number*(1 - random_number)  # logistic map
    if (length_rand==1) {
      return(random_number)
    } else {
      return(c(random_number, random_generator(length_rand - 1)))
    }  # end if
  }  # end random_generator
}  # end seed_random

# create a random number generating function and set seed
make_random <- seed_random(88)
make_random(10)  #  calculate vector of 10 pseudo-random numbers
ls(environment(make_random))  # list objects in scope of make_random
      @
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bank Account Using Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-2em}
  \begin{columns}[T]
    \column{0.5\textwidth}
        <<echo=4:30>>=
rm(list=ls())
# the super-assignment operator '<<-' adjusts the balance
# 'balance' exists in open_account evaluation environment
# bank account example (from Venables) demonstrates mutable states
# 'balance' is persistent between function calls
open_account <- function(balance) {
# returns function list for account operations
  list(
    deposit = function(amount) {  # make deposit
      if(amount > 0) {
        balance <<- balance + amount  # '<<-' super-assignment operator
        cat(amount, "deposited. Your balance is now:", 
            balance, "\n")
      } else {
        cat("Deposits must be positive!\n")
      }
    },  # end deposit
    withdraw = function(amount) {  # make withdrawal
      if(amount <= balance) {
        balance <<- balance - amount  # '<<-' super-assignment operator
        cat(amount, "withdrawn. Your balance is now:", 
            balance, "\n")
      } else {
        cat("You don't have that much money!\n")
      }
    },  # end withdraw
    get_balance = function() {  # get balance
      cat("Your current balance is:", balance, "\n")
    }  # end get_balance
  )  # end list
}  # end open_account
@
    \column{0.5\textwidth}
        <<>>=
# perform account operations
# open an account with 100 deposit
my_account <- open_account(100)
ls(my_account)  # my_account is a list
# add my_account to search path
attach(my_account)
withdraw(30)  # withdrawal to buy groceries
deposit(100)  # deposit paycheck to account
withdraw(200)  # withdrawal to buy Gucci bag
get_balance()  # get account balance

# list objects in scope of get_balance
ls(environment(get_balance))

detach(my_account)  # remove my_account from search path
@
  \end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Infix Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Most functions in \texttt{R} are \emph{prefix} operators (where the function name is followed by an argument list),
      \vskip1ex
      \emph{Infix} operators (where the the function name comes in between its arguments) can also be applied using \emph{prefix} syntax,
      \vskip1ex
      \texttt{R} also allows defining new \emph{infix} functions,
      \vskip1ex
      All user defined \emph{infix} function names must start and end with a "\texttt{\%}" character,
      \vskip1ex
      The new \emph{infix} function name must be used in quotes,
      \vskip1ex

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
'+' (2, 3)  # infix operator applied using prefix syntax

glob_var <- 1  # define a global variable
probe_scope <- function() {  # exploring scope
  loc_var <- 1  # define a local variable
  new_globvar <<- 11  # define a global variable
  cat('objects in parent environment:\t', 
      ls(parent.env(environment())), '\n')
  cat('objects in function environment:\t', 
      ls(environment()), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # re-define the global variable
  cat('this is re-defined glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # global variable is restored
new_globvar  # new_globvar is preserved
loc_var  # local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Object-Oriented Programming in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{The \texttt{S3} Object-Oriented Programming System in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{S3} is the standard object oriented (OO) programming system in \texttt{R},
      \vskip1ex
      The \texttt{S3} system is based on the \texttt{R} \emph{class} system and on \emph{generic} functions,
      \vskip1ex
      \emph{Generic} functions have different \emph{methods} that are dispatched depending on the \emph{class} of the object,
      \vskip1ex
      The actual function that is executed (called a \emph{method}) is determined by the class of the object on which the \emph{generic} function is called,
      \vskip1ex
      For example \texttt{plot()} and \texttt{cbind()} are \emph{generic} functions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
library(zoo)  # load package zoo
# get all methods for generic function "cbind"
methods("cbind")

# show the method of "cbind" applied to "zoo" objects
cbind.zoo
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generic Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Generic} functions follow the naming convention \texttt{function.classname()},
      \vskip1ex
      The \emph{generic} function \texttt{cbind()} has many \emph{methods} with names \texttt{cbind.*()},
      \vskip1ex
      The \texttt{cbind()} method dispatched to \texttt{zoo} objects is called \texttt{cbind.zoo()},
      \vskip1ex
      The function \texttt{methods()} lists all methods for a generic function, or all methods for a class,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
library(zoo)  # load package zoo
# get all methods for generic function "cbind"
# get generic function methods applied to "zoo" objects
methods(class="zoo")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Generic Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Generic functions} are defined using the function \texttt{UseMethod()}
      \vskip1ex
      the user can access symbols from a package that isn't attached using the double-colon operator \texttt{tools::file\_ext}

    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
cbind.ts  # can't view code of non-visible functions
getAnywhere(cbind.ts)  # display function
stats:::cbind.ts  # display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Internal and Primitive Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      R .Internal .Primitive
      \vskip1ex
      several functions call compiled code: .C(), .Call(), .Fortran(), .External(), or .Internal() and .Primitive()
      \vskip1ex
      The function \texttt{getAnywhere()} displays \texttt{R} objects, including functions,
      \vskip1ex
      If a function name is called alone then \texttt{R} displays the function code (but it must be on the search path),
      \vskip1ex
      the user can access symbols from a package that isn't attached using the double-colon operator \texttt{tools::file\_ext}

      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# get all methods for generic function "plot"
methods("plot")

getAnywhere(plot)  # display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Creating New Classes and Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A new \texttt{R} class can be created by simply assigning to the \texttt{class} attribute of an object,
      \vskip1ex
      Then new \emph{methods} can be defined, and \texttt{R} will automatically dispatch them to objects of the new \emph{class},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
my_zoo <- zoo(rnorm(4), order.by=(Sys.Date() + 0:3))
class(my_zoo)
length(my_zoo)

# coerce "zoo" object to new class "newts"
class(my_zoo) <- "newts"
class(my_zoo)

# define "length" method for class "newts"
length.newts <- function(in_ts) {
# "length" method for class" "newts"
  cat("length of object from newts class\n")
  length(unclass(in_ts))
}  # end length.newts

# apply new "length" method
length(my_zoo)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}
    \item Create a function for calculating the kurtosis of a time series of returns,
    \item Using this function calculate the kurtosis of DAX returns, and of t-distribution returns with four degrees of freedom (use the same number of data points in both cases),
    \item Plot the probability density of DAX returns together with t-distribution returns with four degrees of freedom on a single plot,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}
    \item Read chapters 4, 5, 10: \fullcite{website:rintro}
  \end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Additional Reading}
\begin{frame}[t]{\subsecname}

Download \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network)\\
\hskip1em\url{http://cran.r-project.org/}\\
\vskip4ex
Download \texttt{RStudio} IDE (Integrated Development Environment)\\
\hskip1em\url{http://www.rstudio.com/ide}\\
\vskip4ex

\end{frame}


\end{document}
