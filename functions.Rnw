% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6871_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Functions]{Functions}
\subtitle{FRE6871 R in Finance, Fall 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \texorpdfstring{(\textit{\color{blue}{\footnotesize{jp3900@nyu.edu}}})}{}}
% \email{jp3900@nyu.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle



%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.4emin \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions have three components: 
      \begin{itemize}
        \item a list of formal arguments,
        \item a body containing \texttt{R} code,
        \item an environment,
      \end{itemize}
      An \texttt{R} function plus its environment is referred to as a function closure,
      \vskip1ex
      The function body must be enclosed in curly braces \texttt{\{\}},
      \vskip1ex
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body,
      \vskip1ex
      \texttt{args()} displays the formal arguments of a function,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a function with two arguments
test_func <- function(first_arg, second_arg) {  # body
  first_arg + second_arg  # returns last evaluated statement
}  # end test_func

test_func(1, 2)  # apply the function
args(test_func)  # display argument

# define function that uses variable from enclosure environment
test_func <- function(first_arg, second_arg) {
  first_arg + second_arg + glob_var
}  # end test_func

test_func(3, 2)  # error - glob_var doesn't exist yet!
glob_var <- 10  # create glob_var
test_func(3, 2)  # now works
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The formal arguments of a function are defined in its argument list,
      \vskip1ex
      When a function is called, it's passed a list of actual function arguments,
      \vskip1ex
      Formal arguments can be \texttt{bound} to actual arguments either by name or by position:
      \begin{itemize}
        \item by name: formal arguments are \texttt{bound} to actual arguments with the same name,
        \item by position: the first formal argument is \texttt{bound} to the first actual argument, etc.
      \end{itemize}
      \texttt{Binding} by name takes precedence over \texttt{binding} by position: first all the named arguments are \texttt{bound}, then the remaining arguments are \texttt{bound} by position,
      \vskip1ex
      Partial argument names are matched to full names,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
test_func <- function(first_arg=2, second_arg=1) {
# default values can be specified in the argument list
  first_arg + 2*second_arg
}  # end test_func

test_func(first_arg=3, second_arg=2)  # bind by name
test_func(first=3, second=2)  # partial name matching
test_func(3, 2)  # bind by position
test_func(second_arg=2, 3)  # mixed binding
test_func()  # use default values of arguments
test_func(3, 2, 1)  # too many arguments
      @
      All the actual arguments must be \texttt{bound} to formal arguments, and if not then an error \texttt{"unused argument"} is produced,
      \vskip1ex
      Formal arguments may be assigned default values so that when actual arguments are missing then their default values are used instead,
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Return Values of \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function body doesn't require a \texttt{return} statement, since by default \texttt{R} functions return the last statement evaluated in the body,
      \vskip1ex
      \texttt{return()} statements are inserted in logical branches to terminate function execution and return its intended value,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a function that returns invisibly
test_func <- function(arg_var) {
  if (!is.numeric(arg_var)) {
    warning(paste("argument", arg_var, "isn't numeric"))
    return(NULL)
  }
  2*arg_var
}  # end test_func

test_func(2)
test_func("hello")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.4emThat Return \texttt{invisible}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      If a return value is wrapped in the function \texttt{invisible()} then the return value isn't printed,
      \vskip1ex
      But if the function is assigned to a variable, then its return value is assigned to that variable,
      \vskip1ex
      \texttt{invisible()} allows creating functions whose return values can be assigned, but which do not print when they're not assigned,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a function that returns invisibly
return_invisible <- function(arg_var) {
  invisible(arg_var)
}  # end return_invisible

return_invisible(2)

glob_var <- return_invisible(2)
glob_var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing Function Calls Using \texttt{do.call()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Quite often we need to pass a list of arguments into a function that accepts multiple arguments,
      \vskip1ex
      The function \texttt{do.call()} executes a function call on a list of arguments,
      \vskip1ex
      \texttt{do.call()} passes the list elements one by one, instead of passing the whole list as one argument,
      \vskip1ex
      \texttt{do.call()} is often used to convert lists of vectors to matrices,
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
str(sum)  # "sum" accepts multiple arguments
# passing a list of arguments to "sum" produces an error
sum(list(1, 2, 3, 4))
# do.call passes the list elements into "sum" one by one
do.call(sum, list(1, 2, 3, 4))

num_list <- list(1, 2, 3, 4)  # create numeric list
do.call(rbind, num_list)  # returns single column matrix
do.call(cbind, num_list)  # returns single row matrix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive Function for Calculating Fibonacci Sequence}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Recursive} functions call themselves in their own body, 
      \vskip1ex
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 1, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
fibo_nacci <- function(seq_length) {
  if (seq_length > 2) {
    fib.seq <- fibo_nacci(seq_length-1)  # recursion
    c(fib.seq, sum(tail(fib.seq, 2)))  # return this
  } else {
    c(1, 1)  # initialize and return
  }
}  # end fibo_nacci
fibo_nacci(10)
tail(fibo_nacci(10), 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function for Calculating Skew}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} provides an easy way for users to write functions,
      \vskip1ex
      Function arguments can be bound by position or by name,
      \vskip1ex
      If the function arguments are missing then the default value is used,
      \vskip1ex
      Functions return the value of the last expression that is evaluated,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
rets_series <- diff(log(EuStockMarkets[, 1]))  # DAX returns

# define function calc_skew for calculating the skew
calc_skew <- function(time_series=rnorm(1000)) {  # default is normal
# Calculates the skew of a time series of returns.
  len_data <- length(time_series)  # number of observations
# normalize time_series
  time_series <- (time_series - mean(time_series))/sd(time_series)
# calculate skew - last statement is automatically returned
  len_data*sum(time_series^3)/((len_data-1)*(len_data-2))
}  # end calc_skew

# calculate skewn of DAX returns
calc_skew(time_series=rets_series)  # bind arguments by name
calc_skew(rets_series)  # bind arguments by position
calc_skew()  # use default value of arguments
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      If a function name is called alone then \texttt{R} displays the function code (but it must be on the search path),
      \vskip1ex
      The function \texttt{getAnywhere()} displays \texttt{R} objects, including functions,
      \vskip1ex
      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
calc_skew  # show the function code

getAnywhere(calc_skew)  # display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lazy Evaluation of Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions delay evaluation of their arguments until they're needed by their \texttt{R} code,
      \vskip1ex
      This is called \emph{lazy} evaluation,
      \vskip1ex
      If the function body doesn't evaluate an argument, then the function won't throw an error, even if the argument is missing,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
lazy_func <- function(arg1, arg2) {  # define function lazy_func
  2*arg1  # just multiply first argument
}  # end lazy_func
lazy_func(3, 2)  # bind arguments by position
lazy_func(3)  # second argument was never evaluated!
lazy_func <- function(arg1, arg2) {  # define function lazy_func
  cat(arg1, '\n')  # write to output
  cat(arg2)  # write to output
}  # end lazy_func
lazy_func(3, 2)  # bind arguments by position
lazy_func(3)  # first argument written to output
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The '...' Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The '...' argument represents additional unknown arguments, that may be passed on to another nested function,
      \vskip1ex
      The '...' argument is also used when the number of arguments isn't known in advance,
      \vskip1ex
      Any arguments that appear after '...' in the argument list cannot be partially bound,
      \vskip1ex
      It's better practice to bind by name after the '...' in argument,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
match_dots <- function(arg1=2, arg2=1, ...) {  # define function match_dots
# default values can be specified in the argument list
  arg1 + 2*arg2 + sum(...)
# the function returns the last evaluated statement
}  # end match_dots
match_dots(3, 2)  # match arguments by position
match_dots(3, 2, 5, 8)  # extra arguments
match_dots()  # use default value of arguments
str(paste)  # function 'paste' can take many arguments
paste('a', 'b', sep = ':')  # bind arguments by name
paste('a', 'b', se = ':')  # partial name matching fails!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive \secname\hskip0.4emwith '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Recursive} functions can also accept the '\texttt{...}' argument, 
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sum_dots <- function(arg_var, ...) {  # define recursive function
# returns the sum of its argument list
  if (missing(...)) {  # check if dots are empty
    return(arg_var)  # just one argument left
  } else {
    arg_var + sum_dots(...)  # sum remaining arguments
  }  # end if
}  # end sum_dots
sum_dots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function Environments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When a function is called, a new \emph{evaluation} environment is created,
      \vskip1ex
      The \emph{evaluation} environment contains the function arguments and locally defined variables,
      \vskip1ex
      The enclosure of the \emph{evaluation} environment is the environment where the function was defined (the global environment for functions defined in the workspace),
      \vskip1ex
      Functions defined in packages with namespaces have the package namespace as their enclosure,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
ls(environment())  # get all variables in environment
func_env <- function() {  # explore function environments
  loc_var <- 1  # define a local variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('objects in enclosing environment:\t', 
      ls(parent.env(environment())), '\n')
  cat('this is the enclosing environment:')
  parent.env(environment())  # return enclosing environment
}  # end func_env
func_env()

environment(func_env)
environment(print)  # package namespace is the enclosure
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lexical Function Scope}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{free} variable is a variable that's not included in the \emph{evaluation} environment,
      \vskip1ex
      Scoping rules determine how \emph{free} variables are evaluated,
      \vskip1ex
      By default \texttt{R} uses \emph{lexical} (\emph{static}) scoping, which means that variables are first evaluated in the \emph{evaluation} environment, then in the \emph{enclosing} environment in which the function was \emph{defined}, and so on,
      \vskip1ex
      \emph{Dynamic} scoping means that variables are evaluated in the environment from which the function was \emph{called},
      \vskip1ex
      The standard assignment operator "\texttt{<-}" modifies variables in the \emph{evaluation} environment,
      \vskip1ex
      The special assignment operator "\texttt{<<-}" modifies variables in the \emph{enclosing} environment,

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
probe_scope <- function() {  # explore function scope
  loc_var <- 2*glob_var  # define a local variable
  new_globvar <<- 11  # define a global variable
  cat('objects in evaluation environment:\t', 
      ls(environment()), '\n')
  cat('this is a local loc_var:\t', loc_var, '\n')
  cat('objects in enclosing environment:\n', 
      ls(parent.env(environment())), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local glob_var
  cat('this is the local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # global variable is unaffected
new_globvar  # new_globvar is preserved
loc_var  # local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The Super-assignment Operator "\texttt{<<-}"}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The super-assignment operator "\texttt{<<-}" modifies or creates variables in the \emph{enclosing} environment in which the function was \emph{defined} (\emph{lexical} scoping),
      \vskip1ex
      If the function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment and the "\texttt{<<-}" operator operates on variables in the \emph{global} environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
glob_var <- 1  # define a global variable
probe_scope <- function() {  # explore function scope
  cat('this is the global glob_var:\t', glob_var, '\n')
  glob_var <- 10  # define local 'glob_var' variable
  glob_var <<- 2  # re-define the global variable
  cat('this is a local glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # the global variable
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.4emas First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Functions in \texttt{R} are \emph{first class objects}, which means they can be treated like any other \texttt{R} object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher-order} functions are \texttt{R} functions that either take a function as input or return a function as output,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# create functional that accepts a function as input argument
func_tional <- function(func_arg) {
# calculates statistic on random numbers
  set.seed(1)
  func_arg(runif(1e4))  # apply the function name
}  # end func_tional
func_tional(mean)
func_tional(sd)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Functionals} are functions that accept a function as its input argument,
      \vskip1ex
      The function \texttt{match.fun()} produces a function specified by its name,
      \vskip1ex
      \texttt{match.fun()} produces an error condition if it fails to find a function with the specified name,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
func_tional <- function(func_arg, arg_var) {
# functional accepts function name and one additional argument
  func_arg <- match.fun(func_arg)  # produce function from name
  func_arg(arg_var)  # apply input function
}  # end func_tional

func_tional(sqrt, 4)

# if argument is a list, then we need to call "do.call", to pass them one by one
# Passing a function as a list: first element is function name, remaining elements are arguments
func_tional <- function(list_arg) {
  func_arg <- match.fun(list_arg[[1]])  # produce function from name
  do.call(func_arg, list(as.numeric(list_arg[-1])))
}  # end func_tional

arg_list <- list("mean", 1, 2, 3, 4)
func_tional(arg_list)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The '\texttt{...}' argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
func_tional <- function(func_arg, ...) {
# functional accepts function and additional '...' arguments
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional

func_tional(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functions,
      \vskip1ex
      The function \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix,
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns},
      \vskip1ex
      The function \texttt{apply()} can replace '\texttt{for}' loops,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
str(apply)  # get list of arguments
mat_rix <- matrix(6:1, nrow=2, ncol=3)  # create a matrix
mat_rix
# sum the rows and columns
row_sums <- apply(mat_rix, 1, sum)
col_sums <- apply(mat_rix, 2, sum)
mat_rix <- cbind(c(sum(row_sums), row_sums), 
                  rbind(col_sums, mat_rix))
dimnames(mat_rix) <- list(c("col_sums", "row1", "row2"), 
                           c("row_sums", "col1", "col2", "col3"))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
      <<>>=
str(apply)  # get list of arguments
mat_rix <- matrix(sample(12), nrow=3, ncol=4)  # create a matrix
mat_rix
apply(mat_rix, 2, sort)  # sort matrix columns
apply(mat_rix, 2, sort, decreasing=TRUE)  # sort decreasing order
      @
    \column{0.5\textwidth}
        <<>>=
mat_rix[2, 2] <- NA  # introduce NA value
mat_rix
# calculate median of columns
apply(mat_rix, 2, median)
# calculate median of columns with na.rm=TRUE
apply(mat_rix, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{R} allows defining functions without assigning a name to them,
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name,
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
# simple anonymous function
(function(x) (x + 3)) (10)

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Anonymous} functions are most often passed as arguments to \emph{functionals},
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments,
    \column{0.7\textwidth}
      \vspace{-2em}
        <<>>=
# functional accepts function and additional '...' arguments
func_tional <- function(func_arg, ...) {
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(sum, 2, 3, 4)
func_tional(mean, 1:10)
func_tional((func_arg=function(x) (x + 3)), 5)
# anonymous function can be a default value
func_tional <- function(..., 
                        func_arg=function(x, y, z) {x+y+z}) {
  func_arg(...)  # apply input function to '...' arguments
}  # end func_tional
func_tional(2, 3, 4)  # use default func_arg
func_tional(func_arg=sum, 2, 3, 4)  # func_arg bound by name
func_tional(func_arg=sum, 2, 3, 4, 5)
func_tional(2, 3, 4, 5)
# pass anonymous function to func_arg
func_tional(func_arg=function(x, y, z) {x*y*z}, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{apply()} function combined with \emph{anonymous} functions can be used to loop over function parameters,
      \vskip1ex
  The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
rets_series <- 100*diff(log(EuStockMarkets[, 1]))  # DAX percent returns
library("moments")  # load library"moments"
str(moment)  # get list of arguments

moment(x=rets_series, order=3)  # apply moment function

moment_orders <- as.matrix(1:4)  # 4x1 matrix of moment orders

# anonymous function allows looping over function parameters
apply(X=moment_orders, MARGIN=1, 
      FUN=function(moment_order) {
          moment(x=rets_series, order=moment_order)
        }  # end anonymous function
      )  # end apply

# another way of passing parameters into moment() function
apply(X=moment_orders, MARGIN=1, FUN=moment, x=rets_series)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{sapply()} function is a specialized version of the \texttt{apply()} function,
      \vskip1ex
      \texttt{sapply()} applies a function to a list or a vector of objects and returns a vector,
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interprets it as a list, and applies the function to each element (column) of the data frame,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sapply(6:10, sqrt)  # sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # sapply on list

# calculate means of iris data frame columns
sapply(iris, mean)  # returns NA for Species

# create a matrix
mat_rix <- matrix(sample(100), ncol=4)
# calculate column means using apply
apply(mat_rix, 2, mean)

# calculate column means using sapply, with anonymous function
sapply(1:ncol(mat_rix), 
       function(col_index) {  # anonymous function
         mean(mat_rix[, col_index])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{lapply()} function is a specialized version of the \texttt{apply()} function,
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list,
      \vskip1ex
      The function \texttt{unlist()} flattens a list into a vector that contains the atomic elements of the list,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<>>=
sapply(iris[, -5], mean)  # vector of means of numeric columns
lapply(iris[, -5], mean)  # calculate means of numeric columns
# calculate means of numeric columns using anonymous function
unlist(lapply(iris, 
              function(col_umn) {
                if (is.numeric(col_umn)) mean(col_umn)
              }  # end anonymous function
              )  # end sapply
       )  # end unlist
unlist(sapply(iris, function(col_umn) {if (is.numeric(col_umn)) mean(col_umn)}))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.4emThat Return \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions can also return a function as their value,
      \vskip1ex
      Functions returned by a function are called \emph{closures},
      \vskip1ex
      Functions that return closures can be used as \emph{function factories},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a power function factory
make_func <- function(arg_param) {  # wrapper function
  function(arg_var) {  # anonymous closure
    arg_var^arg_param
  }
}  # end make_func

square_func <- make_func(2)  # define square function
square_func(4)
cube_func <- make_func(3)  # define cube function
cube_func(2)
cube_root_func <- make_func(1/3)  # define cube root function
cube_root_func(8)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{mutable state} is an object that is preserved between function calls,
      \vskip1ex
      Functions that return closures can also be used for creating \emph{mutable states},
      \vskip1ex
      A function \emph{evaluation} environment is only temporary and disappears after the function returns its value,
      \vskip1ex
      But a \emph{closure} assigned to a name maintains access to the environment in which it was created,
      \vskip1ex
      Therefore the \emph{closure} maintains access to its parent function's arguments and locally defined variables,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
make_counter <- function() {
# counter function with mutable state
  counter <- 0  # initialize counter
  cat('counter = ', counter)
  function() {  # return anonymous advance function
    counter <<- counter + 1  # advance counter
    cat('counter = ', counter)
  }  # end advance function
}  # end make_counter

advance_counter <- make_counter()  # create new counter
advance_counter()  # advance counter
advance_counter()  # advance counter
advance_counter_two <- make_counter()  # create another counter
advance_counter_two()  # advance counter two
advance_counter()  # advance counter one
advance_counter_two()  # advance counter two
advance_counter()  # advance counter one
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Generating Function}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \emph{Mutable states} can be used to implement pseudo-random number generators,
        <<>>=
# Returns the pseudo-random generating function random_generator
# the formal argument 'seed' persists in the evaluation environment of seed_random
seed_random <- function(seed) {  # seed must be an integer
  random_number <- as.numeric(paste0('0.', seed))  # initialize
# random_generator returns a vector of pseudo-random numbers of length length_rand
  random_generator <- function(length_rand=1) {  # assign function name for recursion
# Returns a vector of pseudo-random numbers of length length_rand
    random_number <<- 4*random_number*(1 - random_number)  # logistic map
    if (length_rand == 1) {
      return(random_number)
    } else {
      return(c(random_number, random_generator(length_rand - 1)))
    }  # end if
  }  # end random_generator
}  # end seed_random

# create a random number generating function and set seed
make_random <- seed_random(88)
make_random(10)  #  calculate vector of 10 pseudo-random numbers
ls(environment(make_random))  # list objects in scope of make_random
      @
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bank Account Using Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-2em}
  \begin{columns}[T]
    \column{0.5\textwidth}
        <<echo=4:30>>=
rm(list=ls())
# the super-assignment operator '<<-' adjusts the balance
# 'balance' exists in open_account evaluation environment
# bank account example (from Venables) demonstrates mutable states
# 'balance' is persistent between function calls
open_account <- function(balance) {
# returns function list for account operations
  list(
    deposit = function(amount) {  # make deposit
      if(amount > 0) {
        balance <<- balance + amount  # '<<-' super-assignment operator
        cat(amount, "deposited. Your balance is now:", 
            balance, "\n")
      } else {
        cat("Deposits must be positive!\n")
      }
    },  # end deposit
    withdraw = function(amount) {  # make withdrawal
      if(amount <= balance) {
        balance <<- balance - amount  # '<<-' super-assignment operator
        cat(amount, "withdrawn. Your balance is now:", 
            balance, "\n")
      } else {
        cat("You don't have that much money!\n")
      }
    },  # end withdraw
    get_balance = function() {  # get balance
      cat("Your current balance is:", balance, "\n")
    }  # end get_balance
  )  # end list
}  # end open_account
@
    \column{0.5\textwidth}
        <<>>=
# perform account operations
# open an account with 100 deposit
my_account <- open_account(100)
ls(my_account)  # my_account is a list
# add my_account to search path
attach(my_account)
withdraw(30)  # withdrawal to buy groceries
deposit(100)  # deposit paycheck to account
withdraw(200)  # withdrawal to buy Gucci bag
get_balance()  # get account balance

# list objects in scope of get_balance
ls(environment(get_balance))

detach(my_account)  # remove my_account from search path
@
  \end{columns}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Infix Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Most functions in \texttt{R} are \emph{prefix} operators (where the function name is followed by an argument list),
      \vskip1ex
      \emph{Infix} operators (where the the function name comes in between its arguments) can also be applied using \emph{prefix} syntax,
      \vskip1ex
      \texttt{R} also allows defining new \emph{infix} functions,
      \vskip1ex
      All user defined \emph{infix} function names must start and end with a "\texttt{\%}" character,
      \vskip1ex
      The new \emph{infix} function name must be used in quotes,
      \vskip1ex

    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30>>=
rm(list=ls())
'+' (2, 3)  # infix operator applied using prefix syntax

glob_var <- 1  # define a global variable
probe_scope <- function() {  # exploring scope
  loc_var <- 1  # define a local variable
  new_globvar <<- 11  # define a global variable
  cat('objects in parent environment:\t', 
      ls(parent.env(environment())), '\n')
  cat('objects in function environment:\t', 
      ls(environment()), '\n')
  cat('this is glob_var:\t', glob_var, '\n')
  glob_var <- 10  # re-define the global variable
  cat('this is re-defined glob_var:\t', glob_var, '\n')
}  # end probe_scope
probe_scope()
glob_var  # global variable is restored
new_globvar  # new_globvar is preserved
loc_var  # local variable is gone!
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Object-Oriented Programming in \texttt{R}}


%%%%%%%%%%%%%%%
\subsection{The \texttt{S3} Object-Oriented Programming System in \texttt{R}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{S3} is the standard object oriented (OO) programming system in \texttt{R},
      \vskip1ex
      The \texttt{S3} system is based on the \texttt{R} \emph{class} system and on \emph{generic} functions,
      \vskip1ex
      \emph{Generic} functions have different \emph{methods} that are dispatched depending on the \emph{class} of the object,
      \vskip1ex
      The actual function that is executed (called a \emph{method}) is determined by the class of the object on which the \emph{generic} function is called,
      \vskip1ex
      For example \texttt{plot()} and \texttt{cbind()} are \emph{generic} functions,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
library(zoo)  # load package zoo
# get all methods for generic function "cbind"
methods("cbind")

# show the method of "cbind" applied to "zoo" objects
cbind.zoo
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Generic Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Generic} functions follow the naming convention \texttt{function.classname()},
      \vskip1ex
      The \emph{generic} function \texttt{cbind()} has many \emph{methods} with names \texttt{cbind.*()},
      \vskip1ex
      The \texttt{cbind()} method dispatched to \texttt{zoo} objects is called \texttt{cbind.zoo()},
      \vskip1ex
      The function \texttt{methods()} lists all methods for a generic function, or all methods for a class,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
library(zoo)  # load package zoo
# get all methods for generic function "cbind"
# get generic function methods applied to "zoo" objects
methods(class="zoo")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exploring Generic Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Generic functions} are defined using the function \texttt{UseMethod()}
      \vskip1ex
      the user can access symbols from a package that isn't attached using the double-colon operator \texttt{tools::file\_ext}

    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
cbind.ts  # can't view code of non-visible functions
getAnywhere(cbind.ts)  # display function
stats:::cbind.ts  # display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Internal and Primitive Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      R .Internal .Primitive
      \vskip1ex
      several functions call compiled code: .C(), .Call(), .Fortran(), .External(), or .Internal() and .Primitive()
      \vskip1ex
      The function \texttt{getAnywhere()} displays \texttt{R} objects, including functions,
      \vskip1ex
      If a function name is called alone then \texttt{R} displays the function code (but it must be on the search path),
      \vskip1ex
      the user can access symbols from a package that isn't attached using the double-colon operator \texttt{tools::file\_ext}

      The function \texttt{getAnywhere()} also displays \texttt{R} objects that aren't on the search path,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# get all methods for generic function "plot"
methods("plot")

getAnywhere(plot)  # display function
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Creating New Classes and Methods}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A new \texttt{R} class can be created by simply assigning to the \texttt{class} attribute of an object,
      \vskip1ex
      Then new \emph{methods} can be defined, and \texttt{R} will automatically dispatch them to objects of the new \emph{class},
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30>>=
rm(list=ls())
my_zoo <- zoo(rnorm(4), order.by=(Sys.Date() + 0:3))
class(my_zoo)
length(my_zoo)

# coerce "zoo" object to new class "newts"
class(my_zoo) <- "newts"
class(my_zoo)

# define "length" method for class "newts"
length.newts <- function(in_ts) {
# "length" method for class" "newts"
  cat("length of object from newts class\n")
  length(unclass(in_ts))
}  # end length.newts

# apply new "length" method
length(my_zoo)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}
    \item Create a function for calculating the kurtosis of a time series of returns,
    \item Using this function calculate the kurtosis of DAX returns, and of t-distribution returns with four degrees of freedom (use the same number of data points in both cases),
    \item Plot the probability density of DAX returns together with t-distribution returns with four degrees of freedom on a single plot,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}
    \item Read chapters 4, 5, 10: \fullcite{website:rintro}
  \end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Additional Reading}
\begin{frame}[t]{\subsecname}

Download \texttt{R} Interpreter from \texttt{CRAN} (Comprehensive \texttt{R} Archive Network)\\
\hskip1em\url{http://cran.r-project.org/}\\
\vskip4ex
Download \texttt{RStudio} IDE (Integrated Development Environment)\\
\hskip1em\url{http://www.rstudio.com/ide}\\
\vskip4ex

\end{frame}


\end{document}
