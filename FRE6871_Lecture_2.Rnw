% FRE6871_Lecture_2

% Define knitr options
% !Rnw weave=knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, tidy=FALSE, strip.white=FALSE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
options(digits=3)
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% mathtools package for math symbols
% \usepackage{mathtools}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE_lectures.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text scriptsize
\renewcommand\UrlFont{\scriptsize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6871 Lecture\#2]{FRE6871 \texttt{R} in Finance}
\subtitle{Lecture\#2, Spring 2016}
% \subject{Getting Started With R}
\institute[NYU Tandon]{NYU Tandon School of Engineering}
\titlegraphic{\includegraphics[scale=0.2]{image/tandon_long_color}}
\author[Jerzy Pawlowski]{Jerzy Pawlowski \emph{\href{mailto:jp3900@nyu.edu}{jp3900@nyu.edu}}}
% \email{jp3900@poly.edu}
\date{April 11, 2016}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has the following logical operators:
      \begin{itemize}
        \item \texttt{"<"} less than,
        \item \texttt{"<="} less than or equal to,
        \item \texttt{">"} greater than,
        \item \texttt{">="} greater than or equal to,
        \item \texttt{"=="} exactly equal to,
        \item \texttt{"!="} not equal to,
        \item \texttt{"!x"} Not \texttt{x},
        \item \texttt{"x \& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x | y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
vec_tor1 <- c(2, 4, 6)
vec_tor1 < 5  # element-wise comparison
(vec_tor1 < 5) & (vec_tor1 > 3)
vec_tor1[(vec_tor1 < 5) & (vec_tor1 > 3)]
vec_tor2 <- c(-10, 0, 10)
vec_tor1 < vec_tor2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} also has two long form logical operators:
      \begin{itemize}
        \item \texttt{"x \&\& y"} \texttt{x} AND \texttt{y},
        \item \texttt{"x || y"} \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first elements of their vector arguments,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use \texttt{"\&\&"} and \texttt{"||"} in if-clauses,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
echo_true <- function() {cat("echo_true\t"); TRUE}
echo_false <- function() {cat("echo_false\t"); FALSE}
echo_true() | echo_false()
echo_true() || echo_false()  # echo_false() isn't evaluated at all!
vec_tor <- c(2, 4, 6)
# works (does nothing) using '&&'
if (is.matrix(vec_tor) && (vec_tor[2, 3] > 0)) {
  vec_tor[2, 3] <- 1
}
# no short-circuit so fails (produces an error)
if (is.matrix(vec_tor) & (vec_tor[2, 3] > 0)) {
  vec_tor[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Comparing Objects With \texttt{identical()}}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{identical()} tests if two objects are exactly the same, and always returns a single logical \texttt{TRUE} or \texttt{FALSE} (never \texttt{NA} or logical \texttt{vectors}),
      \vskip1ex
      For atomic arguments \texttt{identical()} often gives the same result as the \texttt{"=="} operator, but it's not synonymous with it in general,
      \vskip1ex
      The \texttt{"=="} operator applies the \emph{recycling rule} to vector arguments and returns logical \texttt{vectors}, but \texttt{identical()} doesn't and returns a single logical value,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
num_var <- 2
num_var==2
identical(num_var, 2)

identical(num_var, NULL) 
num_var==NULL
is.null(num_var)

vec_tor <- c(2, 4, 6)
vec_tor==2
identical(vec_tor, 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lookup and Matching}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{which()} returns the indices of the \texttt{TRUE} elements of a boolean \texttt{vector} or \texttt{array}, 
      \vskip1ex
      If the argument is an \texttt{array} and \texttt{arr.ind=TRUE}, then \texttt{which()} returns a matrix with rows containing the indices of the \texttt{TRUE} elements,
      \vskip1ex
      The functions \texttt{which.max()} and \texttt{which.min()} return the index of the minimum or maximum of a \texttt{numeric} or \texttt{boolean} vector,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
vec_tor <- sample(1:9)
mat_rix <- matrix(vec_tor, ncol=3)
vec_tor
which(vec_tor == 5)
# equivalent but less efficient than above
(1:length(vec_tor))[vec_tor == 5]
which(vec_tor > 5)
# find indices of TRUE elements of boolean matrix
which((mat_rix == 5)|(mat_rix == 6), arr.ind=TRUE)
# equivalent but less efficient than above
arrayInd(which((mat_rix == 5)|(mat_rix == 6)), 
         dim(mat_rix), dimnames(mat_rix))
which.max(vec_tor)
# equivalent but less efficient than above
which(vec_tor == max(vec_tor))
which.min(vec_tor)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{match()} returns the index of the first element of its second argument, that matches its first argument,
      \vskip1ex
      The binary operator \texttt{\%in\%} returns a boolean \texttt{vector} with \texttt{TRUE} values corresponding to elements that have matches,
      \vskip1ex
      \texttt{\%in\%} is a wrapper for \texttt{match()} defined as follows:\\
      \texttt{"\%in\%" <- function(x, table) match(x, table, nomatch=0) > 0},
      \vskip1ex
      \texttt{\%in\%} never returns \texttt{NA}, so it's preferred in \texttt{if()} statements,
      \vskip1ex
      \texttt{any()} returns \texttt{TRUE} if at least one element of a boolean vector is \texttt{TRUE}, and \texttt{FALSE} otherwise,
      \vskip1ex
      Given a single argument, \texttt{any()} is equivalent to \texttt{\%in\%}, but is much faster because it's a \emph{compiled} function,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
match(5, vec_tor)
# equivalent but less efficient than above
which(vec_tor == 5)
match(-5, vec_tor)
5 %in% vec_tor
# equivalent to above
match(5, vec_tor, nomatch=0) > 0
-5 %in% vec_tor
c(5, -5) %in% vec_tor
# equivalent to "5 %in% vec_tor"
any(vec_tor == 5)
# equivalent to "-5 %in% vec_tor"
any(vec_tor == (-5))
if(any(vec_tor < 0))
  cat("vector contains negative values\n")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The standard assignment operator in \texttt{R} is \texttt{"<-"},
      \vskip1ex
      Both \texttt{"<-"} and \texttt{"="} are valid assignment operators in \texttt{R},
      \vskip1ex
      The \texttt{"<-"} operator may cause an error if \texttt{R} confuses it with the \texttt{"<"} logical operator,
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} (\texttt{"<-"} has higher precedence than \texttt{"="}),
      \vskip1ex
      The \texttt{"="} operator is used for named arguments in function calls,
      \vskip1ex
      When variables are assigned within an argument list using the \texttt{"="} operator, their \emph{scope} is limited to the function,
      \vskip1ex
      {\color{red}{Rule of Thumb}}:\\
      Use \texttt{"<-"} in \texttt{R} scripts and inside functions,\\
      Use \texttt{"="} only in function calls,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
num_var1 <- 3  # "<-" and "=" are valid assignment operators
num_var1
num_var1 = 3
num_var1
2<-3  # "<" operator confused with "<-"
2 < -3  # add space or brackets to avoid confusion
median(x=1:10)  # "=" assignment within argument list
x  # x doesn't exist outside the function
median(x <- 1:10)  # "<-" assignment within argument list
x  # x exists outside the function
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{The \texttt{"if() else"} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} has the familiar \texttt{"if() \{...\} else \{...\}"} statement to control execution flow depending on logical conditions,
      \vskip1ex
      The logical conditions must be either a logical or numeric type, otherwise an error is produced,
      \vskip1ex
      The \texttt{"else"} statement can also be omitted,
      \vskip1ex
      \texttt{"if"} statements can be nested using multiple \texttt{"else if"} statements,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
num_var1 <- 1

if (num_var1) {  # numeric zero is FALSE, all other numbers are TRUE
  num_var2 <- 4
} else if (num_var1 == 0) {  # 'else if' together on same line
  num_var2 <- 0
} else {  # 'else' together with curly braces
  num_var2 <- -4
}  # end if

num_var2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{switch()} Control Statement}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{switch()} evaluates its first argument \texttt{"EXPR"}, and depending on its value, chooses one of the named arguments passed to the dots \texttt{"..."} argument,
      \vskip1ex
      The dots \texttt{"..."} argument accepts a named list (symbol-value pairs),
      \vskip1ex
      If \texttt{"EXPR"} is a character string, then the element with that name is returned by \texttt{switch()},
      \vskip1ex
      If \texttt{switch()} can't match the string to any name, then it returns \texttt{NULL}, 
      \vskip1ex
      If \texttt{"EXPR"} is an integer, then \texttt{switch()} returns the element from that position, 
      \vskip1ex
      Using \texttt{switch()} is a convenient alternative to a cascade of \texttt{"if() else"} statements, 
      \vskip1ex
      The function \texttt{match.arg()} matches a string to one of the possible values, and returns the matched value, or produces an \texttt{error} if it can't match it,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
switch("a", a="aaahh", b="bee", c="see", d=2, "else this")
switch("c", a="aaahh", b="bee", c="see", d=2, "else this")
switch(3, a="aaahh", b="bee", c="see", d=2, "else this")
switch("cc", a="aaahh", b="bee", c="see", d=2, "else this")
# measure of central tendency
centra_lity <- function(in_put, 
            meth_od=c("mean", "mean_narm", "median")) {
# validate "meth_od" argument
  meth_od <- match.arg(meth_od)
  switch(meth_od,
         mean=mean(in_put),
         mean_narm=mean(in_put, na.rm=TRUE),
         median=median(in_put))
}  # end centra_lity
foo <- rnorm(100, mean=2)
centra_lity(foo, "mean")
centra_lity(foo, "mean_narm")
centra_lity(foo, "median")
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using \texttt{for()} and \texttt{while()} Loops}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{"for() \{...\}"} statement iterates a \emph{bound} variable over elements of a vector or list, 
      \vskip1ex
      The \texttt{for()} loop creates the \emph{bound} variable, which then iterates over the elements of the vector, and upon loop exit the \emph{bound} variable is left equal to the last element of the vector, 
      \vskip1ex
      \texttt{R} also has a \texttt{"while() \{...\}"} loop,
      \vskip1ex
      \texttt{while()} loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE},
      \vskip1ex
      But \texttt{while()} loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
color_list <- list("red", "white", "blue")
for (some_color in color_list) {  # loop over list
  print(some_color)
}
for (in_dex in 1:3) {  # loop over vector
  print(color_list[[in_dex]])
}

in_dex <- 1  # while loops need initialization
while (in_dex < 4) {  # while loop
  print(color_list[[in_dex]])
  in_dex <- in_dex + 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using \texttt{for()} Loop}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 0, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration,
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector,
      \vskip1ex
      The function \texttt{numeric(k)} returns a numeric vector of zeros of length \texttt{k},
      \vskip1ex
      The function \texttt{numeric(0)} returns an empty (zero length) numeric vector (not to be confused with a \texttt{NULL} object),
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
# fib_seq <- numeric()  # zero length numeric vector
# pre-allocate vector instead of "growing" it
fib_seq <- numeric(10)
fib_seq[1] <- 0  # initialize
fib_seq[2] <- 1  # initialize
for (i in 3:10) {  # perform recurrence loop
  fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2]
}  # end for
fib_seq
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Recursive Data Objects}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Lists are a type of vector that contain elements of different \emph{types},
      \vskip1ex
      Lists are recursive object types, meaning each list element can contain other vectors or lists,
      \vskip1ex
      The function \texttt{list()} creates a list from a list of vectors,
      \vskip1ex
      \texttt{list()} creates a named list from a list of symbol-value pairs,
      \vskip1ex
      The function \texttt{is.list()} returns \texttt{TRUE} if its argument is a list, and \texttt{FALSE} otherwise,
      \vskip1ex
      The function \texttt{unlist()} flattens a list into a vector that contains the atomic elements of the list (which typically causes coercion),
    \column{0.6\textwidth}
      \vspace{-2em}
      <<>>=
# create a list with two elements
list_var <- list(c('a', 'b'), 1:4)
list_var
c(typeof(list_var), mode(list_var), class(list_var))
# lists are also vectors
c(is.vector(list_var), is.list(list_var))
length(list_var)
# create named list
list_var <- list(first=c('a', 'b'), second=1:4)
list_var
names(list_var)
unlist(list_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Lists can be subset (indexed) using:
      \begin{itemize}
        \item the \texttt{"["} operator (returns sublist),
        \item the \texttt{"[["} operator (returns an element),
        \item the \texttt{"\$"} operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
list_var[2]  # extract second element as sublist
list_var[[2]]  # extract second element
list_var[[2]][3]  # extract third element of second element
list_var[[c(2, 3)]]  # third element of second element
list_var$second  # extract second element
list_var$s  # extract second element - partial name matching
list_var$second[3]  # third element of second element
list_var <- list()  # empty list
list_var$a <- 1
list_var[2] <- 2
list_var
names(list_var)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Vectors Into \subsecname \hskip0.5em Using \texttt{as.list()}}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{as.list()} coerces vectors and other objects into lists,
      \vskip1ex
      \texttt{as.list()} returns a list with the same elements as the vector,
      \vskip1ex
      \texttt{list()} called on a vector returns a single element equal to the vector,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
as.list(c(1,2,3))
list(c(1,2,3))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Factors are similar to vectors, but their elements can only take values from a set of \emph{levels},
      \vskip1ex
      Factors are designed for categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a vector into a factor,
      \vskip1ex
      Factors have two attributes: \emph{class} (equal to \texttt{"factor"}) and \texttt{levels} (the allowed values),
      \vskip1ex
      Although factors aren't vectors, the data underlying a factor is an integer vector, called an \emph{encoding vector},
      \vskip1ex
      The function \texttt{as.numeric()} extracts the encoding vector (indices) of a factor,
      \vskip1ex
      The function \texttt{as.vector()} coerces a factor to a character vector,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<>>=
# create factor vector
fac_tor <- factor(c('b', 'c', 'd', 'a', 'c', 'b'))
fac_tor
fac_tor[3]
attributes(fac_tor)  # get factor attributes
levels(fac_tor)  # get allowed values
as.numeric(fac_tor)  # get encoding vector
is.vector(fac_tor)
as.factor(1:5)  # coerce vector to factor
# coerce factor to character vector
as.vector(as.factor(1:5))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames are \texttt{2-D} objects (like matrices), but their columns can be of different \emph{types},
      \vskip1ex
      Data frames can be thought of as lists of vectors of the same length,
      \vskip1ex
      The function \texttt{data.frame()} creates a \texttt{data frame} from vectors assigned to column names,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0)
                    )  # end data.frame
data_frame
dim(data_frame)  # get dimension attribute
colnames(data_frame)  # get the colnames attribute
rownames(data_frame)  # get the rownames attribute
class(data_frame)  # get object class
typeof(data_frame)  # data frames are lists
is.data.frame(data_frame)

class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
      \vskip1ex
      Depending on how a data frame is subset, the result can be either a data frame or a vector,
      \vskip1ex
      Extracting a single column from a data frame produces a vector,
      \vskip1ex
      The data frame class attribute can be preserved by using the parameter \texttt{"drop=FALSE"},
      \vskip1ex
      Extracting a single row from a data frame produces a data frame,
      \vskip1ex
      The function \texttt{unlist()} applied to a single row extracted from a data frame coerces it to a vector, 
    \column{0.6\textwidth}
      \vspace{-2em}
      <<>>=
data_frame[, 3]  # extract third column
data_frame[[3]]  # extract third column
data_frame[[3]][2]  # second element from third column
data_frame$price[2]  # second element from 'price' column
is.data.frame(data_frame[[3]]); is.vector(data_frame[[3]])
data_frame[, 3, drop=FALSE]  # extract third column
data_frame[2, ]  # extract second row
data_frame[2, ][3]  # third element from second column
data_frame[2, 3]  # third element from second column
unlist(data_frame[2, ])  # coerce to vector
is.data.frame(data_frame[2, ]); is.vector(data_frame[2, ])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em and Factors}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      By default \texttt{data.frame()} coerces \texttt{character} vectors to \texttt{factors}, unless the \texttt{stringsAsFactors=FALSE} option is passed into \texttt{data.frame()},
      \vskip1ex
      The function \texttt{options()} sets global \emph{options}, that determine how \texttt{R} computes and displays its results,
      \vskip1ex
      If the global \texttt{option} \texttt{stringsAsFactors=FALSE} is set, then \texttt{character} vectors will not be coerced to \texttt{factors} in all subsequent \texttt{data frame} operations,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
data_frame <- data.frame(  # create a data frame
                      type=c('rose', 'daisy', 'tulip'),
                      color=c('red', 'white', 'yellow'),
                      price=c(1.5, 0.5, 1.0),
                      row.names=c('flower1', 'flower2', 'flower3'),
                      stringsAsFactors=FALSE
                    )  # end data.frame
data_frame
class(data_frame$type)  # get column class
class(data_frame$price)  # get column class
# set option to not coerce character vectors to factors
options(stringsAsFactors=FALSE)
options("stringsAsFactors")
default.stringsAsFactors()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{str()} displays the structure of an \texttt{R} object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an \texttt{R} object,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<>>=
str(data_frame)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{sort()} returns a sorted vector,
      \vskip1ex
      The function \texttt{order()} returns a permutation index,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-(1:7))>>=
type <- c('rose', 'daisy', 'tulip')  # character vector
color <- c('red', 'white', 'yellow')  # character vector
price <- c(1.5, 0.5, 1.0)  # numeric vector
# create a data frame
data_frame <- data.frame(type, color, price)
# assign rownames
rownames(data_frame) <- c('flower1', 'flower2', 'flower3')
sort_data <- sample(1:6)  # permute data
sort_data
sort(sort_data)  # sorted data
order(sort_data)  # permution index
sort_data[order(sort_data)]  # permution index
order(data_frame$price)  # permute on price
data_frame[order(data_frame$price), ]  # sort on price
data_frame[order(data_frame$color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing \subsecname \hskip0.5em Into Matrices Using \texttt{as.matrix()}}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{as.matrix()} coerces vectors and data frames into matrices,
      \vskip1ex
      Coercing a data frame into a matrix causes coercion of \texttt{numeric} values into \texttt{character},
      \vskip1ex
      \texttt{as.matrix()} coerces vectors into single column matrices, as opposed to \texttt{matrix()}, which produces a matrix,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
as.matrix(data_frame)
vec_tor <- sample(9)
matrix(vec_tor, ncol=3)
as.matrix(vec_tor, ncol=3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Matrices Into \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The generic function \texttt{as.data.frame()} coerces matrices and other objects into data frames,
      \vskip1ex
      The method \texttt{as.data.frame.matrix()} coerces only matrices into data frames,
      \vskip1ex
      \texttt{as.data.frame.matrix()} is about \texttt{50\%} faster than \texttt{as.data.frame()}, because it skips extra \texttt{R} code in \texttt{as.data.frame()} needed for argument validation, error checking, and method dispatch,
      \vskip1ex
      As a general rule, calling generic functions is slower than directly calling individual methods, because generic functions must execute extra \texttt{R} code for method dispatch,
      \vskip1ex
      The function \texttt{data.frame()} can also be used to coerce matrices into data frames, but is much slower than even \texttt{as.data.frame()},
      \vskip1ex
      \texttt{as.data.frame()} is about three times faster than \texttt{data.frame()}, because it doesn't require extra \texttt{R} code in \texttt{data.frame()} needed for handling different types of vectors, and for method dispatch,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
library(microbenchmark)
# call method instead of generic function
as.data.frame.matrix(mat_rix)
# a few methods for generic function as.data.frame()
sample(methods(as.data.frame), size=4)
# function method is faster than generic function
summary(microbenchmark(
  as_data_frame_matrix=
    as.data.frame.matrix(mat_rix),
  as_data_frame=as.data.frame(mat_rix),
  data_frame=data.frame(mat_rix), 
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Coercing Matrices Into Lists}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Matrices can be coerced into lists in at least two different ways, 
      \vskip1ex
      Matrices can be first coerced into a data frame, and then into a list using function \texttt{as.list()}, 
      \vskip1ex
      Matrices can be directly coerced into a list using function \texttt{lapply()}, 
      \vskip1ex
      Using \texttt{lapply()} is the faster of the two methods, because \texttt{lapply()} is a \emph{compiled} function, 
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=(-(1:1)),eval=TRUE>>=
library(microbenchmark)
# lapply is faster than coercion function
summary(microbenchmark(
  as_list=
    as.list(as.data.frame.matrix(mat_rix)),
  l_apply=
    lapply(seq_along(mat_rix[1, ]), 
           function(in_dex) mat_rix[, in_dex]),
  times=10))[, c(1, 4, 5)]  # end microbenchmark summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{iris} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{iris} data frame is included in the \texttt{datasets} base package,
      \vskip1ex
      \texttt{iris} contains sepal and petal dimensions of 50 flowers from 3 species of iris,
      \vskip1ex
      The function \texttt{unique()} extracts unique elements of an object,
      \vskip1ex
      \texttt{sapply()} applies a function to a list or a vector of objects and returns a vector,
      \vskip1ex
      \texttt{sapply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# ?iris  # get information on iris
dim(iris)
head(iris, 2)
colnames(iris)
unique(iris$Species)  # list of unique elements of iris
class(unique(iris$Species))
# find which columns of iris are numeric
sapply(iris, is.numeric)
# calculate means of iris columns
sapply(iris, mean)  # returns NA for Species
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{mtcars} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{mtcars} data frame is included in the \texttt{datasets} base package, and contains design and performance data for 32 automobiles,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# ?mtcars  # mtcars data from 1974 Motor Trend magazine
# mpg   Miles/(US) gallon
# qsec   1/4 mile time
# hp	 Gross horsepower
# wt	 Weight (lb/1000)
# cyl   Number of cylinders
dim(mtcars)
head(mtcars, 2)
colnames(mtcars)
head(rownames(mtcars), 3)
unique(mtcars$cyl)  # extract list of car cylinders
sapply(mtcars, mean)  # calculate means of mtcars columns
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{Cars93} Data Frame}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \texttt{Cars93} data frame is included in the \texttt{MASS} package, and contains design and performance data for 93 automobiles,
      \vskip1ex
      The function \texttt{hist()} calculates and plots a histogram,
      \vskip1ex
      The parameter \texttt{breaks} is the number of cells of the histogram,
      \vskip1ex
      \texttt{"FD"} stands for the Freedman-Diaconis rule for calculating histogram breaks,
        <<Cars93_hist,fig.show='hide'>>=
library(MASS)
# ?Cars93  # get information on Cars93
dim(Cars93)
head(colnames(Cars93))
# head(Cars93, 2)
unique(Cars93$Type)  # extract list of car types
# sapply(Cars93, mean)  # calculate means of Cars93 columns
# plot histogram of Highway MPG using the Freedman-Diaconis rule
hist(Cars93$MPG.highway, col="lightblue1", 
     main="Distance per Gallon 1993", xlab="Highway MPG", breaks="FD")
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/Cars93_hist-1}
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Data Management and Analysis}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      When a function produces \texttt{NA} or \texttt{NaN} values, then it also produces a \emph{warning} condition, but not an \emph{error},
      \vskip1ex
      \texttt{NA} or \texttt{NaN} values are not \emph{errors},
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for \texttt{NA} and \texttt{NaN} values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove \texttt{NAs} from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, NaN, 0/0, 1/0))  # test for NA
is.nan(c(NA, NaN, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
da_ta <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
da_ta
mean(da_ta)  # returns NA, when NAs are input
mean(da_ta, na.rm=TRUE)  # remove NAs from input data
da_ta[!is.na(da_ta)]  # delete the NA values
sum(!is.na(da_ta))  # count non-NA values
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
# display rows containing NAs
head(airquality[!complete.cases(airquality), ])
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from package \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=(-1)>>=
rm(list=ls())
# remove rows containing NAs
good_air <- airquality[complete.cases(airquality), ]
dim(good_air)
head(good_air)  # NAs removed
library(zoo)  # load package zoo
good_air <- na.locf(airquality)  # replace NAs
dim(good_air)
head(good_air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{NULL} Values}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{NULL} is a reserved word that represents a value that doesn't exist,
      \vskip1ex
      \texttt{NULL} is a legitimate value, not bad data,
      \vskip1ex
      The function \texttt{is.null()} tests for \texttt{NULL} values,
      \vskip1ex
      \texttt{NULL} is often returned by functions whose value is undefined,
      \vskip1ex
      Very often variables are initialized to \texttt{NULL} before the start of iteration,
      \vskip1ex
      A more efficicent way to perform iteration is by pre-allocating the vector,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=TRUE>>=
# NULL values have no mode or type
c(mode(NULL), mode(NA))
c(typeof(NULL), typeof(NA))
c(length(NULL), length(NA))
# check for NULL values
is.null(NULL)
# NULL values are ignored when combined into a vector
c(1, 2, NULL, 4, 5)  
# vectors can be initialized to NULL
da_ta <- NULL
for (in_dex in 1:5)
  da_ta <- c(da_ta, in_dex)
da_ta
# NA value isn't ignored
da_ta <- NA
for (in_dex in 1:5)
  da_ta <- c(da_ta, in_dex)
da_ta
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{Lazy Evaluation of Function Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions delay evaluation of their arguments until they're needed by their \texttt{R} code,
      \vskip1ex
      This is called \emph{lazy} evaluation,
      \vskip1ex
      If the function body doesn't evaluate an argument, then the function won't produce an error, even if the argument is missing,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
lazy_func <- function(arg1, arg2) {  # define function lazy_func
  2*arg1  # just multiply first argument
}  # end lazy_func
lazy_func(3, 2)  # bind arguments by position
lazy_func(3)  # second argument was never evaluated!
lazy_func <- function(arg1, arg2) {  # define function lazy_func
  cat(arg1, '\n')  # write to output
  cat(arg2)  # write to output
}  # end lazy_func
lazy_func(3, 2)  # bind arguments by position
lazy_func(3)  # first argument written to output
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The dots \texttt{"..."} Function Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The dots \texttt{"..."} function argument is a formal argument without a name, as opposed to the other formal arguments which all have names,
      \vskip1ex
      The dots \texttt{"..."} bind with any number of additional arguments, that aren't already bound by name or position to the named arguments,
      \vskip1ex
      The dots \texttt{"..."} are used when the number of arguments isn't known in advance, and allows functions to accept an indefinite number of arguments,
      \vskip1ex
      The dots \texttt{"..."} are sometimes placed \emph{after} the named arguments, to allow passing of additional parameters into a function,
      \vskip1ex
      \emph{Functionals} often place the dots \texttt{"..."} argument \emph{after} the named arguments, to allow passing the dots \texttt{"..."} to the function being called by the \emph{functional}, 
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(plot)  # dots for additional plot parameters
bind_dots <- function(in_put, ...) {
  paste0("in_put=", in_put, 
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "in_put" bound by position
bind_dots(2, in_put=1, 3)  # "in_put" bound by name
bind_dots(1, 2, 3, foo=10)  # named argument bound to dots
bind_dots <- function(arg1, arg2, ...) {
  arg1 + 2*arg2 + sum(...)
}  # end bind_dots
bind_dots(3, 2)  # bind arguments by position
bind_dots(3, 2, 5, 8)  # extra arguments bound to dots
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Argument Binding With dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The dots \texttt{"..."} argument is sometimes placed \emph{before} the named arguments, so that a function can accept an indefinite number of arguments, without binding them by position with the named arguments,
      \vskip1ex
      When the dots \texttt{"..."} are placed \emph{before} the named arguments, the named arguments are often assigned default values, so they don't have to be bound to a value in the call,
      \vskip1ex
      Arguments that appear after the dots \texttt{"..."} must be \emph{bound} by their full name, and can't be partially \emph{bound},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
str(sum)  # dots before other arguments
sum(1, 2, 3)  # dots bind before other arguments
sum(1, 2, NA, 3, na.rm=TRUE)
bind_dots <- function(..., in_put) {
  paste0("in_put=", in_put, 
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
# arguments after dots must be bound by full name
bind_dots(1, 2, 3, in_put=10)
bind_dots(1, 2, 3, in_put=10, foo=4)  # dots bound
bind_dots(1, 2, 3)  # "in_put" not bound
bind_dots <- function(..., in_put=10) {
  paste0("in_put=", in_put, 
         ", dots=", paste(..., sep=", "))
}  # end bind_dots
bind_dots(1, 2, 3)  # "in_put" not bound, but has default
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Higher-order Functions}


%%%%%%%%%%%%%%%
\subsection{Functions as First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Functions in \texttt{R} are \emph{first class objects}, which means they can be treated like any other \texttt{R} object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher-order} functions are \texttt{R} functions that either accept a function as their argument (input) or return a function as their value (output),
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# create functional that accepts a function as input argument
func_tional <- function(func_name) {
# calculates statistic on random numbers
  set.seed(1)
  func_name(runif(1e4))  # apply the function name
}  # end func_tional
func_tional(mean)
func_tional(sd)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functions That Return Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} functions can also return a function as their value,
      \vskip1ex
      Functions returned by a function are called \emph{closures},
      \vskip1ex
      Functions that return closures can be used as \emph{function factories},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# define a power function factory
make_func <- function(arg_param) {  # wrapper function
  function(in_put) {  # anonymous closure
    in_put^arg_param
  }
}  # end make_func

square_func <- make_func(2)  # define square function
square_func(4)
cube_func <- make_func(3)  # define cube function
cube_func(2)
cube_root_func <- make_func(1/3)  # define cube root function
cube_root_func(8)
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Functionals}


%%%%%%%%%%%%%%%
\subsection{Functionals}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Functionals} are functions that accept a function or a function name as one of their input arguments,
      \vskip1ex
      \emph{Functionals} are able to execute function calls using the function names,
      \vskip1ex
      The function \texttt{match.fun()} returns a function name that is specified by a string,
      \vskip1ex
      \texttt{match.fun()} produces an error condition if it fails to find a function with the specified name,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# func_tional accepts function name and additional argument
func_tional <- function(func_name, in_put) {
# produce function name from argument
  func_name <- match.fun(func_name)
# execute function call
  func_name(in_put)
}  # end func_tional
func_tional(sqrt, 4)
str(sum)  # sum() accepts multiple arguments
# func_tional can't accept indefinite number of arguments
func_tional(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The dots \texttt{"..."} argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional},
      \vskip1ex
      If named values are passed to the dots \texttt{"..."} argument, then the \emph{functional} can bind them to the correct formal arguments of the function being called by the \emph{functional},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# func_tional accepts function name and dots '...' argument
func_tional <- function(func_name, ...) {
  func_name <- match.fun(func_name)
  func_name(...)  # execute function call
}  # end func_tional
func_tional(sum, 1, 2, 3)
func_tional(sum, 1, 2, NA, 4, 5)
func_tional(sum, 1, 2, NA, 4, 5, na.rm=TRUE)
# function with three arguments and dots '...' arguments
my_func <- function(in_put, param1, param2, ...) {
  c(input=in_put, param1=param1, param2=param2, 
        dots=c(...))
}  # end my_func
my_func(1, 2, 3, param2=4, param1=5)
func_tional(my_func, 1, 2, 3, param2=4, param1=5)
func_tional(my_func, 1, 2, 3, 4, 5)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \texttt{R} allows defining functions without assigning a name to them,
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name,
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# simple anonymous function
(function(x) (x + 3)) (10)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals},
      \vskip1ex
      \emph{Anonymous} functions can also be used as default values for function arguments,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# anonymous function passed to func_tional
func_tional(func_name=(function(x) (x + 3)), 5)
# anonymous function is default value
func_tional <- 
  function(..., func_name=function(x, y, z) {x+y+z}) {
    func_name <- match.fun(func_name)
    func_name(...)  # execute function call
}  # end func_tional
func_tional(2, 3, 4)  # use default func_name
func_tional(2, 3, 4, 5)
# func_name bound by name
func_tional(func_name=sum, 2, 3, 4, 5)
# pass anonymous function to func_name
func_tional(func_name=function(x, y, z) {x*y*z}, 
            2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Executing Function Calls Using the \texttt{do.call()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The functional \texttt{do.call()} executes a function call using a function name and a list of arguments,
      \vskip1ex
      \texttt{do.call()} allows calling a function on arguments that are elements of a list,
      \vskip1ex
      \texttt{do.call()} passes the list elements individually, instead of passing the whole list as one argument:\\
      \texttt{do.call(fun, list)=
      fun(list[[1]], list[[2]], \ldots)}
      \vskip1ex
      \texttt{do.call()} can be called inside other \emph{functionals} to allow them to execute function calls,
      \vskip1ex
      The function \texttt{str()} displays the structure of an \texttt{R} object, for example a function name and its formal arguments,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
str(sum)  # sum() accepts multiple arguments
# sum() can't accept list of arguments
sum(list(1, 2, 3))
str(do.call)  # "what" argument is a function
# do.call passes list elements into "sum" individually
do.call(sum, list(1, 2, 3))
do.call(sum, list(1, 2, NA, 3))
do.call(sum, list(1, 2, NA, 3, na.rm=TRUE))
# func_tional() accepts list with function name and arguments
func_tional <- function(list_arg) {
# produce function name from argument
  func_name <- match.fun(list_arg[[1]])
# execute function call uing do.call()
  do.call(func_name, list_arg[-1])
}  # end func_tional
arg_list <- list("sum", 1, 2, 3)
func_tional(arg_list)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Performing Loops Using the \texttt{apply()} \secname}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functions,
      \vskip1ex
      The function \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix,
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns},
      \vskip1ex
      \texttt{apply()} performs a loop over the list of objects, and can replace \texttt{"for"} loops in \texttt{R},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
str(apply)  # get list of arguments
# create a matrix
mat_rix <- matrix(6:1, nrow=2, ncol=3)
mat_rix
# sum the rows and columns
row_sums <- apply(mat_rix, 1, sum)
col_sums <- apply(mat_rix, 2, sum)
mat_rix <- cbind(c(sum(row_sums), row_sums), 
                  rbind(col_sums, mat_rix))
dimnames(mat_rix) <- list(c("col_sums", "row1", "row2"), 
                         c("row_sums", "col1", "col2", "col3"))
mat_rix
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with dots \texttt{"..."} Argument}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names,
      <<>>=
str(apply)  # get list of arguments
mat_rix <- matrix(sample(12), nrow=3, ncol=4)  # create a matrix
mat_rix
apply(mat_rix, 2, sort)  # sort matrix columns
apply(mat_rix, 2, sort, decreasing=TRUE)  # sort decreasing order
      @
    \column{0.5\textwidth}
        <<>>=
mat_rix[2, 2] <- NA  # introduce NA value
mat_rix
# calculate median of columns
apply(mat_rix, 2, median)
# calculate median of columns with na.rm=TRUE
apply(mat_rix, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Functional with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{apply()} functional combined with \emph{anonymous} functions can be used to loop over function parameters,
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=(-1)>>=
rm(list=ls())
# DAX percent returns
dax_rets <- 100*diff(log(EuStockMarkets[, 1]))
library(moments)  # load package moments
str(moment)  # get list of arguments
# apply moment function
moment(x=dax_rets, order=3)
# 4x1 matrix of moment orders
moment_orders <- as.matrix(1:4)
# anonymous function allows looping over function parameters
apply(X=moment_orders, MARGIN=1, 
      FUN=function(moment_order) {
          moment(x=dax_rets, order=moment_order)
        }  # end anonymous function
      )  # end apply

# another way of passing parameters into moment() function
apply(X=moment_orders, MARGIN=1, FUN=moment, 
      x=dax_rets)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{apply()} Calling Functions with Multiple Arguments}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When \texttt{apply()} calls a function with multiple arguments, then care must be taken for proper argument binding,
      \vskip1ex
      The dots \texttt{"..."} argument in \texttt{apply()} allows passing additional arguments to the function being called by \texttt{apply()},
      \vskip1ex
      The additional arguments to \texttt{apply()} must be \emph{bound} by their full (complete) names,
      \vskip1ex
      The values of the \texttt{"X"} argument in \texttt{apply()} are \emph{bound} by position to the first unused argument in the function being called by \texttt{apply()},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=TRUE>>=
# function with three arguments
my_func <- function(arg1, arg2, arg3) {
  c(arg1=arg1, arg2=arg2, arg3=arg3)
}  # end my_func
my_func(1, 2, 3)
da_ta <- as.matrix(1:4)
# pass da_ta to arg1
apply(X=da_ta, MAR=1, FUN=my_func, arg2=2, arg3=3)
# pass da_ta to arg2
apply(X=da_ta, MAR=1, FUN=my_func, arg1=1, arg3=3)
# pass da_ta to arg3
apply(X=da_ta, MAR=1, FUN=my_func, arg1=1, arg2=2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{lapply()} functional is a specialized version of the \texttt{apply()} functional,
      \vskip1ex
      \texttt{lapply()} applies a function to a list of objects and returns a list,
      \vskip1ex
      The function \texttt{unlist()} flattens a list into a vector that contains the atomic elements of the list,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
sapply(iris[, -5], mean)  # vector of means of numeric columns
lapply(iris[, -5], mean)  # list of means of numeric columns
unlist(lapply(iris,  # lapply using anonymous function
              function(col_umn) {
                if (is.numeric(col_umn)) mean(col_umn)
              }  # end anonymous function
              )  # end sapply
       )  # end unlist
unlist(sapply(iris, function(col_umn) {
  if (is.numeric(col_umn)) mean(col_umn)}))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{sapply()} Functional}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \texttt{sapply()} functional is a specialized version of the \texttt{apply()} functional,
      \vskip1ex
      \texttt{sapply()} applies a function to a vector or a list of objects and returns a vector or a list,
      \vskip1ex
      \texttt{sapply()} tries to return a vector, but if the elements can't be combined into a vector, then it returns a list,
      \vskip1ex
      When \texttt{sapply()} is given a data frame, it interprets it as a list, and applies the function to each element (column) of the data frame,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
sapply(6:10, sqrt)  # sapply on vector
sapply(list(6, 7, 8, 9, 10), sqrt)  # sapply on list

# calculate means of iris data frame columns
sapply(iris, mean)  # returns NA for Species

# create a matrix
mat_rix <- matrix(sample(100), ncol=4)
# calculate column means using apply
apply(mat_rix, 2, mean)

# calculate column means using sapply, with anonymous function
sapply(1:ncol(mat_rix), 
       function(col_index) {  # anonymous function
         mean(mat_rix[, col_index])
  }  # end anonymous function
)  # end sapply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{sapply()} Returning Matrices}
\begin{frame}[fragile,t]{\subsecname}
\vspace{-1em}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      If the function called by \texttt{sapply()} returns a vector, then \texttt{sapply()} returns a matrix, if possible,
      \vskip1ex
      The vectors returned by the function are arranged to form columns of the matrix returned by \texttt{sapply()},
      \vskip1ex
      But if the function returns vectors of different lengths, then \texttt{sapply()} cannot return a matrix, and returns a list instead,
      \vskip1ex
      This behavior of \texttt{sapply()} can cause run-time errors,
      \vskip1ex
      The function \texttt{vapply()} is similar to \texttt{sapply()}, but it always attempts to simplify its output to a matrix, and if it can't then it produces an error,
      \vskip1ex
      \texttt{vapply()} requires the argument \texttt{FUN.VALUE} that specifes the output format of the function called by \texttt{vapply()},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<>>=
# vectors form columns of matrix returned by sapply
sapply(2:4, function(num) c(el1=num, el2=2*num))
# vectors of different lengths returned as list
sapply(2:4, function(num) 1:num)
# vapply is similar to sapply
vapply(2:4, function(num) c(el1=num, el2=2*num), 
       FUN.VALUE=c(row1=0, row2=0))
# vapply produces an error if it can't simplify
vapply(2:4, function(num) 1:num, 
       FUN.VALUE=c(row1=0, row2=0))
      @
  \end{columns}
\end{block}

\end{frame}



%%%%%%%%%%%%%%%
\section{Homework Assignment}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\secname}
\vspace{-1em}
\begin{block}{Required}
  A file with the homework assignment will be uploaded to NYU Classes,
\end{block}
\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 4-6, 9-10: \fullcite{website:rintro}
    \item Read chapters 3-7, 2, 11: \citetitle{matloffbook}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
